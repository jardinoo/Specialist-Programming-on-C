

                             ГЛАВА 12

                  Построение резидентных программ
     -----------------------------------------------------------------
          В этой главе демонстрируется,  как  концепции  TSR-программ,
     описанные  в  главе  11,  воплощаются  на практике в программы на
     Турбо   Си.   Функции   из   этой   главы   представляют    собой
     программу-драйвер, связав которую с вашей программой на Турбо Си,
     вы получите резидентную программу.  Имеются некоторые ограничения
     на эту   программу.  Первое  -  это  то,  что  в  ней  не  должны
     применяться функции Турбо Си,  вызывающие прерывание ДОС  0х21  с
     номерами  функций  от  0  до 12.  Это означает,  что весь обмен с
     клавиатурой и экраном должен выполняться с помощью  вызовов  BIOS
     или  прямого  доступа к экранной памяти.  В примерах используются
     оконные  функции  из  предыдущих   глав,   удовлетворяющие   этим
     соглашениям.  Второе - TSR-программа должна быть скомпилирована в
     крохотной (tiny) или малой (small) модели памяти.
          В главе  10  демонстрируется  интеграция   всех   предыдуших
     примеров  в  одну программу,  выполняемую под управлением оконных
     меню. В этой главе та же программа превращается в TSR.
          Интегрированный пример использует  файловые  функции  ДОС  и
     выполняет  в  соответствии с этим все правила,  описанные в главе
     11.  По причине сложности этой задачи и для того, чтобы облегчить
     ваше знакомство с программированием TSR, первый пример не требует
     соблюдения этих правил.


          Пример TSR-программы - "часы".
     -----------------------------------------------------------------

          На листинге  12.1  приведена  программа   clock.c,   простая
     TSR-утилита, обеспечивающая постоянное отображение даты и времени
     в верхнем левом углу экрана.  В программе  после  активизации  не
     делаются   вызовы   ДОС,   поэтому   нет   нужды   в   защите  от
     нереентерабельности ДОС.


          Превращение программы в резидентную.
     -----------------------------------------------------------------

          Функция main  производит  все  подготовительные  действия  и
     объявляет себя резидентной.  Сначала она сохраняет свой указатель
     стека,  что позволит затем восстановить свой собственный стек при
     вызове. Затем   в   программе  используется  getvect  для  чтения
     текущего вектора прерывания таймера, после чего с помощью setvect
     в  качестве  обработчика  таймерного  прерывания  устанавливается
     функция newtimer.  Указатель стека TSR-программы  устанавливается
     как   функция   от   объявленного   размера  программы  и  адреса
     видеопамяти,  определяемого  на  основе  значения,  возвращаемого
     функцией vmode. Для получение даты и времени используются функции
     ДОС.












                                                                      180

          Прерывание по делению на ноль.
     -----------------------------------------------------------------

          При старте программ,  написанных  на  Турбо  Си,  выполнение
     начинается со стартового кода. При этом устанавливается начальные
     величины стека и "кучи" и вызывается функция main.  Стартовый код
     находится в  файлах c0t.obj (для крохотной модели) и c0s.obj (для
     малой модели).  Эти файлы  поставляются  вместе  с  Турбо  Си.  В
     стартовом  коде  находится  обработчик  прерывания  по делению на
     ноль,  который присоединяется к  соответствующему  вектору  перед
     вызовом функции main.  При выполнении return из функции main этот
     вектор устанавливается в предыдущее  свое  значение.  Возврат  из
     функции main  нормальной  нерезидентной  программы означает,  что

     программа закончила свои  действия  и  готова  к  завершению.  Но
     TSR-программы не  завершаются выдачей return из функции main. Они
     используют одну из TSR-функций ДОС,  и таким образом должны  сами
     восстанавливать предыдущее значение вектора прерывания по делению
     на ноль до завершения и превращения в резидентную.  Если этого не
     будет сделано, то ошибка деления на ноль в другой программе будет
     обрабатываться стартовым кодом вашей TSR-программы.

          Фирма Borland поставляет  исходные  тексты  стартового  кода
     Турбо Си. Они  находятся  в  файлах  c0.asm  и  rules.asi.    Вам
     понадобится модифицировать c0.asm и ассемблировать его  дважды  -
     для крохотной и малой моделей памяти. Адрес, по которому в c0.asm
     сохраняется  вектор  прерывания  по  делению  на   ноль,   назван
     ZeroDivVector. Эта  переменная  локальна  в  c0.asm.  Чтобы  ваша
     программа могла восстановить значение этого вектора,  к нему надо
     получить    доступ    путем    преобразования   ZeroDivVector   в
     public-переменную. Турбо Си добавляет  символ  _  в  начале  имен
     внешних переменных, и каждое вхождение переменной ZeroDivVector в
     c0.asm вы должны заменить на _ZeroDivVector.  Затем надо заменить
     оператор, объявляющий ZeroDivVector в программе, на следующий:


     PubSym@ ZeroDivVector <dd 0>,_CDECL_

          Ассемблируйте файл дважды с помощью следующих команд:

     C>masm c0,c0t /ML /D_TINY_,
     C>masm c0,c0s /ML /D_SMALL_,

     после чего  будут  созданы  файлы  c0t.obj  и  c0s.obj.  Замените
     исходные файлы Турбо Си на эти.

          Обратите внимание  на объявление в clock.c указателя функции
     прерывания ZeroDivVector. Внешний указатель - это как раз то, что
     вы только  что объявили public в стартовом коде.  В функции main,
     до объявления  себя  резидентной,  clock.c   использует   функцию
     setvect для восстановления вектора прерывания по делению на ноль.
     Затем clock.c завершается с объявлением себя резидентной.

          Если у вас нет исходных текстов стартового кода, можно найти
     следующий  выход:  позволить  TSR-программе  указывать  на ошибку
     деления на ноль,  как только  она  случилась.  При  возникновении
     такой  ошибки  в  другой  программе стартовый код вашей программы

     будет выдавать сообщение  об  ошибке  и  завершать  программу,  в
     точности как  и  соответствующий  обработчик ДОС.  При завершении
     программы ДОС устанавливает вектор прерывания на  свой обработчик
     деления на   ноль.  Ваша  программа  больше  не  будет  работать.
     Конечно,  вы должны удалить ссылки на ZeroDivVector в  clock.c  и
     resident.c.
                                                                      181

          Выполнение обработчика прерываний от таймера.
     -----------------------------------------------------------------

          С каждым "тиканьем часов", происходящим 18.2 раза в секунду,
     вызывается функция newtimer,  объявленная как interrupt  в  Турбо
     Си. Это  объявление  означает,  что  при  вызове функции регистры
     сохраняются в  стеке  и  регистр  сегмента  данных  указывает  на
     сегмент  данных  программы,  с  которой функция связана с помощью
     link. Такое объявление также гарантирует восстановление регистров
     из стека и выполнение машинной команды IRET при завершении работы
     функции. Команда  IRET  используется   обычно   для   выхода   из
     обработчика прерывания. Она восстанавливает регистры программного
     счетчика,  флагов и сегмента кодов, сохраненные при возникновении
     прерывания.



          Связывание старого вектора прерывания по таймеру.
     -----------------------------------------------------------------

          При выполнении newtimer прежде всего  вызывается  обработчик
     прерывания, на который указывает oldtimer. Это действие позволяет
     другим  программам,  уже  присоединенным  к  вектору,  произвести
     необходимые действия.  Функция  newtimer проверяет флаг,  который
     устанавливает сама же эта функция,  и  означающий,  что  она  еще
     работает.



          Сохранение и переключение контекста стека.
     -----------------------------------------------------------------

          Функция newtimer  сохраняет   сегмент   стека   и   регистры
     указателей -   эти  величины  принадлежат  прерванному  процессу.
     Значения стековых регистров,  сохраненные при выполнении clock.c,
     восстанавливаются в регистрах процессора,  поэтому clock. c может
     использовать свой собственный стек и не портить  стек  прерванной
     программы.



          Вычисление времени.
     -----------------------------------------------------------------

          Функция newtimer   подсчитывает   сигналы    таймера.    При
     прохождении 18  сигналов  (19  каждый пятый раз,  так как сигналы
     приходят 18.2 раза в секунду), новая величина времени вычисляется
     для отображения на экран.

          Затем дата и время отображаются в верхнем левом углу экрана,
     восстанавливаются значения регистров стека  прерванной программы,
     и newtimer возвращает ей управление.












                                                                      182

          Заметим, что  newtimer  не  переводит  дату  в  полночь и не
     изменяет значения на экране после  ввода  новых  даты  и  времени
     командой ДОС.  Эта  программа лишь иллюстрирует работу простейшей
     TSR-программы. Если вы не работаете  после  полуночи,  вы  можете
     использовать ее  для  отображения  даты и времени на экране.  Она
     обновляет значения каждую секунду, поэтому вывод на экран другими
     программами ничего не испортит. В качестве эксперимента вы можете
     добавить будильник  в  clock.c.  Включите   время,   когда   надо
     "звонить",  как  параметр,  передаваемый  в  командной строке при
     первом запуске clock.exe.  Затем,  при каждом изменении  значения
     часов сравнивайте  его  с  этим  временем.  При равенстве времен,
     выдайте  звуковой  сигнал,  избегая,  естественно,  использования
     функций ДОС.   Позднее,   когда   вы  узнаете,  как  использовать
     коммуникационный вектор  прерывания,  вы  сможете  модифицировать
     clock.c  для  установки  и изменения времени звонка путем запуска
     clock.exe из командной строки с параметром в то  время,  как  TSR
     уже  резидентна.  Вы  можете  добавить комментарии к звонку путем
     использования оконных функций и оконного редактора.  Путем именно
     таких  последовательных  улучшений были созданы программы мировой
     известности.

          Программа clock.c использует прерывание от таймера.  Если вы
     загрузите  ее  после  Sidekick,  часы  перестанут идти при вызове
     Sidekick. Так как newtimer просто считает секунды,  а  не  читает
     время  ДОС,  такая  смесь  программы  с  Sidekick'ом  сделает  ее
     результаты неверными.  Sidekick  отбирает  вектор  прерывания  от
     таймера  у  любой  TSR-программы,  загружаемой после него,  чем и
     вызыает такой результат.  Остерегайтесь Sidekick'а  при  загрузке
     ваших резидентных программ.

          Чтобы запустить "часы", введите следующую команду:

     C>clock

               ( Листинг 12.1 ).

     /*--------- clock.c -----------*/

     #include <dos.h>

     void interrupt (*oldtimer)();
     void interrupt newtimer();
     extern void interrupt (*ZeroDivVector)();
     #define sizeprogram 375
     unsigned intsp,intss;
     unsigned myss,stack;
     static union REGS rg;
     struct date dat;
     struct time tim;
     unsigned vseg;
     int running = 0;
     char bf[20];
     unsigned v;
     char tmsk []= " %2d-%02d-%02d %02d:%02d:%02d ";
     int ticker = 0;

     static struct SREGS seg;







                                                                      183

     main()
     {
       segread(&seg);

       myss = _SS;

       oldtimer = getvect(0x1c);
       setvect(0x1c,newtimer);
       stack = (sizeprogram - (seg.ds - seg.cs))*16-300;
       vseg = vmode() == 7 ? 0xb000 : 0xb800;

       gettime(&tim);
       getdate(&dat);

       setvect(0,ZeroDivVector);

       rg.x.ax = 0x3100;
       rg.x.dx = sizeprogram;
       intdos(&rg,&rg);
     }

     void interrupt newtimer()
     {
       (*oldtimer)();
       if (running ==0)
       {
          running = 1;
          disable();
          intsp = _SP;
          intss = _SS;
          _SP = stack;
          _SS = myss;
          enable();
          if (ticker ==0)
          {
             ticker = (((tim.ti_sec % 5) ==0)? 19 :18 );
             tim.ti_sec++;
             if (tim.ti_sec == 60)
             {
                tim.ti_sec =0;
                tim.ti_min++;
                if (tim.ti_min == 60)
                {
                    tim.ti_min=0;
                    tim.ti_hour++;
                    if (tim.ti_hour == 24)
                        tim.ti_hour = 0;
                 }
              }
              sprintf(bf,tmsk,dat.da_day,dat.da_man,dat.da_year % 100,
                      tim.ti_hour,tim.ti_min,tim.ti_sec);
           }

           for (v=0;v<19;v++)
              vpoke (vseg,(60+v)*2,0x7000+bf[]);

           disable();
           _SS = intsp;
           _SS = intss;
           enable();
           running = 0;

        }
      }
                                                                      184

          Файл проекта для построения  clock.exe  с  именем  clock.prj
     имеет следующий вид:

     Листинг 12.2: clock.prj

     clock
     ibmpc.obj



               ПРОГРАММЫ TSR-ДРАЙВЕРА.
     -----------------------------------------------------------------

          Чтобы расширить  возможности  TSR-программ  по использованию
     функций ДОС при ее вызове,  в этой главе приводится два  исходных
     текста  на  Си.  После  их  адаптации и связи с любой стандартной
     программой на Си,  та становится резидентной  программой.  Первый
     текст   содержит  функцию  main,  и  туда  помещаются  параметры,
     зависящие  от  вашей  программы.  Второй  файл  -  это   основной
     TSR-драйвер,   управляющий  присоединением  векторов  прерываний,
     самих прерываний,  арбитраж столкновений ДОС и BIOS, определение,
     резидентна ли уже программа,  приостановка и возобновление работы
     TSR-программы, и удаление TSR-программы из памяти.

          Третий модуль в этом наборе - ваша прогррамма на Си, которая
     должна   придерживаться   следующих   правил,   чтобы   правильно
     выполняться в этом окружении:

          - программа должна быть  построена  в  крохотной  или  малой
     моделях памяти;
          - программа не должна использовать функций ДОС от 0 до 12;
          - при изменении текущего дискового каталога программа должна
     восстанавливать его при возврате в прерванную программу;
          - программа  не  должна  использовать  операции  с плавающей
     запятой;
          - программа не должна завершаться или выходить в ДОС.

          Вас может заинтересовать, почему надо избегать использования
     операций с  плавающей  запятой.  Дело  в  том,  что  подпрограммы
     с плавающей  запятой Турбо Си используют ряд векторов прерываний,
     которые присоединяются во время выполнения стартового  кода.  Эти
     вектора  не  восстанавливаются до завершения программы и передачи
     управления при  этом  в  стартовый  код.  В  стартовом  коде   не
     поддерживается   область  сохранения  для  этих  векторов  (среди
     которых имеется и  вектор  немаскируемого  прерывания  2);  таким
     образом,  при  завершении  работы  TSR-программы и удалении ее из
     памяти эти векторы не будут восстанавливаться.

          В этолй главе используются программа exec.c из  главы  10  и
     все   примеры   оконных   программ   практически   готовых  стать
     резидентными.













                                                                      185


               Действия трех программных модулей.
     -----------------------------------------------------------------

          Три программных  модуля  для  TSR-программ  -  это  popup.c,
     resident.c и ваша утилита на Турбо Си.  Popup.c (листинг 12.3)  и
     resident.c (листинг 12.4) содержат сам TSR-драйвер. Popup.c - это
     модуль,  который надо изменить соответственно  требованиям  вашей
     утилиты,  а  resident.c - модуль,  остающийся неизменным для всех
     TSR-программ.  В дальнейшем  обсуждении  мы  будем  переключаться
     между двумя этими модулями, так как они оба созданы для поддержки
     создания вами TSR-программ.

          Popup.c содержит   кроме    любого    установочного    кода,
     необходимого  вам,  еще  и  несколько  переменных,  которые  надо
     инициализировать значениями, описывающими вашу программу.



               Размер TSR-программы.
     -----------------------------------------------------------------

          Беззнаковая переменная   sizeprogram   специфицирует  размер
     программы в параграфах по 16 байт.  Вы уже прочитали в главе  11,
     как определять это значение.  До тех пор,  пока ваша программа не
     начнет действовать,  увеличивайте  это  значение.   Программа   в
     крохотной модели не может быть больше, чем 64К (4096 параграфов),
     а в малой модели - больше 128К (8192 параграфов).



               Присвоение "горячего ключа".
     -----------------------------------------------------------------

          Значение клавиши "горячего ключа" TSR-программы определяется
     значениями беззнаковых переменных scancode и keymask. При нажатии
     клавиши  обработчик прерывания 09 читает входной порт клавиатуры,
     в котором  находится  скан-код  клавиши  (ее  порядковый  номер).
     Каждая клавиша имеет свой скан-код, которые изображены на рисунке
     12.1. Следовало  бы  присваивать  такие   клавиши,   которые   не
     совпадали   бы  с  клавишами  других  программ,  в  том  числе  и
     нерезидентных. Стоит избегать функциональных клавиш, комбинаций с
     Alt- и Ctrl-,  так как многие программы их используют.  Наилучшим
     выбором является редкая и оригинальная комбинация  клавиш, такая,
     как Alt-точка.



















                                                                      186


     ┌─────────────────────────────────────────────────────────────────┐
     │┌──┬──┐┌──┬─┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐┌──┬──┬──┬──┐│
     ││59│60││41│2│ 3│ 4│ 5│ 6│ 7│ 8│ 9│10│11│12│13│43│14││1 │69│70│84││
     │├──┼──┤├──┴┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴──┤├──┼──┼──┼──┤│
     ││61│62││15 │16│17│18│19│20│21│22│23│24│25│26│27│   ││71│72│73│55││
     │├──┼──┤├───┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┘ 28│├──┼──┼──┼──┤│
     ││63│64││ 29 │30│31│32│33│34│35│36│37│38│39│40│     ││75│76│77│74││
     │├──┼──┤├────┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴─────┤├──┼──┼──┼──┤│
     ││65│66││ 42  │44│45│46│47│48│49│50│51│52│53│  54   ││79│80│81│  ││
     │├──┼──┤├────┬┴─┬┴──┴──┴──┴──┴──┴──┴──┴──┴──┼─┬─────┤├──┴──┼──┤78││
     ││67│68││ 56 │  │          57               │ │ 58  ││ 82  │83│  ││
     │└──┴──┘└────┘  └───────────────────────────┘ └─────┘└─────┴──┴──┘│
     │                                                                 │
     │                    Клавиатура IBM AT                            │
     │                                                                 │
     │                                                                 │
     │┌──┬──┐┌──┬─┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬─────┐┌─────┬─────┐│
     ││59│60││ 1│2│ 3│ 4│ 5│ 6│ 7│ 8│ 9│10│11│12│13│ 14  ││ 69  │ 70  ││
     │├──┼──┤├──┴┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬┴─┬───┤├──┬──┼──┬──┤│
     ││61│62││15 │16│17│18│19│20│21│22│23│24│25│26│27│   ││71│72│73│74││
     │├──┼──┤├───┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┐28│├──┼──┼──┼──┤│
     ││63│64││ 29 │30│31│32│33│34│35│36│37│38│39│40│41│  ││75│76│77│  ││
     │├──┼──┤├────┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴┬─┴──┼──┤├──┼──┼──┤  ││
     ││65│66││ 42  │44│45│46│47│48│49│50│51│52│53│ 54 │55││79│80│81│78││
     │├──┼──┤├────┬┴─┬┴──┴──┴──┴──┴──┴──┴──┴──┴┬┬┴───┬┼──┴┴┬─┴──┴──┤  ││
     ││67│68││ 56 │  │          57             ││ 58 ││ 82 │   83  │  ││
     │└──┴──┘└────┘  └─────────────────────────┘└────┘└────┴───────┴──┘│
     │                                                                 │
     │                    Клавиатура IBM PC                            │
     └─────────────────────────────────────────────────────────────────┘

                           Рис.12.1. Скан-коды клавиатуры.

          Обнаружение комбинации  клавиш облегчается при использовании
     маски статуса по адресу 0:417,  содержащей биты для клавиш  Ctrl,
     Alt,  Shift,  Ins, Caps Lock и Scroll Lock. Эта маска показывает,
     какая из  этих  клавиш  в  текущий  момент  нажата.  На  рис.12.2
     показано положение битов в маске.

     ┌──────┬───────┬───────┬────────┬───────┬───────┬───────┬───────┐
     │  INS │  CAPS │  NUM  │ SCROLL │  ALT  │  CTRL │ LEFT  │ RIGHT │
     │      │  LOCK │  LOCK │  LOCK  │       │       │ SHIFT │ SHIFT │
     └──────┴───────┴───────┴────────┴───────┴───────┴───────┴───────┘

                                Рис.12.2.

          Если соответствующий бит в маске установлен в 1,  то клавиша
     нажата.  По  скан-коду  нажатой  клавиши  и значению бита в маске
     обработчик прерываний от клавиатуры может определить,  нажата  ли
     клавиша "горячего ключа". Чтобы специфицировать эти значения, вам
     надо  присвоить  значения  переменным  scancode   и   keymask   в
     popup.c. Как  показано в листинге,  scancode равен 52,  и keymask
     равен 8, что соответствует Alt-точка.










                                                                      187


               Сигнатура TSR-программы.
     -----------------------------------------------------------------

          Программа popup.c   также  обеспечивает  сигнатуру,  которая
     используется для определения, не резидентна ли уже TSR-программа.
     Символьный    массив   с   именем   signature   -   это   строка,
     заканчивающаяся \0.

          При первом старте popup.c  вызывает  функцию  resident.  Она
     находится   в   resident.c,   ее  задачей  является  определение,
     резидентна ли уже программа,  и если нет,  определить и назначить
     коммуникационный вектор.      Это      делается     сканированием
     пользовательских векторов прерываний от 0х60 до 0х67. Если какой-
     либо  вектор  содержит  значение,  то  сегментная  половина этого
     значения комбинируется со смещением сигнатуры  в  программе.  Это
     смещение  является  указателем  на  сигнатуру,  то есть смещением
     относительно регистра сегмента данных.  Сегментная часть  вектора
     суммируется с разницей между значениями регистров сегмента кода и
     сегмента данных.

          Помните, что  значение  сегментного  регистра,   взятое   из
     вектора, должно   быть   значением  сегмента  кода  первоначально
     стартовавшей  TSR-программы.  Сигнатура  имеется  как  в  области
     данных TSR-программы, так и в области данных копии TSR-программы,
     которая пытается стать резидентной.  Нам нужен  сегментный  адрес
     данных  TSR-программы,  который не сохраняется в коммуникационном
     векторе. Это значение должно быть вычислено.

          Программа, просматривающая векторы,  является второй  копией
     TSR-программы (в предположении, что TSR-программа уже загружена),
     поэтому разность значений регистров кода и данных  у  нее  должна
     быть такой же,  как и у уже резидентной программы. Пользуясь этим
     алгоритмом, вы сравниваете значение по соответствующим смещением,
     и  если  они  одинаковы,  то  программа уже загружена,  и функция
     resident вернет найденный вектор в функцию main в  popup.с.  Если
     сигнатуры  не  равны,  сканирование  продолжается,  пока не будут
     проверены все векторы.  Если определяется,  что TSR-программа еще
     не   резидентна,   то   первый   подходящий   вектор   становится
     коммуникационным. В функцию main возвращается  0,  что  означает,
     что программа стала резидентной.



               Коммуникационные прерывания.
     ----------------------------------------------------------------

          Если функция main  обнаруживает,  что  копия  программы  уже
     резидентна,    она    проверяет   параметры   командной   строки.
     Используемая техника позволяет передавать при  запуске  программы
     параметры для  ее  резидентной  копии.  Напомним,  что  в  памяти
     имеется в этот момент две копии  TSR-программы  -  резидентная  и
     только что  загруженная  в  нерезидентную область.  Нерезидентная
     версия   может   связываться   с   резидентной    копией    через
     коммуникационный вектор.  В  типичной  TSR-программе используются
     три   параметра,   но    вы    можете    добавить    еще,    если
     необходимо. Стандартные   три   позволяют   пользователю  удалять
     программу  из  памяти,   приостанавливать   и   возобновлять   ее
     выполнение. Если один из этих параметров присутствует в командной
     строке (это определяется при помощи args,argv),  то  генерируется
     программное   прерывание,   с   установлением   регистра   ax   в
     соответствующее опции значение.  Прерывание генерируется функцией
     main нерезидентной копии TSR-программы.

                                                                      188


          Посмотрим далее  на  листинг  popup.c.  Функция прерывания с
     именем ifunc является обработчиком  коммуникационного прерывания.
     Когда  функция  main нерезидентной копии TSR-программы инициирует
     прерывание,  вызывается  обработчик  из  резидентной  копии.   Он
     проверяет  значение  регистра  ax  и  производит  соответствующие
     действия. При этом вызывается одна из  трех  функций:  terminate,
     restart  или wait в resident.c.  Вы можете вставить сюда и другую
     логику, чтобы управлять состоянием резидентной программы.

          Функции wait и restart в resident.c просто  устанавливают  и
     очищают флаг, означающий для обработчика клавиатуры необходимость
     реакции на нажатие клавиши "горячего ключа".

          Функция terminate в resident.c должна определять,  может  ли
     быть завершена TSR-программа,  и затем,  если да, производить все
     действия,  аналогичные действиям ДОС при завершении нерезидентной
     программы. Этот  процесс  будет  обсуждаться  после того,  как вы
     поймете, как программа становится резидентной.



               Подготовка к резидентности.
     -----------------------------------------------------------------

          Если функция  resident обнаруживает,  что программа еще не в
     памяти,  то popup.c подготавливает себя к переходу в резидентные.
     ваша  программа  захочет открыть файлы или сделать еще что-нибудь
     "по хозяйству"  при  ее  вызове.  Popup.c,  взятая  для  примера,
     вызывает  load_help  для  установки  функций  помощи  из главы 7,
     устанавливает путь ДОС для использования  программой  notepad  из
     главы 9,  и выдает сообщение. Потом она вызывает resinit, функцию
     из resident.c,  которая делает  все  остальное,  чтобы  программа
     стала резидентной.

          Первоначально, resinit  сохраняет значение регистра сегмента
     стека для переключения контекста стеков при вызове TSR-программы.
     Затем  читается  флаг  занятости  ДОС с помощью функции ДОС 0х34.
     Функция getdta получает адрес дискового буфера для TSR-программы.
     Этот   адрес   также  используется  при  дальнейшем  переключении
     контекстов. Адрес идентификатора процесса (PID) восстанавливается
     и  сохраняется.  Эта  техника  объяснялась  в  главе 11.  Векторы
     прерывания для таймера,  клавиатуры,  диска и  DOSOK  читаются  и
     запоминаются  для связывания прерываний в цепочки,  и собственные
     обработчики присоединяются к этим  прерываниям.  Указатель  стека
     TSR-программы вычисляется так, чтобы быть на 300 байт меньше, чем
     размер  программы,   и   вектор   обработки   деления   на   ноль
     восстанавливается на то значение,  которое он имел до того ,  как
     стартовый код присоединил его. Затем TSR-функция ДОС используется
     для завершения программы, оставляя ее резидентной.














                                                                      189


               Обработчик обращения к диску.
     -----------------------------------------------------------------

          В то время,  как компьютер выполняет программу,  и программа
     вызывает ДОС,  ДОС использует дисковое прерывание BIOS (0х13) для
     чтения и записи секторов данных. Напомним, что в главе 11 вас уже
     предупреждали  о  том,  что  дисковые  операции прерывать нельзя.
     Обработчику диска в resident.c дано имя newdisk,  и  он  защищает
     дисковые   операции   от  прерывания  вашей  TSR-программой.  При
     возникновении прерывания 0х13 устанавливается флаг, а после этого
     управление передается   на  обработку  дисковых  операций.  После
     окончания обработки флаг очищается.  Если этот  флаг  установлен,
     когда программа   вызывается  по  нажатию  "горячего  ключа",  то
     производится задержка выполнения до очистки этого флага.

          Обратите внимание на трюк в newdisk.  Функция, описанная как
     interrupt,  сохраняет все регистры в стеке, устанавливает регистр
     ds на сегмент данных программы,  содержащей  эту  функцию.  Затем
     начинается   выполнение  кода  функции.  При  завершении  функции
     регистры  восстанавливаются,  и  выполняется   машинная   команда
     IRET. Эта команда восстанавливает регистры программного счетчика,
     сегмента  кода  и  флажков.  Таким  образом,  выполняется  полное
     восстановление регистров прерванной программы.

          Все работает  до  тех  пор,  пока  вы  не имеете прерывания,
     которое  возвращает  условие  в  флаге  переноса.  Команда   IRET
     восстанавливает   все   флаги   в  состояние,  которое  было  при
     возникновении прерывания.  Некоторые программные прерывания ДОС и
     BIOS используют этот флаг для индикации результата.  В их числе и
     прерывание 0х13 BIOS;  однако программа обработчика  обращений  к
     диску сохраняет значение флажка переноса.  Когда заканчивает свои
     действия присоединенный обработчик  olddisk,  необходимо  вернуть
     вызывавшему процессу два значения:  регистр ax и флажок переноса.
     Значение ax берется из псевдопеременной _AX и помещается  в целую
     переменную ax, являющуюся одним из параметров функции прерывания.
     Турбо Си  использует  это  средство,  чтобы   изменять   значения
     регистров,  которые  будут восстановлены из стека при возврате из
     функции. Для  регистра  флагов  псевдопеременной  нет,  и,  чтобы
     избежать   программирования  на  ассемблере,  делается  следующий
     хэккерский трюк:  за функцией newdisk может быть сразу же вызвана
     функция  newcrit,  и она запишет флаговый регистр,  сохраненный в
     стеке при ее вызове, во внешнюю переменную cflag. При возврате из
     newcrit  cflag  записывается  в стек,  где было сохранено прошлое
     значение регистра флагов.При возврате из  функции  результирующие
     флаги из olddisk будут восстановлены в регистр флагов.

          Эти действия  базируются  на  понимании  того,  как Турбо Си
     использует регистры и производится вызов  и  возврат  из  функций
     interrupt.  Таким образом,  эти программы не переносимы на другой
     компилятор,  и могут быть несовместимы даже с  будущими  версиями
     Турбо Си,  если Borland изменит свои соглашения.  Программисты на
     ассемблере,  возможно, скажут, что подобные дествия можно было бы
     легко проделать на их любимом языке.  Эта критика верна,  но этот
     программный  трюк  является  примером,  как  достигнуть  пределов
     возможностей Турбо  Си.  Автор благодарен Турбо Си за тот сервис,
     который предоставляется для разрешения всех  проблем, возникающих
     при создании TSR-программ.






                                                                      190


               Обработчик критических ситуаций.
     -----------------------------------------------------------------

          Функция interrupt с именем newcrit  является  присоединенным
     обработчиком критических   ситуаций.   Она  не  присоединяется  к
     прерыванию,  когда программа объявляет себя резидентной, а делает
     это лишь  временно,  при  "всплытии" TSR-программы.  Его задача -
     обезопасить TSR-программу от возникновения критических  ошибок  в
     то время,  как  она  переключила  контекст  на  себя.  Обработчик
     возвращает ноль в регистре ax,  что означает для ДОС игнорировать
     ошибку.



               Обработчик клавиатуры.
     -----------------------------------------------------------------

          Функция interrupt  с  именем  newkb  является   обработчиком
     клавиатуры для TSR-программы. Она читает порт данных клавиатуры и
     проверяет на соответствие  определенному  скан-коду,  означающему
     нажатие  клавиши   "горячего   ключа".   При   равенстве  и  если
     TSR-программа не приостановлена,  "горячий ключ"  активизируется.
     Функция сбрасывает клавиатуру,  чтобы не было будущих прерываний,
     и затем проверяет,  а не вызвана ли уже TSR-программа.  Если нет,
     то устанавливается флаг,  означающий, что нажат "горячий ключ", и
     выполнение функции заканчивается.

          Если  скан-код и маска статуса не равны "горячему ключу", то
     управление  передается  старой  программе обработки прерываний от
     клавиатуры.



               Обработчик таймера.
     -----------------------------------------------------------------

          Каждый импульс  таймера вызывает выполнение функции newtimer
     в  resident.c.  Прежде  всего  она  вызывает  старый   обработчик
     таймера. Затем  она проверяет,  не нажат ли "горячий ключ".  Если
     да, то проверяется флажок занятости ДОС.  Если ДОС не занята,  то
     newtimer  проверяет,  не  производится  ли в этот момент дисковая
     операция. Если  нет,  то  сбрасывается  прерывание  от   таймера,
     очищается  флажок  "горячего ключа",  и вызывается функция dores,
     начинающая выполнение TSR-программы.



               Обработчик DOSOK.
     -----------------------------------------------------------------

          Прерывание DOSOK обслуживается обработчиком с именем new28 в
     resident.c.  Он  присоединяется  к  старому   обработчику   этого
     прерывания, и   проверяет   флажок   "горячего  ключа".  Если  он
     установлен,  то проверяется,  занята ли ДОС,  и  затем  очищается
     флажок "горячего ключа" и вызывается dores.








                                                                      191

               Выполнение TSR-программы.
     -----------------------------------------------------------------

          Функция dores вызывается  лишь  после  того,  как  программа
     убедилась  в  безопасности своего выполнения.  Dores прежде всего
     устанавливает  флажок,  означающий,  что  она  выполняется.   Эта
     установка  предохраняет  от  повторного  вызова  путем вторичного
     нажатия  "горячего  ключа".  Затем  сохраняется   регистр   стека
     прерванной   программы,  и  указатель  стека  устанавливается  на
     собственный стек TSR-программы.

          Сохраняется вектор прерывания по критической  ошибке,  затем
     соответствующий   обработчик   присоединяется  к  этому  вектору.
     Текущий статус Ctrl-Break сохраняется, и прерывания по Ctrl-Break
     запрещаются.

          Адрес дискового  буфера прерванной программы сохраняется,  и
     устанавливается на  соответствующий  текущему  контексту.  То  же
     производится и   с  идентификатором  процесса.  Затем  вызывается
     утилита popup  из  popup.c.  Функция  popup   сохраняет   текущее
     положение курсора,  вызывает вашу программу,  после ее выполнения
     восстанавливает курсор  и  заканчивается.  В   листинге   popup.c
     вызывается  функция  exec,  вы  можете  подставить туда имя вашей
     программы.

          При завершении   popup   адреса   идентификатора   процесса,
     дискового буфера, вектор прерывания по критической ошибке, статус
     Ctrl-Break и указатель стека  восстанавливаются  в  те  значения,
     которые они имели до вызова TSR-программы,  и выполняется возврат
     в прерванную программу.



               Удаление TSR-программы.
     -----------------------------------------------------------------

          При удалении  пользователем  TSR-программы  путем запуска ее
     копии  с   соответствующим   параметром   в   командной   строке,
     нерезидентная  копия  вызывает резидентную через коммуникационное
     прерывание.  Функция terminate в resident.c проверяет,  может  ли
     быть  снята программа путем просмотра,  не изменились ли значения
     векторов прерываний.  Если изменились,  выполнение  TSR-программы
     приостанавливается. Если нет, она может быть снята.

          Для удаления    TSR-программы   необходимо   проделать   три
     процедуры. Сначала все  файлы  должны  быть  закрыты.  Когда  ДОС
     завершает  программу,  она  проверяет  все 20 элементов в массиве
     указателей файлов в PSP.  Эта процедура закрывает  все  файлы  на
     уровне указателей и не затрагивает потоковых файлов.  Так как эти
     файлы  должны  быть  закрыты,  то  terminate   вызывает   функцию
     closefiles в popup.c, закрывающую все открытые файлы.

           Вторая процедура  - восстановление всех векторов прерываний
     в  значение,  которое  они  имели  до  присоединения  их  к  себе
     TSR-программой.

          Завершающим шагом  является освобождение всех блоков памяти,
     распределенных под  TSR-программу.  Память  распределяется  двумя
     способами -  из  ДОС и из программы через вызов функций ДОС.  Эти
     два типа блоков памяти должны освобождаться тем же путем, которым
     и выделялись.



                                                                      192


               Блоки памяти и управляющие блоки памяти.
     -----------------------------------------------------------------

          Выделяемый ДОС  блок   памяти   содержит   16-байтный   блок
     управления  памятью  (БУП),  следующий  сразу  за соответствующим
     распределяемым блоком памяти. Он содержит следующие поля:

          - однобайтный  маркер,  идентифицирующий  БУП.  Все,   кроме
     последнего БУП в списке,  имеют значение маркера 0x4d.  Последний
     БУП имеет маркер 0x5a.

          - двубайтный идентификатор  процесса,  которому  принадлежит
     блок памяти. Если блок свободен, это поле содержит 0.

          - двубайтный размер блока памяти в параграфах. Размер БУП не
     учитывается в этом значении. БУП следует в памяти непосредственно
     за блоком памяти, который он представляет. Связки БУП-блок памяти
     располагаются в памяти смежно.  Сегментный адрес  следующего  БУП
     равен  адресу  предыдущего БУП + размер блока памяти + 1.  Если у
     вас есть адрес первого БУП в памяти,  то  можете  проследить  всю
     цепочку.

          В ДОС  имеется  функция (естественно,  недокументированная),
     которая может быть использована для  определения  адреса  первого
     БУП в  цепочке.  Эта  функция  0х52  возвращает  сегментный адрес
     первого БУП в регистре es и смещение  в  регистре bx. Эффективный
     адрес  этой пары сегмент: смещение, уменьшенный на 2,  дает адрес
     слова,  содержащего  сегментный  адрес  первого  БУП  в   цепочке
     распределенных ДОС блоков памяти.

          Для освобождения памяти,  занимаемой TSR-программой,  должен
     быть просмотрен  весь  список  БУП.   Каждый   блок,   содержащий
     идентификатор  процесса(PID)  TSR-программы,  освобождается путем
     обращения к функции  ДОС  0х49.  При  завершении  этого  процесса
     TSR-программа завершается и удаляется из памяти.



               ИСХОДНЫЕ ТЕКСТЫ: popup.c, resident.c
     -----------------------------------------------------------------

          Листинги 12.3 и 12.4 содержат текст TSR-драйвера.  Эти файлы
     после компиляции  и  связывания  с  вашей  программой на Турбо Си
     сделают ее резидентной.

          Листинг 12.3.
          -------------

     /*----  popup.c ----*/

     #include <dos.h>
     #include <stdio.h>
     #include <string.h>
     #include <dir.h>

     static union REGS rg;

     unsigned sizeprogram = 48000/16;
     unsigned scancode = 52;
     unsigned keymask = 8;
     char *signature = "POPUP";

     char notefile[64];
                                                                      193

     /*--------------------------------*/
     int  resident(char *,void interrupt(*)());
     void resinit(void);
     void terminate(void);
     void restart(void);
     void wait(void);
     void resident_psp(void);
     void interrupted_psp(void);
     void exec(void);
     void cursor(int,int);
     void curr_cursor(int *,int *);

     main(argc,argv)
     char *argv[];
     {
       void interrupt ifunc();
       int ivec;

       if((ivec = resident(signature, ifunc)) != 0) {
         if(argc > 1) {
            rg.x.ax = 0;
            if(strcmp(argv[1],"quit") == 0)
               rg.x.ax = 1;
            else if(strcmp(argv[1],"restart") == 0)
               rg.x.ax = 2;
            else if(strcmp(argv[1],"wait") == 0)
               rg.x.ax = 3;
            if(rg.x.ax)  {
               int86(ivec, &rg, &rg);
               return;
           }
        }
        printf("\n Popup is already resident");
      }
      else   {

        /*load_help("tcprogs.hlp");
        getcwd(notefile, 64);
        if(*(notefile+strlen(notefile)-1) != '\\')
          strcat(notefile,"\\");
        strcat(notefile,"note.pad"); */

        printf("\nResident popup is loaded");
        resinit();
      }
     }

     /*--------------------------------*/
     void interrupt ifunc(bp,di,si,ds,es,dx,cx,bx,ax)
     {
        if(ax == 1)       /* quit */
          terminate();
        else if(ax == 2)  /* restart */
          restart();
        else if(ax == 3)  /* wait */
          wait();
     }







                                                                      194

     /*--------------------------------*/
     /*void closefiles()
     {
      extern FILE *helpfp;

       resident_psp();
       if(helpfp)
         fclose(helpfp);
       interrupted_psp();
     } */

     /*--------------------------------*/
     void popup()
     {
       int x,y;

       curr_cursor(&x, &y);
       exec();
       cursor(x,y);
     }

     /*--------------------------------*/
     void cursor(int x, int y)
     {
       rg.x.ax=0x0200;
       rg.x.bx=0;
       rg.x.dx=((y<<8) &0xff00) + x;
       int86(16,&rg,&rg);
     }
     /*--------------------------------*/
     void curr_cursor(int *x, int *y)
     {
       rg.x.ax=0x0300;
       rg.x.bx=0;
       int86(16,&rg,&rg);
       *x=rg.h.dl;
       *y=rg.h.dh;
     }


























                                                                      195

          Листинг 12.4.
          -------------

     /*---- resident.c ----*/

     #include <dos.h>
     #include <stdio.h>

     static union REGS rg;
     static struct SREGS seg;
     static unsigned mcbseg;
     static unsigned dosseg;
     static unsigned dosbusy;
     static unsigned enddos;
     char far *intdta;
     static unsigned intsp;
     static unsigned intss;
     static char far *mydta;
     static unsigned myss;
     static unsigned stack;
     static unsigned ctrl_break;
     static unsigned mypsp;
     static unsigned intpsp;
     static unsigned pids[2];
     static int pidctr = 0;
     static int pp;
     static void interrupt (*oldtimer)();
     static void interrupt (*old28)();
     static void interrupt (*oldkb)();
     static void interrupt (*olddisk)();
     static void interrupt (*oldcrit)();
     static void interrupt (*ZeroDivVector)();
     void interrupt newtimer();
     void interrupt new28();
     void interrupt newkb();
     void interrupt newdisk();
     void interrupt newcrit();
     extern unsigned sizeprogram;
     extern unsigned scancode;
     extern unsigned keymask;
     static int resoff = 0;
     static int running = 0;
     static int popflg = 0;
     static int diskflag = 0;
     static int kbval;
     static int cflag;

     void dores(),pidaddr();
     /*------------------------------------------------*/
     void resinit()
     {
       segread(&seg);
       myss=seg.ss;

       rg.h.ah=0x34;
       intdos(&rg, &rg);
       dosseg = _ES;
       dosbusy=rg.x.bx;

       mydta=getdta();

       pidaddr();


                                                                      196

       oldtimer=getvect(0x1c);
       old28=getvect(0x28);
       oldkb=getvect(9);
       olddisk=getvect(0x13);

       setvect(0x1c,newtimer);
       setvect(0x9,newkb);
       setvect(0x28,new28);
       setvect(0x13,newdisk);

       stack=(sizeprogram - (seg.ds - seg.cs)) * 16 - 300;

       setvect(0,ZeroDivVector);

       rg.x.ax=0x3100;
       rg.x.dx=sizeprogram;
       intdos(&rg, &rg);
     }

     /*------------------------------------------------*/
     void interrupt newdisk(bp,di,si,ds,es,dx,cx,bx,ax,ip,cs,flgs)
     {
       diskflag++;
       (*olddisk)();
       ax=_AX;
       cx=_CX;
       dx=_DX;
       newcrit();
       flgs=cflag;
       --diskflag;
     }

     /*------------------------------------------------*/
     void interrupt newcrit(bp,di,si,ds,es,dx,cx,bx,ax,ip,cs,flgs)
     {
       ax=0;
       cflag=flgs;
     }

     /*------------------------------------------------*/
     void interrupt newkb()
     {
       if(inportb(0x60) == scancode) {
         kbval=peekb(0,0x417);
         if(!resoff && ((kbval & keymask) & keymask) == 0) { /* !!!!!!! & *
     /
           kbval=inportb(0x61);
           outportb(0x61,kbval|0x80);
           outportb(0x61,kbval);
           outportb(0x20,0x20);
           if(!running)
             popflg=1;
           return;
        }
      }
      (*oldkb)();
      }







                                                                      197

     /*------------------------------------------------*/
     void interrupt newtimer()
     {
       (*oldtimer)();
       if(popflg && peekb(dosseg, dosbusy) == 0)
         if(diskflag == 0) {
           outportb(0x20,0x20);
           popflg=0;
           dores();
         }
     }

     /*------------------------------------------------*/
     void interrupt new28()
     {
       (*old28)();
       if(popflg && peekb(dosseg, dosbusy) != 0) {
           popflg=0;
           dores();
         }
     }

     /*------------------------------------------------*/
     resident_psp()
     {
       intpsp=peek(dosseg,*pids);
       for(pp=0; pp < pidctr; pp++)
         poke(dosseg,pids[pp],mypsp);
     }

     /*------------------------------------------------*/
     interrupted_psp()
     {
       for(pp=0; pp < pidctr; pp++)
         poke(dosseg,pids[pp],intpsp);
     }
     /*------------------------------------------------*/
     void dores()
     {
       running=1;
       disable();
       intsp=_SP;
       intss=_SS;
       _SP=stack;
       _SS=myss;
       enable();
       oldcrit = getvect(0x24);
       setvect(0x24,newcrit);
       rg.x.ax=0x3300;
       intdos(&rg, &rg);
       ctrl_break=rg.h.dl;
       rg.x.ax=0x3301;
       rg.h.dl=0;
       intdos(&rg, &rg);
       intdta=getdta();
       setdta(mydta);
       resident_psp();
       popup();
       interrupted_psp();
       setdta(intdta);
       setvect(0x24,oldcrit);
       rg.x.ax=0x3301;
       rg.h.dl=ctrl_break;
       intdos(&rg, &rg);
                                                                      198

       disable();
       _SP=intsp;
       _SS=intss;
       enable();
       running=0;
     }

     /*------------------------------------------------*/
     static int avec=0;
     unsigned resident(signature, ifunc)
     char *signature;
     void interrupt (*ifunc)();
     {
        char *sg;
        unsigned df;
        int vec;

        segread(&seg);
        df=seg.ds - seg.cs;
        for(vec=0x60; vec < 0x68; vec++) {
           if(getvect(vec) == NULL)  {
             if(!avec)
               avec=vec;
             continue;
           }
           for(sg=signature; *sg; sg++)
             if(*sg!=peekb(peek(0,2+vec*4)+df,(unsigned)sg))
                break;
             if(!*sg)
                return vec;
        }
        if(avec)
           setvect(avec, ifunc);
        return 0;
     }

     /*------------------------------------------------*/
     static void pidaddr()
     {
        unsigned adr=0;

        rg.h.ah=0x51;
        intdos(&rg, &rg);
        mypsp=rg.x.bx;

        rg.h.ah=0x52;
        intdos(&rg, &rg);
        enddos=_ES;
        enddos = peek(enddos, rg.x.bx-2);
        while(pidctr < 2 &&
            (unsigned)((dosseg<<4) + adr) < (enddos<<4)) {
         if(peek(dosseg, adr) == mypsp)  {
            rg.h.ah=0x50;
            rg.x.bx=mypsp+1;
            intdos(&rg, &rg);
            if(peek(dosseg, adr) == mypsp +1)
              pids[pidctr++]=adr;
            rg.h.ah=0x50;
            rg.x.bx=mypsp;
            intdos(&rg, &rg);
         }
         adr++;
       }
     }
                                                                      199

     /*------------------------------------------------*/
     static resterm()
     {
      /* closefiles();*/

       setvect(0x1c,oldtimer);
       setvect(9,oldkb);
       setvect(0x28,old28);
       setvect(0x13,olddisk);
       setvect(avec, (void interrupt (*)()) 0);

       rg.h.ah=0x52;
       intdos(&rg, &rg);
       mcbseg=_ES;
       mcbseg=peek(mcbseg, rg.x.bx-2);

       segread(&seg);
       while(peek(mcbseg, 0) == 0x4d)  {
            if(peek(mcbseg, 1) == mypsp) {
              rg.h.ah=0x49;
              seg.es=mcbseg+1;
              intdosx(&rg, &rg, &seg);
            }
            mcbseg+=peek(mcbseg,3)+1;
       }
     }

     /*------------------------------------------------*/
     terminate()
     {
       if(getvect(0x13) == (void interrupt (*)()) newdisk)
         if(getvect(9) == newkb)
            if(getvect(0x28) == new28)
               if(getvect(0x1c) == newtimer) {
                  resterm();
                  return;
               }
       resoff=1;
     }


     /*------------------------------------------------*/
     restart()
     {
       resoff=0;
     }
     /*------------------------------------------------*/
     wait()
     {
       resoff=1;
     }













                                                                      200

               TSR-ПРОГРАММА - ПРИЛОЖЕНИЕ.
     -----------------------------------------------------------------

          В popup.c   функция   popup   вызывается,   когда  программа
     TSR-драйвера обнаруживает,  что нажата клавиша "горячего ключа" и
     выполнение утилиты  безопасно  для  ДОС._  .Функция popup сохраняет
     текущее положение курсора,  вызывает exec,  затем восстанавливает
     курсор и завершает выполнение._ .Функция exec - это вход в утилиту,
     в данном случае программа-пример из  главы  10._  .Дополнительно  к
     тому,  что  вы узнали о exec ранее,  обратите внимание еще вот на
     что.  Она работает точно так же как и нерезидентная menu.exe,  но
     сейчас ее  имя  popup.exe,  и  она  является  TSR-программой.  На
     листинге 12.5 дан файл проекта для построения popup.exe  в  Турбо
     _Си..

          Листинг 12.5:popup.prj.

     popup (twindow.h)
     exec (twindow.h,keys.h)
     tetstmove (twindow.h,keys.h)
     promote (twindow.h,keys.h)
     ccolor (twindow.h,keys.h)
     fasttest (twindow.h)
     notepad (twindow.h)
     ordent (twindow.h)
     maxims (twindow.h,keys.h)
     poems (twindow.h,keys.h)
     editor (twindow.h,keys.h)
     entry (twindow.h,keys.h)
     thelp (twindow.h,keys.h)
     tmenu (twindow.h,keys.h)
     twindow (twindow.h,keys.h)
     resident
     ibmpc.obj

          Чтобы запустить резидентную утилиту, построенную Турбо Си по
     этому проекту, введите следующую команду:

     C>popup

          Эта команда загрузит TSR-программу и оставит  ее  в  памяти.
     При этом она выдаст сообщение:

     Resident popup is loaded.

          При попытке повторного запуска будет выдано сообщение:

     Popup is already resident.

          Когда программа   резидентна,  вы  можете  выполнять  ее  из
     командной строки  для  того,  чтобы   приостановить,   продолжить
     выполнение или снять ее. Это делается следующими командами:

     C>popup wait
     C>popup restart
     C>popup quit








                                                                      201


               ПРОВЕРКА TSR-ПРОГРАММ.
     -----------------------------------------------------------------

          Если вы написали TSR-программу и  хотите  проверить  ее  как
     резидентную программу,  ваши опыты могут разочаровать вас. Прежде
     всего у вас  не  будет  возможности  использовать  Турбо  Си  для
     интерактивного тестирования.   TSR-программа  устанавливается  из
     командной строки и вызывается по нажатию клавиши.  Далее,  до тех
     пор,  пока не заработает функция terminate,  вам придется удалять
     ее путем перезагрузки.  То же придется делать при загрузке других
     резидентных программ   после   нее.   Так   как   ваша  программа
     присоединяется к прерываниям,  то ее выполнение может подвешивать
     вашу  систему.  Так  что  TSR-программу  нелегко  отлаживать  как
     резидентную.

          Лучшее решение   -   это   отлаживать   TSR-программу    как
     нерезидентную. Все интерфейсы с ДОС,  необходимые для установки и
     действия TSR-программы,  находятся в popup.c и resident.c. Почему
     бы  не  пропустить  эти  операции до тех пор,  пока вы надежно не
     протестируете вашу программу?  Как вы видите  из  примера,  часть
     программы,   выполняющая   основные   функции,   была  создана  и
     протестирована отдельно без TSR-операций. По сути дела, эта часть
     используется  как  пример некоторых возможностей,  не связанных с
     обсуждением TSR-программ.  Вы можете тестировать  свою  программу
     таким же способом.

          Простейший путь  тестировать вашу утилиту - это связать ее с
     корневой  программой,  обеспечивающей  функцию   main   и   любой
     начальный код,  который  вы  потом включите в popup.c.  Программа
     menu.c из главы 10 является хорошим примером.

          Другой способ - связать утилиту с popup.c и  resident.c, как
     будто бы вы строите резидентную программу, но с одним изменением.
     Вместо вызова функции resinit из функции main в  popup.c вставьте
     вызовы  popup  и closefile из popup.c.Программа будет иметь те же
     вид,  структуру и размер,  что и ее резидентная версия,  но будет
     функционировать как нерезидентная программа.

          Используя этот  способ,  вы  тестируете  ее  путем  запуска.
     Вместо того,  чтобы стать резидентной,  программа действует,  как
     будто  бы  был  нажат  "горячий  ключ",  выполняется  один  раз и
     завершается.

          После тестирования программы вы можете  перекомпоновать свою
     программу    как    TSR-программу   и   протестировать   ее   как
     резидентную. Начните с наивысшего значения переменной sizeprogram
     и уменьшайте ее, как описано в главе 11.

          Завершающий тест  -  это  проверка,  как  ваша TSR-программа
     будет вести себя в  окружении  себе  подобных.  Этот  тест  может
     привести к   непредвиденным  результатам.  Многие  из  популярных
     TSR-программ не  могут  выполняться  вместе,  поэтому  вы  должны
     выбрать   те   из  них,  которые  совместимы  друг  с  другом,  и
     попробовать тесты,  которые загружают различные  TSR-программы  в
     различной  последовательности  до  тех пор,  пока вы не добьетесь
     нормальной работы.  Укажите этот порядок в установочную процедуру
     в руководстве пользователя по вашей программе.






                                                                      202


               ВЫВОДЫ.
     -----------------------------------------------------------------

          Используя программы из этой главы,  вы  будете  иметь  набор
     средств, который позволит вам писать резидентные утилиты на Турбо
     Си для IBM PC.  Эти программы могут создаваться и тестироваться в
     интегрированной  среде  Турбо  Си  как  нормальные  нерезидентные
     программы для ДОС.  Они могут использовать  функции  окон,  ввода
     данных, текста  и  меню  из  предыдущих глав в этой книге.  После
     доведения  программ  до  рабочего  состояния   они   могут   быть
     интегрированы  со  средствами  из этой главы для превращения их в
     полностью функционирующие TSR-программы.



               ЭПИЛОГ.
     -----------------------------------------------------------------

          Хэккеры в  сердце  могут  почуствовать  проникновенность  за
     работу,  которая превратилась в программы из этой книги. Хэккер -
     это  человек,  который "разбирает" компьютерные системы для того,
     чтобы узнать,  как они работают. Этот термин в дальнейшем потерял
     свое значение  ввиду его частого употребления в печати и общении,
     но мы предпочитаем его начальное значение.  Программист,  который
     интересуется  техникой  и  принципами,  лежащими  в  основе  этих
     функций, обнаружит, что многие хэккеры обнаружили то же самое. Вы
     можете использовать эти средства без всяких вопросов.  Но если вы
     пытливая натура,   то   это   подтолкнет   вас   к    дальнейшему
     проникновению  во  внутренности PC и ДОС.  Если вы не работаете в
     Microsoft и не имеете исходных текстов каждой из версий  ДОС (или
     времени на  их  изучение),  то должны будете или сами разгадывать
     секреты ДОС или узнавать их от других.

          Мы советуем  вам  присоединиться  к  информационному  обмену
     журнала Byte. Каждый выпуск журнала Byte содержит информацию, как
     это сделать.  Там имеется больше полезных технических данных, чем
     во  всех  вместе взятых книгах,  статьях журналов и руководствах,
     которые вы можете где-либо найти.  Учитесь и  используйте  работу
     тех, кому посвящена эта книга.
























                                                                      203