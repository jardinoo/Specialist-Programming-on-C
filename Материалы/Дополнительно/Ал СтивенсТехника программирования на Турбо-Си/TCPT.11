

                              Г Л А В А  11

                          Резидентные программы
     -----------------------------------------------------------------

          Повсюду в  этой книге "PC" (ПК) относится к семейству IBM PC
     и совместимым с ними компьютерам;  однако персональные компьютеры
     не всегда были такими, как PC. Первые ПК создавались на знаниях и
     интересе   любителей.   ПК   развивались   вместе   с   развитием
     микрокомпьютерной  технологии  от  домашних  игрушек до серьезных
     систем.   Программное   обеспечение   и   операционные    системы
     развивались вместе  с  компьютерами.  Ранние операционные системы
     (ОС) представляли собой немногим более,  чем командные процессоры
     Бейсика или  Паскаля,  которые  обеспечивали  поддержку  языков и
     простое управление файлами. Эти системы обычно ориентировались на
     конкретный   компьютер  и  были  несовместимы  с  другими.  Когда
     компьютеры  начали  ориентироваться   на   массовое   применение,
     операционные системы  начали  стабилизироваться.  Среди  них были
     Apple-DOS, NorthStar DOS,  TRSDOS,  и CP/M. Все они имели похожие
     характеристики:

         - однопрограммный   однопользовательский   режим   работы
         - поддержка файлового каталога
         - поддержка интерпретаторов и компиляторов языков
           программирования
         - несовместимость программ и данных между системами

          С великой  проницательностью  Гарри  Килдалл создал CP/M как
     открытую ОС.  Изначально предназначавшаяся для поддержки создания
     программ для  Intel  MDS,  эта  ОС не ориентирована на какую-либо
     модель или марку компьютеров.  CP/M состоит  из  базовой  системы
     ввода-вывода   (BIOS),   базовой  дисковой  операционной  системы
     (BDOS),  и командного процессора  (CCP).  BIOS  ориентирована  на
     работу  с  аппаратурой  компьютера и предназначена для управления
     консолью, принтером  и   дисковой   системой.   Путем   написания
     соответствующей BIOS производители компьютеров могли использовать
     приемлемую и развитую операционную систему с  тысячами  доступных
     программ.  Благодаря своей адаптируемости CP/M стала промышленным
     стандартом ОС для ПК на микропроцессорах 8080 или Z80.

          Микропроцессоры 8080  и  Z80  могли  адресовать  только  64К
     памяти,   поэтому   CP/M   строилась   как   однопользовательская
     однопрограммная ОС.Была построена и многопользовательская версия,
     названная  MP/M,  но  она не стала промышленным фаворитом,  каким
     была CP/M,  в основном из-за медленнной  работы  (8080  не  очень
     быстрый  процессор),  и  потому,  что ПК не особенно подходят для
     многопользовательской работы.

          ДОС, управляющая  работой  PC,   является   адаптацией   ОС,
     созданной  для использования на 8086,  и заметно похожей на CP/M.
     Microsoft  купила  ее  у  создателя  -  фирмы  Seattle   Computer
     Products,  а  IBM купила лицензию у Microsoft.  ДОС до сих пор во
     многом похожа на CP/M.  ДОС состоит из трех  модулей,  схожих  по
     функциям с BDOS,  CCP и BIOS в CP/M; и пользовательский интерфейс
     почти идентичен используемому в CP/M.  У ДОС есть  дополнительные
     возможности,   такие,   как   каналы,   фильтры,   переназначение
     ввода-вывода,  пометка файлов временем и датой,  и  иерархическая
     структура      файлового      каталога.      ДОС      по-прежнему
     однопользовательская однозадачная ОС, в чем совпадает с CP/M.




                                                                      152

          Первые компьютеры  IBM  PC  были  очень  похожи   на   своих
     предшественников  с микропроцессорами 8080 и Z80;  у них было 64К
     памяти, флоппи-диски и  процессор  немного  побыстрее,  чем  Z80.
     Однозадачная  ДОС  была подходящей и адекватной этим компьютерам,
     но PC имели три архитектурные  особенности,  предназначенные  для
     расширения.  Микропроцессор 8088 адресует до 1М памяти;  он имеет
     векторную  систему  прерываний;  клавиатура  и  дисплей  IBM   PC
     являются    составной    частью    компьютера,   в   отличие   от
     видеотерминалов,  присоединенных через последовательный порт. Эти
     характеристики     легли     в    основу    ограниченного    вида
     мультизадачности,  который развивался на PC и сейчас известен как
     программы, остающиеся в памяти (TSR).

          ДОС включает  две  функции,  позволяющие  программе объявить
     себя  резидентной.  Эти  функции  похожи,  но   имеют   небольшие
     различия. Функция 0х31 прерывания ДОС 0х21 заканчивает выполнение
     программы,  но оставляет ее резидентной.  ДОС не будет покушаться
     на память, принадлежащую программе. Прерывание ДОС 0х27 делает то
     же самое, но ограничивает размер программы величиной 64К.

          Эти две функции  предназначались  в  ДОС  не  для  написания
     резидентных  утилит,  а  для того,  чтобы создатели системы могли
     написать программы  обработки  прерываний  (ISR),  поддерживающие
     дополнительные  устройства   ввода-вывода,   такие,   как   мышь,
     графический  планшет,  или  джойстик.  Эти устройства не являются
     стандартной частью PC и,  соответственно,  не имеют  стандартного
     программного  интерфейса с ДОС.  ISR могут поддерживають и другой
     вид  программ,  не  обязательно   связанных   с   дополнительными
     устройствами,   но   расширяющих   пользовательский  интерфейс  с
     компьютером.  Это TSR-программы;  два  наиболее  популярных  вида
     таких     программ     -    это    расширители    клавиатуры    и
     программы-секретари.  Расширители клавиатуры, такие, как Prokey и
     Superkey,  позволяют  пользователю  присвоить  значения  символов
     функциональным клавишам,  <Alt>-key комбинациям, или любым другим
     клавишам.  Программы-секретари,  такие,  как Sidekick и Homebase,
     предлагают записную книжку,  калькулятор, календарь, автовызывное
     телефонное   устройство  и  другие  возможности  рабочего  стола,
     вызываемые нажатием клавиши.

          Среди других  TSR-программ :  программы-корректоры,  системы
     обработки  структуризованных  текстов,   печать   со   спулингом,
     расширения   командного   процессора   ДОС,   отладчики,  часы  с
     будильником.  Эти программы и многочисленные представители других
     резидентных программ имеются в продаже,  в источниках бесплатного
     программного обеспечения,  или в исходных текстах,  публикуемых в
     журналах.

          Эта глава  представляет  и  объясняет класс программ для PC,
     известных  под  разными  именами,   среди   которых   всплывающие
     (pop-up), TSR,  резидентные утилиты, и программы-секретари. Такие
     программы  уникальны,  так  как  после  исполнения  они  остаются
     резидентными  в  памяти  и  часто  ее  не  покидают до выключения
     компьютера. Будучи    резидентными,    они    выполняются    (или
     "всплывают") при вызове.

          Типичная TSR-программа  вызывается внешним событием,  обычно
     называемым "горячим ключом".  Горячий ключ - это ключевая строка,
     формируемая   при   нажатии   пользователем   комбинации  клавиш,
     зарезервированной для вызова утилиты. Естественно, эта комбинация
     не должна обычно использоваться для других целей.




                                                                      153

          Активизация TSR-программы   прерывает   выполнение   текущей
     программы  на  время  работы   TSR-программы.   После   окончания
     TSR-программы  прерванная программа продолжает работу. Прерванный
     процесс   может    быть    нерезидентной    программой,    другой
     TSR-программой, или самой ДОС.

          Загрузка нескольких  TSR-программ  в память превращает ДОС -
     однозадачную по сути операционную систему - в ограниченную, в чем
     -то калечную мультизадачную ОС.



               Прерывания
     -----------------------------------------------------------------

          Чтобы понять сущность TSR-программ, вы должны понять систему
     прерываний,  потому  что  эти  программы   используют   структуру
     прерываний ДОС  и  PC.  Это обсуждение ни в коей мере не является
     исчерпывающим описанием  прерываний,  и  этим  вы  поощряетесь  к
     исследованию  предмета  с использованием материалов,  посвященных
     архитектуре 8086/80286  и  PC.  Здесь  объясняется,   что   такое
     прерывания и как они используются, но без детальных спецификаций.
     Этого вам хватит, чтобы понять TSR-программы.

          Прерывание -  это   кратковременное   приостановка   текущей
     прочедуры  программы,  позволяющая  выполнить  другую  процедуру.
     После  завершения  прерывания  прерванная  программа   продолжает
     выполняться так,  как  будто  бы  ничего не происходило.  Эти две
     процедуры могут  быть  несвязанными  -  и  прерывание  не  окажет
     никакого воздействия  на  прерванную  процедуру.  Они  могут быть
     взаимозависимы - прерванная программа может  быть  модифицирована
     процедурой обработки  прерывания.  Прерывание  может быть вызвано
     внешним по отношению  к  выполняемой  программе  событием  или  в
     результате действий   самой   программы.  Прерывание  может  быть
     вызвано аппаратно или командой из программы.



          Векторы прерывания
     -----------------------------------------------------------------

          В компьютере PC имеется 256 различных прерываний, с номерами
     от 0 до 0хff.  Некоторые  из  них  определены  для  использования
     процессором.  Например,  прерывание 0 возникает при делении на 0.
     Другие  определены  для  вызова  функций  BIOS,  третьи   -   для
     использования   ДОС.   Напомним,   что   8088/8086/80286   -  это
     микропроцессор,  PC - компьютер, построенный на его базе, а ДОС -
     это операционная система.  Для каждого из этих трех архитектурных
     слоев определен  свой  набор  прерываний.  Оставшиеся  прерывания
     доступны  для использования прикладными программами и программами
     обслуживания устройств.

          Каждое прерывание  представлено  в   памяти   четырехбайтным
     значением   адреса.   Эти  значения  располагаются  в  памяти  со
     смещениями от 0 до  0х3ff.  При  прерывании  содержимое  регистра
     признаков  и четырехбайтный адрес выполняемой команды сохраняется
     в  стеке.После   этого   прерывания   запрещаются,   и   начинает
     выполняться  программа  с  адреса,  соответствующего происшедшему
     прерыванию.  Эта  программа  должна  сохранить  используемые   ей
     регистры, выполнить свою задачу, восстановить значения регистров,
     и   выполнить   команду   возврата   из    прерывания,    которая
     восстанавливает  адрес  прерванной программы и регистр признаков,
     так что прерванная программа продолжит  свое  выполнение  с  того
     места, где была прервана.
                                                                      154


          Аппаратные прерывания
     -----------------------------------------------------------------

          Аппаратные прерывания    вызываются   событиями,   физически
     связанными в аппаратуре с соответствующими  векторами прерываний.
     Например,  клавиатура  в  PC  связана  с  прерыванием 9.  Нажатие
     клавиши  вызывает  прерывание  выполняемой  программы,  как  было
     описано  выше,  и  переход  по  адресу,  находящемуся  в  векторе
     прерывания,  соответствующему прерыванию 9.  В памяти этот вектор
     находится по адресу 0х24 (9*4 байт ).


               Программные прерывания
     -----------------------------------------------------------------

          Программные прерывания  происходят  при выполнении в текущей
     программе команды INT с номером прерывания в качестве операнда. В
     остальном  нет  никакой  разницы  между  программным и аппаратным
     прерыванием.



               ДОС - однозадачная операционная система
     -----------------------------------------------------------------

          Работу TSR-программ можно понять,  изучая условия, в которых
     выполняются нерезидентные  программы.  ДОС   была   сделана   для
     поддержки работы  только  одной задачи.  ОС организует загрузку и
     выполнение задач и выполняет запросы на ввод-вывод. Она управляет
     дисковыми  каталогами  и  файлами,  работает с системными часами,
     выводит  данные  на  печать,  консоль,  и  возвращает   программе
     символы,  введенные  с  клавиатуры.  ДОС - это в сущности сервер,
     обслуживающий     иерархическую      файловую      систему      и
     записе-ориентированные   устройства,   и   обеспечивающий  одному
     пользователю выполнение  одной  задачи.  И  с  этой  службой  ДОС
     справляется.

          После первоначальной  загрузки  ДОС  память размером в 640К,
     имеющаяся  в  PC  (или  в  размерах  памяти  вашего   компьютера)
     распределена, как показано на рис.11.1. Память с адресами от 0 до
     0х400 зарезервирована для  векторов  прерываний.За  ними  следует
     программа ДОС. Затем идут драйверы устройств,загруженные вместе с
     ДОС.Например,  при использовании виртуального диска или  драйвера
     терминала ANSI, программы этих драйверов располагаются после ДОС.
     После драйверов идет резидентная часть командного процессора. Эта
     программа  обрабатывает командную строку и выполняет программы, и
     она разделена на резидентную и нерезидентную части. Нерезидентная
     область   (Transient   Program   Area   -  TPA)  находится  после
     резидентной части командного процессора. Запущенная пользователем
     из  командной  строки  программа  загружается в TPA.  В конце TPA
     находится  область  нерезидентной  части  командного  процессора.
     Пользовательская программа может использовать эту область. В этом
     случае  резидентная  часть   командного   процессора   подгружает
     нерезидентную после окончания программы.









                                                                      155


      ┌──────────────────────────────────────────────────────┐
      │                                                      │
      │                КОМАНДНЫЙ ПРОЦЕССОР                   │
      │               (нерезидентная часть)                  │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │               НЕРЕЗИДЕНТНАЯ ОБЛАСТЬ                  │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                КОМАНДНЫЙ ПРОЦЕССОР                   │
      │                (резидентная часть)                   │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                ДРАЙВЕРЫ УСТРОЙСТВ                    │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                      Д О С                           │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                ВЕКТОРЫ ПРЕРЫВАНИЙ                    │
      └──────────────────────────────────────────────────────┘

                   рис.11.1. Карта памяти ДОС.

          После загрузки командным процессором программы  она начинает
     выполняться.  При  необходимости обращения к ДОС,  например,  для
     выполнения  операции   с   файлом,   вызов   ДОС   осуществляется
     программным  прерыванием с передачей параметров через регистры. В
     зависимости  от  параметров   ДОС   выполняет   одну   из   своих
     функций. Вызвавшая  ДОС программа находится в состоянии ожидания.
     Результаты функций ДОС  возвращаются  в  регистрах  и  с  помощью
     установки флажка переноса.

          Такая последовательность  событий  описывает работу типичной
     однозадачной ОС.  ДОС не обеспечивает одновременное нахождение  в
     памяти  и  выполнение пользовательских программ,  или поддержание
     информации о более, чем одной задаче в памяти. Единственный метод
     сделать   несколько   задач   активными   в   памяти  -  оформить
     (несколько) задач как программы обработки прерываний. Для ДОС эти
     программы   будут  выглядеть  как  ISR-программы,  поддерживающие
     выполнение  единственной  задачи.  В   ДОС   задаче   разрешается
     порождать подчиненную подзадачу, но только одна из них может быть
     активной в текущее время.  Главная задача  будет  бездействовать,
     пока не завершится подзадача.

          Для правильной  работы  ISR-программ  должно  быть соблюдено
     одно правило:  избегать вызова функций  ДОС,  если  ISR-программа
     может быть вызвана в результате прерывания работы самой ДОС. ISR-
     программы,  вызываемые только из нерезидентных программ с помощью
     программных прерываний,    не   имеют   таких   ограничений,   но
     асинхронные по   отношению   к   текущей   задаче   ISR-программы
     (например, обработки  прерываний  от  таймера  или клавиатуры) не
     должны вызывать ДОС.  Программисты узнали через некоторое  время,
     что  TSR-программы,  будучи  вызванными,  не  должны использовать
     функции ДОС.  Если резидентная программа читает  с  клавиатуры  с
     помощью функций ROM-BIOS (BIOS, "зашитый" в ПЗУ) и пишет на экран
     теми же функциями или путем прямого доступа к буферу  экрана, она
     выполняется  без  проблем;  но  при  попытке  использования такой
     программой функции ДОС для чего-либо, система "ломается". Функции
     ДОС  не  реентерабельны;  когда  резидентная  программа прерывает
     выполнение функции ДОС  и  сама  вызывает  функцию  ДОС,  система
     превращается в   мусор.   Казалось  бы,  что  нереентерабельность
     программ ДОС ограничивает TSR-программы  функциями,  позволяющими
                                                                      156

     работать  с  памятью  и  использовать  возможности ROM-BIOS.  Это
     ограничение не приводит к большим жертвам.  После  того,  как  вы
     узнаете,  как  были созданы функции "окон",  вы сможете прекрасно
     обойтись без ДОС.

          К этой аномалии  создатели  ДОС  добавили  трюк,  включив  в
     состав  ДОС  программу  печати  со  спулингом по имени PRINT.COM.
     Спулинг - это слово из прошлых времен,  означающий "одновременное
     оперативное выполнение периферийных операций". Спулинг при печати
     позволяет печатать файл в то время, как пользователь выполняет на
     компьютере  другую  задачу,  для  которой  не  требуется принтер.
     PRINT.COM является   резидентной   программой,    остающейся    в
     памяти, поддерживающей  очередь запросов на печать,  и печатающей
     заданные файлы;  одновременно с этим возможности компьютера и ДОС
     остаются доступными  пользователю.  Наличие  программы,  читающей
     дисковые файлы, читающей и записывающей в файл очереди на печать,
     и  переводящей  страницы  на  принтере,  пока пользователь делает
     что-нибудь еще,  позволяет предположить,  что в  ДОС  реализуется
     некоторая мультизадачность без объяснения миру, как это делается.

          Это предположение  и  пытливая  натура  поколения  хэккеров,
     конечно, подталкивали к открытию возможностей ДОС по ограниченной
     мультизадачности.    Некоторое    время    ключи   не   удавалось
     подобрать; затем те,  кто понял технику  написания  функционально
     полных  TSR-программ,  хранили  секрет,  так  они  продавали  эти
     программы, и, наверно, хотели задушить конкурентов. Но остальные,
     однако, начали  "взламывать"  чужие  программы  и открыли секрет.
     Сегодня аккуратный автор может скомбинировать  шаги,  необходимые
     для   написания   такой  программы,  прочитав  массу  технических
     журналов и сотни выдержек из электронных бюллетеней.  В то время,
     как вы читаете эту книгу, возможно печатаются еще книги, подобные
     этой, чтобы помочь объяснить суть дела.


               TSR-ПРОГРАММЫ
     -----------------------------------------------------------------

          При работе  ДОС  и запуске из командной строки TSR-программы
     выполняются как нормальные нерезидентные программы. По сути, ни у
     ДОС,  ни у командного процессора нет  способов  узнать,  что  эти
     программы станут  резидентными,  до  того,  как  они завершатся с
     помощью одной  из  TSR-функций  ДОС.  При  завершении   программы
     информируют ДОС,  сколько памяти надо зарезервировать.  Насколько
     известно,  в ДОС это действие приведет лишь к  установке  нижнего
     адреса  нерезидентной  области  на  значение  сразу  после  конца
     TSR-программы и уменьшению размера  доступной  для  нерезидентных
     программ  памяти  на  размер TSR-программы.  На рис.11.2 показана
     карта памяти системы при наличии двух TSR-программ.
















                                                                      157

      ┌──────────────────────────────────────────────────────┐
      │                                                      │
      │                КОМАНДНЫЙ ПРОЦЕССОР                   │
      │               (нерезидентная часть)                  │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │               НЕРЕЗИДЕНТНАЯ ОБЛАСТЬ                  │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                TSR-программа #2                      │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                TSR-программа #1                      │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                КОМАНДНЫЙ ПРОЦЕССОР                   │
      │                (резидентная часть)                   │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                ДРАЙВЕРЫ УСТРОЙСТВ                    │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                      Д О С                           │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                ВЕКТОРЫ ПРЕРЫВАНИЙ                    │
      └──────────────────────────────────────────────────────┘

         рис.11.2. Карта памяти ДОС с двумя TSR-программами.


     TSR-программы существуют в двух  вариантах:  программы  обработки
     прерываний    и   резидентные   утилиты.   Разница   между   ними
     незначительна, но она есть.


               Программы обработки прерываний.
     -----------------------------------------------------------------

          Программы обработки прерываний реагируют  на  прерывания  от
     аппаратуры  или  от программ и обычно предназначены для поддержки
     различных устройств. Примером такой программы является программа,
     вызываемая прерыванием от таймера.  Пример в главе 12 показывает,
     как можно  использовать  прерывание  от  системного  таймера  для
     отображения  даты  и  времени на экран.  Программа,  поставляемая
     вместе с  "мышью"  фирмы  Microsoft  под   названием   MOUSE.COM,
     обрабатывает  аппаратные прерывания,  возникающие при перемещении
     "мышки".  MOUSE.COM также обрабатывает программные прерывания  от
     программ,  которым требуется определить местонахождение "мышки" и
     состояние ее кнопок. Резидентные утилиты могут включать несколько
     таких программ.


          Резидентные утилиты.
     -----------------------------------------------------------------

          Резидентные утилиты  -  это  программы обработки прерываний,
     обычно не поддерживающие какое-либо устройство, но реагирующие на
     нажатие определенной  "горячего  ключа" и запускающие процессы по
     запросу пользователя.  Эти утилиты сохраняют состояние компьютера
     на  момент  своего вызова,  и восстанавливают это состояние после
     окончания своей работы.  Типичные резидентные утилиты  используют
     технику "окон" для связи с пользователем.

                                                                      158

          Что может быть резидентным.
     -----------------------------------------------------------------

          После того,  как  вы  прочтете  эту  и  следующую главу,  вы
     научитесь писать  TSR-программы  на  Турбо  Cи.   У   вас   может
     возникнуть  тенденция  писать  все  в виде резидентных программ и
     вызывать все,  что возможно,  по нажатию клавиши,  но  себя  надо
     сдерживать. Не все может или должно быть резидентным.

          Помните, что после добавления резидентной программы в память
     ее  величина  уменьшается.  Вы  можете  дойти  до  того,  что  не
     останется  памяти  для  выполнения  обычных программ.  Можно быть
     богатым на "всплывающие"  утилиты,  но  не  иметь  памяти,  чтобы
     сделать   маленькую  табличку  или  составить  записку  на  своем
     текстовом редакторе.

          Помните также,  что вы увеличиваете  встроенные  ограничения
     ДОС, вводя  первую  резидентную  программу в память.  Не является
     сюрпризом,  что TSR-программы из разных источников не  уживаются.
     Далее,   некоторые  TSR-программы  плохо  работают  с  некоторыми
     нерезидентными программами.

          Некоторые TSR-программы должны быть загруженными  после всех
     других  резидентных  программ;  они  должны быть первыми в наборе
     программ,  обрабатывающих прерывания. Несколько таких программ не
     могут работать  вместе,  так  как  только  одна из них может быть
     последней.  Программа Sidekick является примером такой программы;
     она должна быть последней загруженной,  так как она перехватывает
     прерывания таймера из любой программы, загруженной после нее.

          Такие несообразности являются результатом  попыток  вставить
     мультизадачность в  ДОС.  К  чести  создателей  TSR-программ  они
     старались прийти к соглашениям по стандартам таких  программ. Они
     делали попытки сотрудничества и определения "хорошо ведущих" себя
     TSR-программ,  но  ни  один  такой  стандарт  до   сих   пор   не
     опубликован.  Также  делались попытки определения такой структуры
     нерезидентных  программ,  которая  позволяла  бы  им   гармонично
     сосуществовать   с   "правильными"   TSR-программами.   Создатели
     программ  для  PC  привыкли  работать  с   однозадачной   ДОС   и
     ограничениями   оборудования   PC   определенным  образом.  Чтобы
     преодолеть ограничения ДОС и получить  требуемые  характеристики,
     многие  программисты "напрямую" сканировали клавиатуру и выводили
     данные прямо в видеопамять. Этот метод предполагал наличие только
     одной   программы   и   отсутствие   соперничества   из-за   этих
     ресурсов. Такие  ограничения  встают  на   дороге   TSR-программ,
     которым нужно быть второй задачей, не мешающей первой.

          Фирма Borland    поставляет    программу    Sidekick   Plus,
     управляющую  работой  TSR-программ.  Она  обеспечивает  запуск  и
     взаимодействие  семейства  TSR-программ,  которые  созданы  с  ее
     помощью. Преймущество такого решения - в достижении совместимости
     TSR-программ.  Явным  недостатком  является  необходимость  иметь
     Sidekick Plus  для  запуска  таких  программ  и  то,  что  многие
     резидентные программы,  созданные независимо, не будут работать в
     этой среде.









                                                                      159

          Чтобы решить,  делать свою программу резидентной или нет, мы
     предлагаем использовать следующие правила:

          - Размер  программы.  Если программа не может быть создана в
     крохотной модели памяти (64К на код, данные и стек), то вероятнее
     всего она не должна быть резидентной.  Внушите себе это правило -
     и это убережет вас от засорения памяти резидентными  утилитами за
     счет  нужных  вам  обычных  программ.  Отметим,  что TSR-драйвер,
     описанный в главе 12,  одинаково хорошо работает c программами  в
     крохотной и малой моделях.

          - Частота  использования  утилиты.  Не  советуем  вам делать
     резидентной программу расчета доходов.  Программы,  запускаемые с
     частотой один раз в день должны быть нерезидентными, а один раз в
     час  -  могут  стать   TSR.   Не   перегружайте   систему   редко
     используемыми резидентными программами.

          - Ресурсы,   необходимые   утилите.  Если  программа  должна
     запрашивать дополнительную память или ее характеристики снижаются
     при ограничениях на память,  она не должна быть резидентной; ведь
     она  может  быть  вызвана  во  время  выполнения   любой   другой
     программы,  которая  может  занять  всю или большую часть памяти.
     Если выполняется  COM-программа,  ДОС  считает,  что  занята  вся
     память.

          - "Всплывающая" природа задачи.  Если программа используется
     в дополнение к  другим  -  это  хороший  кандидат  в  резидентные
     утилиты. Например, удобно, когда можно вызвать систему компоновки
     текстов при работе с текстовым процессором. То же самое относится
     к  программе-словарю.  Калькулятор  и  записная книжка необходимы
     почти все время.  Синтаксический анализатор программ на Си  может
     стать   полезной   TSR-программой  при  использовании  текстового
     редактора для подготовки программ.  Но,  однако,  не нужно делать
     все программы вызываемыми по нажатию клавиши.

          - Время,   нужное   для   выполнения.  Главное  преймущество
     "всплывающих"  программ  -  это  их  немедленная  доступность   и
     возможность выполнения без отрыва от основной работы, выполняемой
     на компьютере. Если же утилита требует для выполнения целый день,
     то нет смысла делать ее резидентной.

          (Люди привыкают   к   удобствам.  Еще  несколько  лет  назад
     пользователи были довольны,  если ответ на запрос к  базе  данных
     приходил  из  центральной  машины за ночь.  Сейчас же они ворчат,
     если  им  надо  сохранить  данные  из   электронной   таблицы   и
     возвратиться  в  ДОС,  чтобы  использовать программу для работы с
     модемом.)



               ПОСТРОЕНИЕ TSR-ПРОГРАММ
     -----------------------------------------------------------------

          При написании  резидентной  программы  вам  придется  решить
     много   проблем.   Некоторые   из  них  незначительны,  некоторые
     разрешаются при использовании  расширений  стандартных  библиотек
     Турбо Си,  но некоторые являются крепким  орешком.  Использование
     ассемблера для некоторых задач является более удобным,  но в этой
     книге везде старались максимально использовать Си, где это только
     предоставлялось возможным.




                                                                      160


          Превращение программы в резидентную.
     -----------------------------------------------------------------

          Чтобы стать  резидентной,  программа  должна  объявить  себя
     соответствующим   образом.   Здесь   программисту   может  помочь
     документация на ДОС.  О двух нужных для этого  функциях  ДОС  уже
     было   упомянуто.   Чтобы  их  использовать,  надо  знать  размер
     программы,  а для этого надо знать,  как она строится в Турбо Си.
     Это в дальнейшем будет коротко объяснено. Если программа запущена
     на выполнение,  присоединила себя к нужному вектору прерывания  и
     сделала все,  что требуется для превращения в резидентную, то она
     может  вызвать  одну  из  TSR-функций ДОС.  Действие этих функций
     одинаково,  и можно использовать  функцию  0х31  прерывания  0х21
     чтобы  объявить  программу  резидентной.  Далее  следует фрагмент
     программы на Турбо Си, демонстрирующий эту возможность:

     #include <dos.h>
     static struct REGS rg;
     unsigned int sizeprogram;

     rg.x.ax = 0x3100;
     rg.x.dx = sizeprogram;
     intdos(&rg,&rg);

          Переменная sizeprogram должна содержать размер  программы  в
     шестнадцатибайтных параграфах.


          Резидентна ли уже программа?
     -----------------------------------------------------------------

          Помните, что  ДОС  неизвестно,  что  ваша  программа   стала
     резидентной  и каково ее имя (эта информация доступна,  но ДОС не
     работает с  ней).  После  выполнения  TSR-программы несколько раз
     несколько ее копий будет находиться в памяти,  поэтому  программе
     надо проверять, не загружена ли уже ее копия. Простейшим способом
     для организации такой  проверки  является  применение  одного  из
     неиспользуемых   прерываний.   При  первом  старте  TSR-программа
     выполняет это прерывание,  проверяя возвращаемое  значение.  Если
     это  значение  не  равно  установленному  в  программе,  то можно
     объявлять себя резидентной,  и программа присоединяется  к  этому
     прерыванию.  После этого вызов этого прерывания будет приводить к
     возврату  определенного  значения,  и  другие  копии  загруженной
     программы после проверки не будут объявлять себя резидентными.

          Векторы 0х60-0х67 всегда доступны для использования, и можно
     выбрать один из них.  Но нет уверенности,  что другая  программа,
     взятая из другого источника,  не выберет тот же вектор.  Помните,
     что ДОС ориентирована на одну выполняемую задачу,  и этой  задаче
     дозволено использовать любое прерывание в системе.

          Более предпочтительным   является   использование    вектора
     прерывания,  указывающего  на  сигнатуру  (уникальную  запись)  в
     памяти программы.  Вместо запуска прерывания программа проверяет,
     не указывает ли один из векторов 0х60-0х67 на эту сигнатуру. Если
     таковой  указатель  существует,  то  в  памяти  уже  есть   копия
     программы; если  же  такого не находится,  то программа объявляет
     себя  резидентной  и  устанавливает  адрес  одного  из  свободных
     прерываний на сигнатуру.  К несчастью, нет способов оградить этот
     вектор от посягательтв другой программы.  Тут уж ни в чем  нельзя
     быть уверенным.


                                                                      161

          Чтобы найти неиспользуемый вектор прерывания, надо проверить
     их все  на нулевое значение.  Вектор,  в который записан ноль,  и
     есть неиспользуемый. В документации указано, что прерывания 0х60-
     0х67 доступны для использования программами.

          Неиспользуемые векторы прерывания можно применять для других
     видов связи  между  программами.  Некоторые  TSR-программы  можно
     применять для задания параметров для своей же копии в памяти. При
     выполнении таких программ  они  передают  новые  параметры  своим
     копиям   через  вектор  прерывания.  Вектор  может  указывать  на
     подпрограмму обработки прерывания в  TSR-программе;  а  сигнатура
     находиться  с  определенным  смещением  с том же сегменте.  Найдя
     сигнатуру,  вторая  копия  программы  может  взаимодействовать  с
     первой  через  этот  вектор.  TSR-драйвер,  описанный в главе 12,
     демонстрирует такой способ.


               Захват прерывания.
     -----------------------------------------------------------------

          Вы можете  использовать прерывания не только для связи между
     программами. По прерыванию может выполняться ваша программа, если
     на  нее указывает соответствующий вектор.  В Турбо Си легко можно
     выполнить подобный  захват прерывания.  С помощью функции setvect
     можно оперативно выполнить эту задачу. Надо объявить функцию типа
     interrupt,  которая будет обрабатывать прерывания,  и записать ее
     адрес в нужный вектор.

     Например:

     setvect(vno,isr);

          Параметр vno - это int от 0  до  255,  а  isr  -  это  адрес
     подпрограммы  обработки  прерывания,  которая  может быть описана
     так:

     void interrupt isr();

          Совместное использование прерываний.

          Если вы используете прерывания, нужные другим программам, то
     надо  делать  это  так,  чтобы другие не замечали ваших действий.
     Например,  если ваша  программа  присоединится  к  прерыванию  от
     таймера  и  не позволит оставшейся части системы использовать это
     прерывание, все процессы, работающие по таймеру, будут недоступны
     все  то  время,  пока  ваша программа будет находиться в памяти и
     удерживать  прерывание.  В  этом  случае,  например,  остановятся
     системные часы.

          Вы можете присоединиться также к прерываниям  от клавиатуры,
     прерываниям  для  вызова  функций  ДОС,  дисковых  функций BIOS и
     другим прерываниям   поддержки  TSR-программ.  В  любом  из  этих
     случаев  надо  совместно  использовать   прерывания   с   другими
     процессами, нуждающимися в них.

          Возможность работать   с   прерыванием   другим   программам
     выполняется следующим   образом.   Надо  прочитать  старый  адрес
     прерывания, по которому передавалось управление до загрузки вашей
     программы. В  библиотеке Турбо Си есть функция getvect для чтения
     содержимого вектора прерывания. Надо объявить interrupt указатель
     на функцию, и записать адрес из вектора в этот указатель:



                                                                      162

     void interrupt (*oldisr)();

     oldisr = getvect(vno);

          Затем, запишите    адрес    вашей   подпрограммы   обработки
     прерывания в вектор,  используя функцию setvect, описанную выше.

          В этой подпрограмме вы можете обеспечить  выполнение  старой
     ISR,  после  предварительной  обработки  или  без  нее  передавая
     управление по адресу старой ISR. Эти принципы обсуждаются в главе
     12.



               Величина TSR-программы.
     -----------------------------------------------------------------

          При объявлении программы резидентной надо специфицировать ее
     размер,  чтобы ДОС было  известно,  сколько  памяти  отвести  для
     нее. Для  безопасности можно отвести каждой программе по 64К,  но
     при   этом   значительная   часть   занятой   памяти   может   не
     использоваться. Легко определить размеры программы, написанной на
     ассемблере,  но внутренняя структура программы на  Си  скрыта  от
     программиста. Чтобы вычислить размер программы,  надо знать,  как
     компилятор Турбо Си строит программу.

          Рисунок 11.3  демонстрирует  структуру  типичной программы в
     крохотной модели памяти,  построенную Турбо Си.  Program  Segment
     Prefix  (PSP)  - это конструкция ДОС,  помещаемая в начале каждой
     программы. Она  будет  описана  позже.  Машинный  код   программы
     следует сразу за PSP. Переменные,объявленные static или external,
     и инициализированные при объявлении,  следуют за кодом, а за ними
     идут неинициализированные   static   или   external   переменные.
     Следующая  часть  программы   -   "куча",   область   динамически
     распределяемой памяти.   Ее   размер  зависит  от  того,  сколько
     программа будет распределять памяти.  Область стека располагается
     за    "кучей",   и   его   размеры   увеличиваются   в   обратном
     направлении. Первоначально  вершина  стека  указывает  на   конец
     области в  64К,  занимаемой  программой  в крохотной модели.  При
     использовании стека его указатель двигается в  сторону уменьшения
     адресов. Величина  стека зависит от глубины вложенности функций и
     количества локальных данных,  используемых в этих  функциях.  При
     вызове  функции в стек помещаются параметры и значения регистров,
     которые необходимо сохранить.  Если функция использует  локальные
     automatic-переменные, они  тоже  запоминаются  в стеке.  Функция,
     вызываемая   рекурсивно   и   использующая   большое   количество
     параметров и  automatic-переменных,  будет  использовать  большую
     часть стека.  Из-за динамической природы "кучи" и стека вы можете
     только делать некоторые предположения о размерах программы.















                                                                      163

      ┌──────────────────────────────────────────────────────┐
      │                                                      │
      │                        СТЕК                          │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                      " КУЧА "                        │
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │    НЕИНИЦИАЛИЗИРОВАННЫЕ STATIC И EXTERNAL ДАННЫЕ     │  BSS
      ├──────────────────────────────────────────────────────┤<──────
      │                                                      │
      │     ИНИЦИАЛИЗИРОВАННЫЕ STATIC И EXTERNAL ДАННЫЕ      │  DATA
      ├──────────────────────────────────────────────────────┤<──────
      │                                                      │
      │                                                      │
      │                   КОД ПРОГРАММЫ                      │
      │                                                      │  TEXT
      ├──────────────────────────────────────────────────────┤<──────
      │                                                      │
      │                      P S P                           │
      └──────────────────────────────────────────────────────┘

     рис.11.3. Структура программ с крохотной моделью памяти
               в Турбо Си.

          Приблизительно подсчитать размер программы  можно, используя
     MAP-файл,  генерируемый программой TLINK.  В его начале находится
     информация, подобная следующей:

          Start  Stop   Length Name                Class

          00000H 010BAH 010BBH _TEXT               CODE
          010C0H 013D8H 00319H _DATA               DATA
          013DAH 013DDH 00004H _EMUSEG             DATA
          013DEH 013DFH 00002H _CVTSEG             DATA
          013E0H 013E5H 00006H _SCNSEG             DATA
          013E6H 014EDH 00108H _BSS                BSS
          014EEH 014EEH 00000H _BSSEND             BSSEND

          Самая правая колонка,  с заголовком  class,  показывает  тип
     сегментов,  представленных  значениями  в  левых  колонках.  CODE
     содержит код   программы,   DATA   содержит    инициализированные
     переменные, а BSS - неинициализированные. Значение в колонке Stop
     равно      шестнадцатиричному      адресу      конца      области
     неинициализированных переменных  и начала "кучи".  Программа,  не
     использующая стека и "кучи",  будет иметь  размер,  равный  этому
     значению + 256 байт на PSP.

          Чтобы оценить  размер "кучи",  посмотрите,  сколько и как вы
     используете  функции  распределения  памяти.  При   использовании
     оконных  функций  из  предыдущих  глав  требования к "куче" можно
     оценить исходя из количества и размеров одновременно существующих
     окон. Каждое   окно   требует   буфера   размером   с   удвоенное
     произведение ширины на  высоту  окна.  Этот  буфер  удаляется  из
     "кучи"  при  закрытии  окна,  поэтому  максимальное использование
     "кучи" будет в момент создания максимального количества  окон  на
     экране. Надо   учитывать   также  и  использование  вами  функций
     распределения памяти.  Если ваша программа распределяет память  в
     зависимости от внешних условий,  таких, как ввод пользователя или
     зависимости между  данными,  необходимы  надежные  обнаружение  и
     обработка ошибок.  Не  взирая  на  ошибку,  никогда  не вызывайте
     функцию exit из резидентной программы.


                                                                      164

          Вместе с определением  размеров  "кучи"  определяется  и  ее
     верхняя  граница,  а,  следовательно,  и  нижняя  граница  стека.
     Осталось теперь найти его верхнюю границу.  При первом выполнении
     программы  начало  стека  устанавливается  на  отметку  64К.  При
     завершения и объявления себя резидентной программа  сообщает  ДОС
     свои размеры,  и ДОС использует всю остальную память для загрузки
     других программ.  При  вызове  TSR-программа  должна   установить
     указатель стека  внутри  себя,  а  не  на другую программу.  Если
     размер объявлен меньше 64К,  то указатель стека должен быть также
     установлен ниже 64К.

          Лучший метод  найти  оптимальный размер стека - метод проб и
     ошибок. Сначала запустите программу  на  64К,  а  затем  смещайте
     вершину стека  к  меньшим адресам.  При каждом таком передвижении
     испытывайте  программу  в  условиях  максимального  использования
     стека и  "кучи".  Продолжайте эксперименты до тех пор,  пока ваша
     программа   не   будет   "вешать"   систему    или    неправильно
     выполняться. Затем поставьте вершину стека на безопасное смещение
     и интенсивно используйте программу, пока не поверите наконец, что
     стек безопасен для "кучи".

          Было бы хорошо, если бы имелся более научный и точный способ
     определения  размеров  программы,  но  этот  подход  работает,  и
     кажется, что это единственно реальный метод.



               Переключение контекстов.
     -----------------------------------------------------------------

          При первом  исполнении  TSR-программы  она  использует   все
     ресурсы, предоставляемые ДОС нормальной задаче.  После завершения
     и  объявления  себя  резидентной  эти  ресурсы  отдаются   другим
     программам или,  при отсутствии выполняемых программ,  командному
     процессору ДОС.  При  выполнении   TSR-программы   в   результате
     "горячего ключа"  она "паразитирует" на прерванной программе. ДОС
     неизвестно,  что начала выполняться другая задача,  и все ресурсы
     по-прежнему принадлежат   выполнявшейся   раннее задаче.  Поэтому
     системные указатели на эти  ресурсы  должны  быть  изменены  так,
     чтобы   TSR-программа   стала  выполняемой  задачей,  "известной"
     ДОС. Такая   передача   ресурсов   между   задачами    называется
     переключением контекстов,   и   мультизадачные   ДОС  делают  это
     автоматически. В  однозадачной  ДОС   PC   однако,   переключения
     контекстов  не  производится,  и прерывающая задача должна делать
     это сама.


               Стек.
     -----------------------------------------------------------------

          Для всех программ нужен стек.  У резидентной программы  есть
     свой  стек,  но после прерывания текущей задачи указатель стека и
     сегмент  стека  в  компьютере  указывают   на   стек   прерванной
     задачи. Может  показаться,  что лучшее решение - это использовать
     стек прерванной   программы.   На   деле   многие    ассемблерные
     TSR-программы так и делают,  но для этого приходится ограничивать
     использование стека.  Но,  во-первых,  неизвестно,  какой  размер
     стека был  у прерванной программы.  А во-вторых,  ДОС гарантирует
     достаточный размер стека только для сохранения  регистров.  Си  -
     язык с   интенсивным  использованием  стека,  и  вам  понадобится
     больший его размер,  чем обеспечивает ДОС, и это значит, что надо
     переключаться на собственный стек.


                                                                      165

          Переключение на   собственный   стек   означает,   что  надо
     запомнить значение региста сегмента стека до переключения.  И это
     значение  должно  быть  восстановлено  до  передачи  управления в
     прерванную программу.  Регистры сегментов и указателей могут быть
     прямо адресованы в Турбо Си использованием псевдопеременных _SS и
     _SP. При   объявлении   резидентной   TSR-программа    запоминает
     собственный сегмент  стека.  После вызова она запоминает контекст
     стека прерванной  программы  и  устанавливает  свой   стек.   Это
     производится  с  помощью  установки  регистра  сегмента  стека на
     значение,  запомненное при первом запуске,  и указателя стека  на
     величину, вычисленную из размеров программы.

          Если TSR-программа  реентерабельна,  то есть может прерывать
     сама себя,  переключение стеков  может  привести  к  ошибке.  При
     втором  переключении  стека  вы  перезапишете  область сохранения
     стековых регистров.   Чтобы   избежать   этого,    надо    писать
     нереентерабельные резидентные  программы.  Это небольшая потеря -
     резидентные  программы   не   нуждаются   в   том,   чтобы   быть
     реентерабельными     (вам     не     нужно     прерывать     свою
     программу-калькулятор, чтобы запустить еще одну такую же).

          Чтобы сделать        TSR-программу        нереентерабельной,
     устанавливайте флаг  при  ее   вызове.   Он   должен   оставаться
     установленным то  окончания  работы TSR-программы.  При повторном
     вызове (например,  из-за  случайного  нажатия  "горячего  ключа")
     проверяется установка флага и вторичного запуска не производится.


          Program Segment Prefix (PSP).
     -----------------------------------------------------------------

          PSP - это управляющая область в 256 байт, которая строится в
     памяти в начале каждой программы.  Она содержит  различные  поля,
     используемые ДОС  для  управления выполнением программы.  На рис.
     11.4 показана ее структура. Далее будут обсуждаться все поля PSP.
     Заметим,  что  многие эти поля не были официально описаны фирмами
     Microsoft или IBM.  Они используются так, как описано ниже, но их
     использование    или   модификация   в   прикладной   задаче   не
     санкционировано при продаже.  Знание  этих  полей  -  подарок  от
     хэккеров, расчленивших  ДОС и напечатавших о своих находках.  Эти
     данные верны для популярных версий ДОС - 2.0, 2.1, 3.0, 3.1, 3.2,
     3.3,  за  исключением специально оговоренных случаев.  ДОС 4.0 не
     публиковалась в США,  и,  как утверждается,  будущие  версии  ДОС
     будут  поддерживать мультизадачность и будут предназначены только
     для компьютеров с процессорами 80286/80386.  Использование  полей
     PSP описанным  способом  совершенно безопасно.  Многие популярные
     коммерческие программы делают это точно так же.

















                                                                      166
      ┌──────────────────────────────────────────────────────┐
      │                                                      │
      │      Вызов прерывания для завершения процесса        │ 0000
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │       Сегментный адрес верхней границы памяти        │ 0002
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                          0                           │ 0004
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │      Команда вызова диспетчера функций ДОС           │ 0005
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │             Адрес обработчика завершения             │ 000A
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │             Адрес обработчика Ctrl-Break             │ 000E
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │         Адрес обработчика критических ошибок         │ 0012
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │             Сегментный адрес PSP родителя            │ 0016
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │              Таблица указателей файлов               │ 0018
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │     Сегментный адрес области системных параметров    │ 002C
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │        Адрес стека на время вызова функции ДОС       │ 002E
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │           Размеры таблицы указателей файлов          │ 0032
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │           Адрес таблицы указателей файлов            │ 0034
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │                Зарезервировано ДОС                   │ 0038
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │               Блок управления файлом #1              │ 005C
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │               Блок управления файлом #2              │ 006C
      ├──────────────────────────────────────────────────────┤
      │                                                      │
      │        Остаток командной строки/Дисковый буфер       │ 0080
      └──────────────────────────────────────────────────────┘

                      рис.11.3. Структура PSP.


          Вызов прерывания для завершения процесса.(PSP:0)
          ------------------------------------------------

          Это поле   содержит   команду  INT  0x20;  это  сделано  для
     поддержки программ,  перенесенных из CP/M в ДОС. В CP/M программа
     завершает свое выполнение переходом на свой нулевой адрес.



                                                                      167

          Сегментный адрес верхней границы памяти.(PSP:2)
          -----------------------------------------------

          При выполнении  программы ДОС выделяет ей участок памяти,  в
     который программа загружается. Это поле содержит сегментный адрес
     конца этого участка памяти.


          Адрес обработчика завершения.(PSP:0xa)
          --------------------------------------

          При выполнении программы ДОС запоминает  текущее  содержание
     вектора прерывания  0х22 в этом поле.  После завершения программы
     ДОС восстанавливает  значение,   используя   это   поле.   Вектор
     прерывания  0х22  указывает  на  системный  обработчик завершения
     программ.


          Адрес обработчика Ctrl-Break.(PSP:0xe)
          --------------------------------------

          При выполнении программы ДОС запоминает  текущее  содержание
     вектора прерывания  0х23 в этом поле.  После завершения программы
     ДОС  восстанавливает  значение,  используя   это   поле.   Вектор
     прерывания 0х23 указывает на системный обработчик Ctrl-Break.


          Адрес обработчика критических ошибок.(PSP:0x12)
          -----------------------------------------------

          При выполнении  программы  ДОС запоминает текущее содержание
     вектора прерывания 0х24 в этом поле.  После завершения  программы
     ДОС   восстанавливает   значение,   используя  это  поле.  Вектор
     прерывания 0х24 указывает  на  системный  обработчик  критических
     ошибок.

          Отметим, что ДОС восстанавливает значения этих трех векторов
     при завершении программы и объявлении себя резидентной.  Если TSR
     надо перехватывать эти прерывания,  то придется присоединять себя
     к ним при каждом вызове.


          Сегментный адрес PSP родителя.(PSP:0x16)
          ----------------------------------------

          Любая программа выполняется в  результате  обращения  другой
     программы  к  ДОС.  Обычно  программой-отцом  является  командный
     процессор ДОС (COMMAND.COM),  хотя  любая  программа  может  быть
     родителем любой другой.  Это поле в PSP содержит сегментный адрес
     PSP программы-отца.

          У командного процессора нет "папаши", поэтому это поле в PSP
     командного процессора содержит сегментный адрес собственного PSP,
     что является указателем на самого себя.










                                                                      168

          Таблица указателей файлов.(PSP:0x18)
     -----------------------------------------------------------------

          Это поле представляет  собой  массив  в  20  байт,каждый  из
     которых представляет указатель файла(file handler).  При открытии
     файла в программе ДОС возвращает  в  программу  номер  файла  для
     использования  при  обращении к ДОС для записи в файл и чтения из
     него.  (Программы на Си, использующие потоковый ввод-вывод, прямо
     не  обращаются  к  этим  номерам - они используют указатель FILE,
     определенный в stdio; однако стандартные библиотечные функции Си,
     поддерживающие такой ввод-вывод, используют эти номера скрытым от
     вызывающей программы способом.) Эти номера файлов - номера байт в
     таблице   указателей  файлов,  а  элементы  этой  таблицы  хранят
     значения,  указывающие  на  соответствующую  файлу  структуру   в
     системных таблицах управления файлами.


          Сегментный адрес области системных параметров.(PSP:0x2c)
          --------------------------------------------------------

          Это поле   содержит   сегментный   адрес  области  системных
     параметров,  создаваемой ДОС для выполняемой  программы.  Область
     системных    параметров   -   это   выделенный   задаче   участок
     памяти, который может быть освобожден,  если значения  параметров
     не используются.


          Адрес стека на время вызова функции ДОС.(PSP:0x2e)
          --------------------------------------------------

          В это  поле ДОС записывает значения регистров сегмента стека
     и указателя стека  текущей  программы  при  вызове  из  программы
     функции ДОС.  Затем  ДОС  переключается на свой собственный стек.
     Перед возвратом в вызвавшую программу ДОС использует эти значения
     для восстановления значения этих регистров.


          Размеры таблицы указателей файлов.(PSP:0x32)
          --------------------------------------------

          Это поле  содержит  счетчик  количества  вхождений в таблицу
     указателей файлов. Обычно его значение равно 20. Заметим, что это
     поле не используется в версиях ДОС до 3.0.


          Адрес таблицы указателей файлов.(PSP:0x32)
          ------------------------------------------

          Это поле  содержит  полный  (long)  адрес таблицы указателей
     файлов;  сегмент этого адреса равен сегменту PSP;  а  смещение  -
     0х18. Заметим, что это поле не используется в версиях ДОС до 3.0.

          Вероятно, предыдущие  два  поля  добавлены,  чтобы позволить
     программе  использовать  более,  чем  20  одновременно   открытых
     файлов. После выделения большей таблицы надо поместить ее адрес и
     количество файлов в эти поля,  скопировать в нее 20  значений  из
     PSP,   и  таким  образом  программа  может  увеличить  количество
     одновременно  открытых  файлов  по  сравнению  со  значением   из
     оператора FILES=файла CONFIG.SYS.





                                                                      169

          Блок управления файлом #1.(PSP:0x5c)
          ------------------------------------

          Это поле  содержит блок управления файлом,  который строится
     ДОС  в  случае,  если  в  командной  строке  в  качестве  первого
     параметра было указано имя файла.


          Блок управления файлом #2.(PSP:0x6c)
          ------------------------------------

          Это поле  содержит блок управления файлом,  который строится
     ДОС  в  случае,  если  в  командной  строке  в  качестве  второго
     параметра было указано имя файла.

          Предыдущие два   поля   созданы   для   поддержки  программ,
     конвертированных из CP/M.


          Остаток командной строки/Дисковый буфер.(PSP:80)
          ------------------------------------------------

          Последнее поле  также  создано  под  влиянием  CP/M.   После
     запуска программы все, что находилось в командной строке, начиная
     со второго символа после имени программы,  строится в виде строки
     слов и  записывается  в  это  поле.  Лишние пробелы удаляются.  В
     первый байт поля записывается количество символов в  этой строке.

          Во время  выполнения  программы  это  поле  служит  дисковым
     буфером  для  работы  с  файлами  при  помощи старых функций ДОС,
     использующих блоки   управления   файлами.   Это    поле    также
     используется функциями ДОС, работающими с дисковыми каталогами.


          Контекстное переключение PSP.
          -----------------------------

          У каждой  программы  есть  свой PSP.  Но ДОС известен только
     один PSP - находящийся перед  программой,  запущенной  последней.
     Программа  в  ДОС может порождать выполнение другой программы,  и
     программы-дети могут наследовать значения из  PSP  "папаши",  но,
     так как ДОС знает только об одной активной задаче, то и только об
     одном PSP.

          PSP содержит несколько интересных полей, но самое интересное
     для   дальнейшего  обсуждения  -  это  массив  из  20  указателей
     файлов. Программа может открыть  до  20  файлов  одновременно.  С
     каждым   файлом  ассоциируется  указатель,  являющийся  элементом
     массива в PSP.  В этом массиве есть место для  20  указателей,  и
     первые пять из них отданы для логических устройств stdin, stdout,
     stderr, stdaux,  stdprn.  При  открытии  файлов  новые  указатели
     записываются  в  массив,  неиспользуемые  позиции  массива  имеют
     значение -1. К файлам программа обращается по номерам указателя в
     массиве,  а в элементе массива с таким номером хранится ссылка на
     соответствующую  структуру  в   системных   таблицах   управления
     файлами.








                                                                      170

          При открытии    файла    в   TSR-программе   его   указатель
     записывается в PSP этой программы.  При вызове TSR-программы  ДОС
     считает,  что  выполняется по-прежнему прерванная программа.  При
     обращении к ДОС для работы с файлом,  открытым при первоначальном
     запуске  TSR-программы,  ДОС будет брать указатель файла с данным
     номером из  PSP  прерванной  программы.  Поэтому   возможно   или
     обращение  к  чужому файлу,  если файл с таким номером открыт и в
     прерванной программе,  или  ошибка  по  обращению  к  неоткрытому
     файлу.

          Разрешить эту проблему можно следующим образом:

          - не  открывать файлов во время инициализации TSR-программы;
     открывать их после вызова и прерывания  другой  программы.  Тогда
     для  файлов  TSR-программы  будут  использоваться указатели в PSP
     прерванной программы.

          - не использовать работу с  указателями  файлов  ДОС  2.0  и
     выше. Пользоваться  FCB(File  Control  Block)  из  ДОС  1.1.  Эти
     функции не используют PSP.  Таблицы FCB строятся в области данных
     программы, использующих файлы.

          - переключить    системный    указатель   PSP   при   вызове
     TSR-программы на ее PSP,  и после отработки вернуть все  на  свои
     места.

          Каждое из этих решений имеет свои недостатки:

          - При   использовании   таблицы  указателей  файлов  из  PSP
     прерванной программы имеются два серьезных недостатка. Во-первых,
     может  оказаться  неприемлемым  открывать  и  закрывать файлы при
     каждом вызове TSR-программы.  Во-вторых,  нельзя быть  уверенным,
     что  в  таблице прерванной задачи достаточно места для указателей
     файлов TSR-программы.

          - Использование     функций     с     FCB     имеет      два
     недостатка. Во-первых,  файлы,  открываемые с помощью FCB, должны
     быть в текущем подкаталоге. Пути для спецификации файла указывать
     нельзя. Во-вторых,  все стандартные библиотечные функции Турбо Си
     для работы с  файлами  предполагают  использование  более  гибких
     указателей. Для  использования  FCB  вы  должны  создать функции,
     эквивалентные стандартным open, close, read, write, fclose, fget,
     fput, fprintf и т.д.

          - Не  имеется  документированной  функции  ДОС для изменения
     адреса PSP.  Есть документированная функция для  чтения  текущего
     PSP (INT 0x21, функция 0x62), но она доступна только в ДОС версии
     3.0 и выше.  Две функции  ДОС  (0х50  и  0х51),  не  описанные  в
     документации,  устанавливают  и  записывают  адрес  PSP,  но  они
     недоступны для использования резидентными программами в ДОС 2.0 и
     2.1. Они разделяют стек с некоторыми функциями ДОС, которые могут
     быть прерваны   резидентной   программой.   Если    TSR-программа
     использует   функции   0х50   и   0х51  в  этом  случае,  система
     зависнет. Эти функции можно использовать только с ДОС  версий 3.0
     и выше. Адрес PSP называется идентификатором процесса (Process ID
     - PID).  Две скрытые функции ДОС носят название GetPID  (получить
     идентификатор процесса)   и   SetPID   (установить  идентификатор
     процесса).






                                                                      171

          Ни одно из  этих  решений  не  является  удовлетворительным.
     Необходимы работающие заменители функций GetPID и SetPID. Одно из
     решений - экспериментально определить адрес,  куда ДОС записывает
     PID. Этот  адрес,  конечно,  зависит  от  версии ДОС и может быть
     уникальным даже при использовании одной версии ДОС. Использование
     таких значений является опасным решением.

          Лучшим является  определение  адреса PID оперативно во время
     выполнения TSR-программы.  Найти адреса, куда ДОС записывает PID,
     можно, используя   следующую   процедуру.  Сначала,  текущий  PID
     восстанавливается с  использованием  функции  GetPID.  Затем   по
     памяти,  занимаемой  ДОС,  осуществляется  поиск  копии  значения
     PID. Как только такое значение находится,  его адрес запоминается
     и PID изменяется на какое-либо значение с помощью функции SetPID.
     Значение по найденному адресу  анализируется  на  нахождение  там
     нового значения.  Если  это так,  то обнаружен адрес,  куда в ДОС
     записывается PID,  и он запоминается. Первоначальное значение PID
     восстанавливается, и   поиск  продолжается.  Версии  ДОС  до  3.0
     сохраняют PID в двух местах.  Версии от 3.0 и  выше  поддерживают
     одно значение   PID.   Адреса   PID  и  PID  самой  TSR-программы
      записываются до завершения и  обьявления  себя  резидентной. При
     вызове TSR-программы один из сохраненных адресов PID используется
     для чтения PID прерванной программы.  Это значение  запоминается,
     устанавливается  значение  PID   резидентной   программы.   Перед
     завершением резидентной программы она восстанавливает  в  системе
     PID прерванной программы.

          Этот способ  используется в функциях резидентного драйвера в
     главе 12.


          Дисковый буфер.
     -----------------------------------------------------------------

          Вторая часть  PSP  -  это  дисковый  буфер,  область,  через
     которую ДОС   пишет   и   читает  дисковые  файлы,  открытые  для
     использования  с  FCB.  ДОС  также  использует  эту  область  для
     функций, работающих с подкаталогами.

          В библиотеке    Турбо    Си   есть   функции,   читающие   и
     устанавливающие адрес дискового буфера.  Getdta возвращает  адрес
     текущего дискового буфера,  и setdta изменяет адрес.  Эти функции
     имеют следующий формат:

     #include <dos.h>
     char far *dta;

     dta = getdta();

     setdta(dta);

          Если TSR-программа  будет использовать функции ДОС,  которые
     пишут в дисковый буфер,  она  должна  сохранить  адрес  дискового
     буфера прерванной программы, установить свой, и перед завершением
     работы восстановить предыдущий адрес.

          Если TSR-программа  будет  писаться  на  Си,   нельзя   быть
     уверенным,  что  она  не  изменяет  или  не  использует  дисковый
     буфер. Действия функций из библиотеки Си достаточно не изучены, и
     лучшим  решением  будет  самое  осторожное.  Резидентный драйвер,
     описанный в  главе  12,  сохраняет  дисковый   буфер   прерванной
     программы.


                                                                      172


          Прерывание от клавиатуры (9).
     -----------------------------------------------------------------

          При нажатии   пользователем   "горячего  ключа"  резидентная
     программа должна прервать  все,  что  бы  ни  делала  система,  и
     запустить себя.  Чтобы сделать это,  программа должна сканировать
     клавиатуру в поисках "горячего ключа".  Понимание этого  процесса
     требует  понимания,  как  работает  прерывание  от  клавиатуры  и
     сканирование кодов.

          Нажатие клавиши  генерирует  прерывание   9,   и   обработка
     передается программе  по адресу вектора прерывания 9.  Она должна
     прочитать порт  данных  клавиатуры  и  обработать  это  значение.
     Клавиатура  PC  генерирует  код сканирования,  который может быть
     прочитан из входного  порта  клавиатуры,  а  не  значение  ASCII,
     поступающее  в вашу программу при использовании функции get_char.
     Каждая клавиша на клавиатуре  имеет  свое  собственное  значение.
     Программа  должна  определить  по  нему,  какая  клавиша  или  их
     комбинация нажата, и что делать с ними.

          Программа обработки прерывания от клавиатуры,  находящаяся в
     ROM-BIOS (базовой   системе  ввода-вывода  в  ПЗУ),  читает  коды
     сканирования, переводит их в коды ASCII,  и пересылает их в буфер
     клавиатуры. Программы   (включая  ДОС),  читающие  с  клавиатуры,
     читают коды из  буфера.  ROM-BIOS  поддерживает  байт  состояния,
     показывающий,  были  ли нажаты клавиши Alt,  правый Shift,  левый
     Shift, и  Ctrl.   Программа   может   прочитать   эти   значения,
     восстановив у себя байт состояния. В главе 12 иллюстрируются коды
     сканирования и значения байта состояния клавиатуры.

          TSR-программа может  присоединить  себя  к   прерыванию   9.
     Подпрограмма  обработки  прерывания в резидентной программе может
     поддерживать  выполнение  программы  из  ROM-BIOS,   читая   коды
     сканирования и байт состояния,  и проверяя,  не нажат ли "горячий
     ключ". Если нет, то обработка дальше предоставляется программе из
     ROM-BIOS.

          Если в  TSR-программе нет вызовов функций ДОС,  подпрограмма
     обработки  прерывания  9  может  непосредственно  выполнить  свою
     функцию.   Если   же   необходимо   использовать   функции   ДОС,
     подпрограмма должна выставить флаг присутствия "горячего ключа" и
     закончить работу. Другие подпрограммы обработки прерывания должны
     заметить этот флаг и выполниться,  если это  безопасно.  Одна  из
     подпрограмм, ждущая подходящего момента для выполнения функции, -
     это подпрограмма обработки прерывания от таймера.


          Прерывание от таймера.
     -----------------------------------------------------------------

          Работа PC  прерывается  18.2  раза   в   секунду   системным
     таймером,  который  использует вектор прерывания 0х1c для запуска
     подпрограммы обработки.  В главу 12  включен  пример  резидентной
     программы       "часы",      использующей      прерывание      от
     таймера. TSR-программы,  вызываемые по  "горячему  ключу",  также
     должны использовать это прерывание, поэтому надо прикрепиться и к
     вектору 0х1с.  Так как программа не может  выполняться,  пока  не
     убедится,  что  использование  функций  ДОС  безопасно,  то  надо
     проверить, установлен ли флаг "горячего ключа", как описано выше,
     и затем  проверить безопасность.  Если эти два условия выполнены,
     то подпрограмма обработки прерывания от таймера  может  запускать
     основную резидентную программу.

                                                                      173

          Как и  в  случае  с  прерыванием от клавиатуры,  должна быть
     реализована  возможность  работы   с   прерыванием   от   таймера
     программе,  которая до этого была обработчиком такого прерывания.


          Проблема реентерабельности ДОС.
     -----------------------------------------------------------------

          Вы уже  читали  о  проблемах,  возникающих при использовании
     функций ДОС из резидентных  программ.В  случае,  когда  программа
     прерывает  ДОС  и хочет использовать ее функции,  ДОС не является
     реентерабельной.  Может случиться так,  что при нажатии "горячего
     ключа"  ДОС  будет  находиться в состоянии ввода с клавиатуры,  и
     пользователю не удастся быстро вызвать TSR-программу,  так как до
     окончания ввода она не может начать выполнение.


          Два стека ДОС.
     -----------------------------------------------------------------

          ДОС поддерживает  два  стека.Когда  ДОС  выполняет  одну  из
     функций с номером от 0  до  12,  используется  первый  стек;  при
     выполнении других  функций  используется  второй.  ДОС  сохраняет
     значение сегментного регистра стека и регистра смещения стека для
     каждой  группы  функций  отдельно;  но  реентерабельных  функций,
     однако, нет.  Сохраненные значение регистров  при  первом  вызове
     функции могут быть затерты при следующем вызове.

          ДОС лучше определить как полуреентерабельную. При прерывании
     выполнения функций 0-12 безопасно вызывать остальные  функции,  и
     наоборот.

          Можно легко   избежать   использования   функций  0-12.  Они
     предназначены для организации консольного ввода и вывода. Но есть
     много других способов,  чтобы управлять клавиатурой и экраном,  и
     частенько они работают  лучше,  чем  функции  ДОС.  Использования
     остальных функций  не  так-то легко избежать.  С их помощью можно
     делать многое из того, что нужно в резидентной программе, включая
     управление файлами.

          Если вы  можете  избежать  использование  функций  0-12,  но
     нуждаетель в остальных функциях,  то  ситуация  с  двумя  стеками
     работает на вас.  При уверенности, что прерывания по вызову вашей
     программы будут происходить не во  время  работы  функций  второй
     группы,  проблемы  реентерабельности  не существует. Задачу можно
     решить установкой  флажка  ввода  "горячего  ключа"  и  ожиданием
     окончания  работы  небезопасных  функций ДОС,  если таковая имеет
     место. Эти функции работают быстро,  так что большой задержки  не
     получится.

          Теперь остальсь узнать, каким способом получить информацию о
     возможности использовать ДОС. Такую информацию содержит системный
     флажок занятости.



          Системный флажок занятости (0х34).
     -----------------------------------------------------------------

          Функция ДОС 0х34  возвращает  сегментный  адрес  и  смещение
     специального флага в памяти,  поддерживаемого ДОС.  Он называется
     системным флажком занятости. Этот флаг устанавливается, когда ДОС
     выполняет одну  из своих "небезопасных" функций.  После выхода из
     функции ДОС очищает флаг.
                                                                      174

          При первом запуске TSR-программы она использует  функцию ДОС
     0х34  для  нахождения  и  запоминания  адреса  системного  флажка
     занятости.  При   каждом   прерывании   от   системного   таймера
     обработчик, находящийся в TSR-программе, проверяет наличие флажка
     "горячего ключа",  устанавливаемого  обработчиком  прерывания  от
     клавиатуры, и отсутствие системного флажка занятости. При наличии
     этих двух условий обработчик таймера сбрасывает  флажок "горячего
     ключа" и запускает основную часть TSR-программы.

          Такая процедура  временами  срабатывает.  Но  временами  ДОС
     остается  занятой,  пока  пользователь   занят   чем-то   другим,
     например, набирает  символы в командной строке.  Если при этом он
     нажмет "горячий ключ",  то обработчик клавиатуры  установит  флаг
     "горячего  ключа",  но  обработчик  таймера  никогда  не запустит
     TSR-программу. Чтобы бороться в таких условиях, надо использовать
     вектор прерывания DOSOK.


          Прерывание DOSOK.
     -----------------------------------------------------------------

          Часто наступают   периоды,   когда   ДОС  занята,  но  можно
     использовать вторую группу функций;  например,  когда ДОС ожидает
     ввода строки символов. В этом случае ДОС вызывает прерывание 0х28
     - DOSOK.  Цель этого - известить  TSR-программу  (в  частности  -
     системный  спулер  PRINT.COM  ),  о  том,  что можно использовать
     функции второй группы.  Если никакая программа не  прикреплена  к
     этому прерыванию,   оно   просто   указывает   на  команду  IRET.
     Прерывание 0х28    -    программное    прерывание;    обработчик,
     прикрепленный  к  нему,  будет  вызываться из другой программы по
     команде INT 0х28.

          TSR-программы могут  прикрепляться  к  прерыванию  DOSOK   и
     использовать его для обнаружения занятости ДОС.  Обработчик этого
     прерывания из TSR-программы проверяет установку  флажка "горячего
     ключа"  и  в  зависимости от его значения либо запускает основную
     часть  TSR-программы;  либо  возвращает   управление   программе,
     вызвавшей  это прерывание,  или программе,  ранее прикрепленной к
     этому прерыванию.

          Прерывание DOSOK вызывается  в  случае,  когда  ДОС  занята;
     однако  TSR-программа,  вызванная  в  это  время,  не  может быть
     прервана  другой  такой  же   программой   до   тех   пор,   пока
     выполняющаяся  TSR-программа  не  сделает  вызов прерывания 0х28.
     Причина  этого  ограничения  в  том,  что  когда   ДОС   вызывает
     прерывание  DOSOK,  флажок  занятости ДОС остается установленным.
     При выполнении TSR-программы  он  не  меняет  значения,  и,  если
     пользователь нажмет  "горячий ключ" для другой TSR-программы,  ее
     обработчик  таймера  будет  ожидать,  пока  флажок  занятости  не
     сбросится. А    это    не    случится    до   окончания   текущей
     TSR-программы. Такая  ситуация  всегда   случается   при   вызове
     TSR-программы   в   момент,   когда  ДОС  ожидает  ввода  команды
     пользователя.

          Резидентная программа,   чтобы   разрешить   прервать   свое
     выполнение  другой такой же программе,  должна вызвать прерывание
     DOSOK в подходящее время.  Лучше всего это сделать, когда текущая
     программа ожидает ввода строки от пользователя.  Если вы обратили
     внимание, функция get_char из главы 4 вызывает прерывание 0х28 во
     время ожидания ввода строки. Это делается для поддержки концепции
     резидентных программ,  описанной в этой главе  и  используемой  в
     главе 12.


                                                                      175

          Дисковое прерывание ROM-BIOS.(0х13)
     -----------------------------------------------------------------

          Дисковые операции   нельзя   прерывать  из-за  возникновения
     ошибок в   прерванной   программе.    Чтобы    избежать    этого,
     TSR-программа должна присоединить себя к дисковому прерыванию ROM
     -BIOS 0х13. Если какой-либо процесс вызывает это прерывание, TSR-
     программа  устанавливает  флаг  и  затем  передает  управление по
     старому адресу  прерывания.  Когда  обработка   прерывания   0х13
     завершается, TSR-программа  очищает  флаг.  Этот флаг проверяется
     ISR таймера и DOSOK.  Если производится дисковая операция, то TSR
     не разрешает прерывание.

          Прерывание тяжелой ошибки в ДОС.(0х24)

          При возникновении  тяжелой  ошибки  ДОС  вызывает прерывание
     0х24. Например, при обращении к дискете в открытом дисководе, ДОС
     обнаруживает состояние неготовности и вызывает прерывание тяжелой
     ошибки. Если программа не присоедиила себя к  вектору  0х24,  все
     критические   ошибки   будут   обрабатываться   ISR  в  командном
     процессоре ДОС.  Он выдает сообщение "Abort,Retry,  or Ignore" на
     экран. ISR   возвращает  в  ДОС  значение,  определяющее  порядок
     дальнейшей обработки.

          Предположим, что ни одна программа не присоединена к вектору
     0х24. Ваша  TSR  прерывает  нерезидентную  программу,  и пытается
     прочитать дискету из открытого дисковода. Командный процессор ДОС
     перехватывает управленеие и запрашивает пользователя о дальнейших
     действиях. Пользователь  отвечает  "A"  (Abort-прервать),  и  ДОС
     пытается прервать выполнение программы. Если ваша TSR переключила
     адрес PSP,  то ДОС будет пытаться прервать TSR. ДОС не знает, что
     в   памяти   находится   нерезидентная   программа  в  прерванном
     состоянии, и не возвращает ей управление.  Система ломается. Если
     TSR не переключала PSP,  то ДОС завершает нерезидентную программу
     и не возвращает управление TSR.

          Предположим, что нерезидентная  программа  присоединилась  к
     вектору   0х24.   Дисковая   ошибка  в  вашей  программе  вызовет
     исполнение обработчика тяжелой ошибки из прерванной нерезидентной
     программы.

          TSR должна  присоединяться  к  вектору  0х24 в любом случае,
     будет ли или не будет в ней какая-либо обработка  ошибок.  Вектор
     присоединяется при "всплытии" TSR и восстанавливается на тот, что
     был, при возвращении управления в прерванную  программу.  Никакие
     обстоятельства  не  должны  заставить  TSR  просить  ДОС прервать
     обработку. Большинство TSR-программ просто  игнорируют  ошибки  и
     говорят ДОС  также их игнорировать.  Прерывание тяжелой ошибки не
     связывается в цепочки - это  опасно.  Если  другая  TSR-программа
     (например,  спулер)  присоединила  к  себе  вектор 0х24 и вызвана
     после вашей TSR,  она получит ваши ошибки.  Если же эта программа
     была  вызвана  до  вашей  TSR,  то вы будете получать ее ошибки и
     говорить ДОС игнорировать их,  что  является  проблемой,  которую
     нельзя    разрешить   без   написания   системно-ориентированного
     обработчика ошибок.









                                                                      176

          Прерывание Ctrl-Break в ДОС.(0х23)
     -----------------------------------------------------------------

          При нажатии пользователем клавиш Ctrl-Break  ДОС  отображает
     на  экране  в  текущей  позиции  курсора  символы  ^C  и вызывает
     прерывание 0х23.  Обработчик этого прерывания,  имеющийся в  ДОС,
     вызывает немедленное  завершение текущей программы. TSR-программу
     завершать  таким  способом   нельзя:   слишком   много   векторов
     прерываний  прикреплено  к  ней,  и нерезидентная программа может
     находиться в памяти за ней.  Если вы  просто  проигнорируете  это
     прерывание,  имеется риск,  что другая программа,  загруженная за
     вашей,  присоединит себя к  этому  прерыванию  и  сделает  что-то
     неподходящее  при  нажатии  клавиш Ctrl-Break во время выполнения
     вашей программы.

          В ДОС имеется функция (0х33),  которая  позволяет  программе
     читать  текущий статус (разрешено/запрещено) обработки Ctrl-Break
     и  устанавливать  его.  При  вызове  TSR-программы   она   должна
     прочитать  текущее значение статуса,  и затем запретить обработку
     Ctrl-Break.  При завершении своей работы TSR должна  восстановить
     значение статуса  обработки  Ctrl-Break.  Присоединяться  к этому
     прерыванию нет необходимости.

          После таких действий вашей TSR в случае  нажатии  Ctrl-Break
     во время ее выполнения, после возврата в прерванную программу она
     будет закончена  ДОС.  Если  все  TSR  будут  использовать  такой
     способ,  то  завершаться по Ctrl-Break будут только нерезидентные
     программы.


          Выполнение TSR-программы.
     -----------------------------------------------------------------

          Выполнение TSR-программы проходит в два этапа. Первый этап -
     когда пользователь  запускает  ее из командной строки.  Программа
     выполняет  инициализационный  код,   сохраняет   свой   контекст,
     присоединяет себя к прерываниям,  если это нужно, и завершается с
     использованием функции  ДОС  TSR,  таким  образом  объявляя  себя
     резидентной.

          Второй этап  -  когда TSR-программа запускается в результате
     одного из прерываний,  к которому она прикрепилась. В большинстве
     случаев,  векторы прерываний связываются в цепочки,  как это было
     описано ранее.  Программа определяет,  может ли она выполняться -
     это  зависит от состояния некоторых важных системных индикаторов,
     описанных  выше.  Если  она  может  выполняться,  она   сохраняет
     контекст  прерванной программы,  восстанавливает свой собственный
     контекст,  выполняет  свою   задачу,   восстанавливает   контекст
     прерванной программы, и передает ей управление.



               Завершение TSR-программы.
     -----------------------------------------------------------------

          Могут быть причины,  по которым вы можете захотеть завершить
     TSR-программу, что  отнюдь не является легкой задачей. Вспомните,
     ведь ДОС не знает ничего о программе,  оставшейся резидентной,  и
     вам самим надо сделать все то, что обычно делает ДОС по отношению
     к обычным нерезидентным программам.




                                                                      177

          Завершение TSR-программы включает в себя следующие шаги:

          1. Сообщение программе о том, что ей надо завершиться.

          Для этого можно  использовать  другой  "горячий  ключ",  или
     коммуникационный  вектор  прерывания,  указывающий на сигнатуру в
     программе, означающую,  что программа уже в памяти.  Второй метод
     используется в драйвере TSR-программ,  описанном в главе 12.  При
     этом  пользователь,  знающий,  что  программа   уже   резидентна,
     запускает  ее  второй  раз,  давая  в  командной строке параметр,
     означающий, что программа должна завершиться. Программа ищет свою
     сигнатуру способом,  описанным выше. При нахождении сигнатуры она
     также находит свой  вектор  прерывания.  Через  этот  вектор  она
     посылает команду завершения свой резидентной копии, после чего та
     совершает следующие шаги завершения.

          2. Восстановление  векторов  прерывания   в   первоначальное
     состояние.

          У вас может быть возможность сделать это, а может и не быть.
     Если другая TSR-программа  была  загружена  после  вашей,  и  она
     связала векторы  в  цепочки,  то вы успешно дезактивируете ее при
     восстановлении векторов.  Далее,  если  эта  TSR-программа  будет
     затем завершена,  то  она переустановит вектора на адреса в вашей
     программе,  по которым уже может находиться неизвестно  что.  Так
     что  до того,  как восстанавливать вектора,  надо убедиться,  что
     ваша программа до сих пор владеет ими. Чтобы определить это, надо
     сравнить   адреса,  находящиеся  в  соответствующих  векторах,  с
     адресами соответствующих обработчиков  в  вашей  программе.  Если
     какой-либо  вектор изменен,  то ваша программа уже не владеет им,
     поэтому завершать ее нельза и надо просто приостановить ее.

          Еще одним осложнением,  возникающем при завершении вашей TSR
     с  другой  программой  такого  же  типа,  загруженной  после нее,
     является фрагментация памяти в  нерезидентной  области. ДОС будет
     использовать   область,   освобожденную   вашей  программой,  при
     запросах на память из выполняющихся  программ,  но  для  загрузки
     других программ эта область не будет использоваться. Помните, что
     ДОС - однозадачная ОС - не понимает  концепции  фрагментированных
     программ, потому что она не понимает мультипрограммирование.

          3.Закрытие всех файлов, открытых в программе.

          При завершении  нерезидентной  программы  ДОС  автоматически
     закрывает все файлы,  сканируя массив указателей файлов программы
     в   PSP   и   закрывая   все   вхождения   в  него,  которые  еще
     используются. Помните,  что эти вхождения - это номера  элементов
     массива, который  поддерживает  ДОС.  При завершении и объявлении
     резидентной ДОС не закрывает файлы,  открытые этой программой,  и
     при завершении  работы TSR-программы необходимо это сделать. Если
     файлы не будут закрыты, то элементы массива не будут освобождены,
     и   будут   недоступны   для  дальнейшего  использования  другими
     программами. Загрузка   и   завершение   без   закрытия    файлов
     TSR-программ  может  привести  к  исчерпанию таблицы файлов ДОС и
     "зависанию" системы.









                                                                      178

          Элементы в таблице указателей файлов представляют  файлы  на
     уровне  указателей.  Это  эквивалентно функциям небуферизованного
     ввода-вывода низкого  уровня  в  Си.  Функции   Си,   выполняющие
     буферизованный  потоковый  ввод-вывод,  поддерживают  собственные
     буферы и  указатели   и   могут   потребовать   особого   порядка
     закрытия, называемого    потоковым.    Такое   закрытие   -   это
     библиотечная функция Си,  отличающаяся от соответствующей функции
     ДОС. Такие  файлы  надо  закрывать  стандартной  функцией fclose.
     Файлы,  открытые функциями  open  и  creat,  могут  быть  закрыты
     функцией close.

          4.Возврат памяти, занимаемой программой, в ДОС.

          Для этого    можно    использовать    функцию    ДОС   0х49.
     TSR-программой, как минимум,  занимается два блока памяти. Первый
     - это блок системных параметров, адрес которого хранится в PSP со
     смещением 0х2с.  Второй  блок  -  это  сам  PSP.  Если  программе
     выделены оба этих блока, то они оба должны быть возвращены ДОС. В
     главе 12 демонстрируется техника сканирования  списка управляющих
     блоков  памяти  ДОС  для  нахождения  и  возвращения в ДОС блоков
     памяти, выделенных программе.


          Приостановка и возобновление выполнения TSR-программы.
     -----------------------------------------------------------------

          При приостановке TSR-программы ее не удаляют  из  памяти,  а
     только  дают  ей  команду  не  реагировать  на  прерывания  путем
     установки флага.  Команда возобновления сбрасывает этот  флаг.  С
     этой целью можно использовать коммуникационный вектор прерывания.

          TSR-драйвер в   главе   12   использует   эту   технику  для
     завершения,    приостановки,    и    возобновления     выполнения
     TSR-программ.



          Выводы.
     -----------------------------------------------------------------

          В этой  главе описывается операционное окружение резидентных
     программ. В главе 12 на примере двух таких  программ  описывается
     весь процесс  шаг  за  шагом.  Первая программа - это оперативная
     программа-часы,  которая  поддерживает   на   экране   постоянное
     отображения текущих   времени  и  даты.  Вторая  программа  более
     интересна - это TSR-драйвер.  Вы  связываете  свою  программу  на
     Турбо  Си  c  этим драйвером,  используя некоторые соглашения для
     инициализации,  и  ваша  программа   на   Турбо   Си   становится
     резидентной. Это   значит,  что  программа  будет  вызываться  по
     нажатию клавиши,  что она может  открывать,  читать,  пиать  в  и
     закрывать дисковые файлы, что она использует ROM-BIOS функции для
     чтения с клавиатуры и прямой доступ к видеопамяти для  вывода  на
     экран, и что она никогда не выходит в ДОС.











                                                                      179