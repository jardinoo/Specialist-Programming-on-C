
                             ГЛАВА 5
                             -------

                           Экранные окна
     -----------------------------------------------------------------


         Этот раздел посвящен вопросу о том,  что  собой  представляют
     экранные  окна  и как с ними работать.  Раздел 6 разъясняет,  как
     можно использовать окна в ваших программах,  создаваемых в  среде
     Турбо  Си,  а также содержит полную библиотеку функций управления
     окнами.  Следующие  разделы   содержат   расширенную   библиотеку
     функций,  поддерживающих работу с окнами для специфических целей,
     как,  например,  для контекстно-чувствительного вывода справочной
     информации,  редактирования текста, ввода данных и создания меню.

          После того,  как вы прочитали об экранных окнах, способах их
     создания  и   применения,    постарайтесь  вспомнить  программные
     системы,   которые   используют   подобные  средства.   Подумайте
     также и о том,   какую пользу могли бы принести  эти средства для
     тех  программных проектов,  в которых вы принимали участие. Затем
     попытайтесь найти в этих функциях недостатки,  устранение которых
     позволит   сделать функции более подходящими для вашей работы.  В
     любой программе вы  почти всегда можете отыскать  эти недостатки.
     В данном случае вы имеете большое  преимущество:  исходные тексты
     функций  предоставлены,  вы  можете  модифицировать  их по своему
     усмотрению.



                Экранное окно
     -----------------------------------------------------------------

          Окном называется    область    экрана    дисплея,    которая
     используется  для  определенных  целей.  Окно  обычно имеет форму
     прямоугольника или квадрата,  а его границей  служат  символы  из
     набора   графических   символов.  Использование  окон  становится
     наиболее   популярным    способом    представления    информации,
     предназначенной  для  восприятия пользователем ПЭВМ.  Этот способ
     позволяет  на   ограниченном   пространстве   экрана   отображать
     информацию,    передаваемую   множеством   задач,   выполняющихся
     асинхронно.

          Поскольку отображаемые  на  экране изображения формируются в
     видеопамяти с прямым доступом процессора (так  называемый  способ
     формирования   изображения путем  управления  содержимым памяти),
     то  окна  на  экране  создаются мгновенно,   возникая  как  бы из
     ничего,   и так же  мгновенно   исчезают.  Использование  окон  в
     программах  позволяет  очень  удобно  отображать  различного рода
     информацию.    Окна  появляются    и  сменяют  друг  друга:   они
     появляются  на экране,   когда это необходимо,   и исчезают после
     того,   как информация,   которую они  содержат,  становится  вам
     ненужной.   Программа  может  отображать  столько  окон,  сколько
     нужно программисту.  Окна могут иметь различные размеры,  цвета и
     форматы.  Вы можете разместить окно в любом месте экрана, где это
     необходимо.  Если окно становится ненужным,  то вы можете удалить
     его,   и окно исчезнет,  а на его месте будет то, что было до его
     появления.

          Каждый, кто занимался проблемами автоматизации  в  последние
     годы,  обязательно  сталкивался  с  окнами.  ПЭВМ  IBM  PC сейчас
     встречаются везде,  в любой сфере общественной и деловой жизни. И
     почти  на каждой из  них работает  вездесущая программа Sidekick,
     включающая калькулятор,  календарь и средства вызова  абонента  в
                                                                       33

     сети.  Каждый   из  этих компонентов отображает свою информацию с
     помощью  окон,    которые  по  мере  необходимости  появляются  и
     исчезают на экране, не разрушая того изображения, которое было до
     их  появления.  Волшебники  в  области  разработки   программного
     обеспечения  и  ее сбыта  из фирмы Bоrland International (это они
     дали Вам Турбо Си)  внедрили окна во всеобщую  практику.  Если вы
     никогда   не  видели окон,  то отложите книгу в сторону,  найдите
     IBM PC и нажмите одновременно клавиши <Alt>  и <Ctrl>. Если вы не
     увидите после этого  красно-бело-зелено-голубого  окна  на экране
     (или зеленого и черного для монохромного экрана),   то спросите у
     владельца машины,  почему у него не работает  программа Sidekick.
     Если же окно небольшого размера все-таки появится,  начните с ним
     игру. Сделав выбор в меню,  содержащемся в первом окне, вы можете
     создать другое окно.  Вы можете перемещать окна,  нажимая клавишу
     со стрелкой.   Вы можете удалять окна,  нажимая клавишу <Esc>. Вы
     можете  вызвать  на  экран  справочную  информацию  по  работе  с
     программой, нажав клавишу <F1>.

          Из этого  раздела  вы  узнаете,  как работать с окнами,  как
     накладывать их друг на друга,  как перемещать их по экрану и  как
     их  использовать  в  своих программах,  разрабатываемых с помощью
     Турбо Си.  Окна используются для отображения меню, информационных
     и предупреждающих сообщений,  текстовых файлов, шаблона для ввода
     данных  и  контекстно-чувствительных  информационных   сообщений.
     Программные  системы  могут  использовать  окна  для  отображения
     информации независимо от содержания других окон и размера области
     пространства экрана,  занимаемой другими окнами.  Благодаря этому
     можно обозревать на экране несколько окон,  даже если  каждое  из
     них занимает больше половины экрана, потому что окна могут как бы
     "всплывать" друг над другом.

          Свойство всплывания окон  часто  объясняют  путем  сравнения
     экрана  дисплея  с поверхностью стола.  Допустим,  на вашем столе
     лежит множество документов,  но в каждый момент времени вы можете
     работать  только с одним из этих документов,  возможно,  наиболее
     важным для вас.  То, что можно делать с бумагами, можно выполнять
     и  на  экране  дисплея.  Если первоначально изображение на экране
     содержит только одно окно,  как  это  показано  на  рис.  5.1,  и
     программе  необходимо создать второе окно,  не уничтожая при этом
     первого,  то в результате получится изображение, как на рис. 5.2.
     Если затем второе окно становится ненужным,  то оно уничтожается,
     и изображение снова будет соответствовать рис. 5.1.


     ┌───────────────────────────────────────────────────────────┐
     │                                                           │
     │                                                           │
     │ ┌──────────────────────────┐                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │        Окно  A           │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ └──────────────────────────┘                              │
     │                                                           │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

                Рис. 5.1  Экранное окно

                                                                       34

     ┌───────────────────────────────────────────────────────────┐
     │             ┌────────────────────────────┐                │
     │             │                            │                │
     │             │                            │                │
     │ ┌───────────┤                            │                │
     │ │           │          Окно  B           │                │
     │ │           │                            │                │
     │ │           │                            │                │
     │ │           │                            │                │
     │ │        Окн│                            │                │
     │ │           │                            │                │
     │ │           │                            │                │
     │ │           └──────────────┬─────────────┘                │
     │ │                          │                              │
     │ └──────────────────────────┘                              │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

                Рис. 5.2  Наложение окон

          Для того,  чтобы  понять,  как  можно   использовать   окна,
     необходимо  знать,  какие  действия  с  окнами  можно  выполнять.
     Помните,  что окном  является  прямоугольная  область  на  экране
     дисплея.  Окна имеют и другие свойства,  но главное, что отличает
     их от других типов экранных изображений, - это их способность как
     бы всплывать и погружаться относительно остального изображения.

          Информация, которая     содержалась     в    соответствующей
     прямоугольной области экрана до  появления  нового  окна,  должна
     сохраняться.  Окно  накладывается  на предшествующее изображение,
     как бы  всплывает.  Когда  окно  уничтожается  (погружается),  то
     информация,   которая   была   до   его  появления,  должна  быть
     восстановлена.  Та часть изображения,  на  которую  накладывается
     новое окно,  также может содержать окна. На рис. 5.3 представлено
     изображение на экране дисплея,  которое содержит несколько  окон,
     причем   каждое   последующее   окно   накладывается   на   часть
     предыдущего.


     ┌───────────────────────────────────────────────────────────┐
     │             ┌────────────────────────────┐                │
     │             │                            │                │
     │             │                            │                │
     │             │                  ┌─────────┴──────┐         │
     │             │                  │                │         │
     │ ┌───────────┤                  │   Окно  D      │         │
     │ │           │          Окно  B │                │         │
     │ │           │                  │                │         │
     │ │           │   ┌──────────────┤                ├──┐      │
     │ │           │   │  Окно  C     │                │  │      │
     │ │        Окн│   │     ┌────────┴────────────────┴─┐│      │
     │ │           │   │     │                           ││      │
     │ │           │   │     │                           ││      │
     │ │           └───┤     │        Окно  E            ││      │
     │ │               │     │                           ││      │
     │ └───────────────┤     │                           ││      │
     │                 │     └────────┬────────────────┬─┘│      │
     │                 │              └────────────────┘  │      │
     │                 └──────────────────────────────────┘      │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

                 Рис. 5.2  Наложение нескольких окон

                                                                       35

          Если бы каждая программа,  работающая с окнами,  должна была
     управлять размещением окон и восстанавливать  содержимое  экрана,
     которое  было до их появления,  то создание и сопровождение таких
     программ было  бы  очень трудным делом.   К  счастью,  в этом нет
     необходимости.  Поскольку функции и свойства окон являются общими
     для разных применений,  то можно использовать  библиотеку функций
     общего назначения для  работы с окнами.  Настоящая книга содержит
     такую библиотеку, ее функции описаны в разделе 6.

          Основных операций  по  работе  с  окнами,  использующихся  в
     большинстве программ,  не так уж много,  и они не слишком сложны.
     При работе с окнами вам необходимо установить окно, определив его
     размеры   и   местоположение.   Вы   имеете   возможность   также
     устанавливать его цвета,  границу и заголовок.  Вы можете вписать
     свой текст  внутрь  окна,  а  также  при  необходимости  изменять
     местоположение  окна.  Наконец,  вы можете удалить окно с экрана,
     восстановив при этом  изображение,  которое  было  на  экране  до
     появления   окна.   Основываясь  на  этих  операциях,  вы  можете
     создавать программы,  которые  используют  чарующие  многоцветьем
     красок  окна  в  качестве пользовательского интерфейса.  (Следует
     помнить, что использование эффективной библиотеки само по себе не
     гарантирует   высокое   качество  пользовательских  характеристик
     разрабатываемой программы. Программист должен использовать вместе
     с   окнами  также  звуковые  эффекты  и  другие  инструментальные
     программные средства).

          Чтобы понять, как можно управлять изображением на экране, вы
     должны  разобраться  в  организации видеопамяти.  Приводимые ниже
     сведения представляют собой введение  в  архитектуру  видеопамяти
     IBM  PC.  Для получения исчерпывающей информации по этому вопросу
     обращайтесь к "Руководству Питера Нортона  для  программистов  по
     IBM PC" (Питер Нортон, Мicrosoft Press, 1985).



             Архитектура видеопамяти
     -----------------------------------------------------------------

          Система формирования   изображения   является   неотъемлемой
     частью  ПЭВМ  IBM PC.  В  более ранних  моделях  персональных ЭВМ
     видеотерминалы   подключались   через    последовательные   порты
     ввода/вывода,  но аппаратная архитектура IBM PC включает в себя и
     видеосистему.

          Предназначенное для вывода на экран изображение  создается в
     видеопамяти.  В  IBM PC в качестве видеопамяти используется часть
     оперативной памяти.  Видеопамять  доступна  для  чтения  и записи
     процессору  и,   следовательно, вашим программам. Видеопроцессор,
     входящий  в состав видеоконтроллера,   по содержимому видеопамяти
     постоянно   формирует   изображение на  экране  дисплея.  Поэтому
     каждый новый символ,   записанный в видеопамять, почти немедленно
     появляется   на  экране.   Поскольку   видеопамять  доступна  для
     микропроцессора,     то    скорость    формирования   изображения
     соответствует   скорости  пересылки  содержимого  памяти, которая
     превышает скорость передачи данных при подключении видеотерминала
     через последовательные порты ввода/вывода.

          Адреса видеопамяти и ее характеристики являются стандартными
     для всех ПЭВМ линии IBM PC, а также совместимых с ними.





                                                                       36

          ПЭВМ типа IBM PC  может  иметь  одну  из  трех  видеосистем,
     использующих  различные  типы  видеомониторов  и,  следовательно,
     различные типы видеоконтроллеров.  Видеоконтроллер  первого  типа
     называется  Монохромным  Адаптером  (МА),  он обеспечивает работу
     только  монохромного  видеомонитора  в  символьном  режиме  и  не
     поддерживает  графического  режима.  Видеоконтроллер второго типа
     называется  Цветным  Графическим  Адаптером  (CGA).   С   помощью
     контроллера  CGA  подключается  цветной  монитор,  который  может
     работать в двух различных режимах.  В символьном  режиме  имеется
     возможность выбирать цвет фона и цвет символа из восьми возможных
     цветов,  а также один из двух  уровней  интенсивности  цвета  для
     символа.   В   графическом  режиме  низкого  разрешения  (640x200
     растровых точек) можно работать только  с  одним  цветом.  Третий
     видеоконтроллер    называется   Усовершенствованным   Графическим
     Адаптером (EGA),  который поддерживает такой же символьный режим,
     что  и  CGA,  и  многоцветный  графический  режим  более высокого
     разрешения.

          Приведенные в  данной  книге  программы  работают с любым из
     этих контроллеров в символьном режиме.  Поскольку в  этом  режиме
     контроллеры   CGA   и   EGA   функционально    эквивалентны,   то
     нижеследующие  рассуждения   для  CGA  относятся   к  обоим  этим
     контроллерам.

          Видеопамять организована в виде двумерного массива символов,
     состоящего из рядов и колонок. Ее можно рассматривать и как набор
     следующих друг за другом 16-разрядных слов,  по одному на  каждый
     символ. Каждый ряд содержит 80 следующих друг за другом символов,
     все  они образуют  25  следующих друг  за  другом  колонок. Слово
     содержит  информацию  об  одном   символе   и   состоит  из  двух
     восьмибитных байт:  один -  для ASCII-кода символа,  второй - для
     атрибутов  символа,  определяющих   его  изображение.   Код ASCII
     записан в младшем (правом) байте слова.

          Видеопамять контроллера  МА  организована   в   виде   одной
     страницы,  а контроллера CGA - в виде четырех страниц.  Программы
     из этой  книги  используют  только  первую  страницу  видеопамяти
     контроллера CGA.

          Видеопамять расположена   в   верхних   областях  доступного
     процессору   адресного   пространства.   Разработчики   IBM   PC,
     столкнувшись  с  ограничением  на  максимальный объем адресуемого
     адресного  пространства   в   1   мегабайт,   решили   разместить
     видеопамять  и  ПЗУ  Базовой  Системы  Ввода-Вывода  (ROM BIOS) в
     верхних областях этого пространства.  Для того,  чтобы  позволить
     контроллерам   МА   и  CGA  работать  совместно  на  одной  ПЭВМ,
     разработчики назначили различные адреса сегментов видеопамяти для
     разных контроллеров.  Память контроллера МА начинается в сегменте
     0xB000,  а память контроллера CGA - в сегменте 0xB800.  Программа
     может  определить,  какой  из  контроллеров  используется,  путем
     вызова соответствующей функции  ROM  BIOS,  и  настроиться  таким
     образом  на соответствующий адрес сегмента видеопамяти. Поскольку
     архитектура видеопамяти для того  и  другого  случая  в  основном
     одинакова,  то  необходимые действия по настройке программы будут
     минимальными.

          Байт атрибутов  символа  содержит   2   трехразрядных   поля
     кодирования  цвета  (одно для цвета фона символа и одно для цвета
     самого символа),  разряд для задания уровня  интенсивности  цвета
     символа  и  разряд  для установки режима мерцания символа при его
     отображении.  На  рис.  5.4   представлена   конфигурация   байта
     атрибутов.


                                                                       37

     ┌────┬────┬────┬────┬────┬────┬────┬────┐
     │    │    │    │    │    │    │    │    │
     │ B  │ R  │ G  │ B  │ I  │ R  │ G  │ B  │
     │    │    │    │    │    │    │    │    │
     └─┬──┼────┴────┴────┼──┬─┼────┴────┴────┤
       │  └───────┬──────┘  │ └───────┬──────┘
       │          │         │         │
       │          │         │         └─────── цвет символа
       │          │         │
       │          │         └───────────────── интенсивность цвета
       │          │                                        символа
       │          └─────────────────────────── цвет фона
       │
       └────────────────────────────────────── мерцание символа


                Рис. 5.4   Байт атрибутов символа


          Комбинации красной,  зеленой и голубой цветовых составляющих
     позволяют получить набор из восьми отчетливо  различаемых цветов:
     белого, красного, зеленого, голубого, синего, малинового, желтого
     и черного.  Использование разряда интенсивности для цвета символа
     позволяет получить еще восемь дополнительных оттенков цвета.

          В случае  использования Монохромного Адаптера значение байта
     атрибутов  немного  отличается  от  описанного  выше.   Поскольку
     возможность   использования   различных цветов  не поддерживается
     контроллером МА,  то разрешены только комбинации  белого  символа
     на черном  фоне или черного  символа на белом  фоне.  Другие коды
     цвета  дают  комбинации  черного на  черном или  белого на белом.
     Хотя  следует   отметить,   что   комбинация   голубого символа и
     черного фона формирует изображение подчеркнутого  символа, что не
     поддерживается уже контроллером CGA.   Монохромный Адаптер, как и
     CGA,  поддерживает  возможности  задания  интенсивности  цвета  и
     режима мерцания символа.

          Поскольку вы теперь знаете,  где размещена видеопамять и что
     в нее может быть записано, то можете использовать программу pokes
     из  библиотеки  Турбо  Си  для формирования изображения на экране
     дисплея.  Ниже приводится  листинг  5.1  маленькой  программы под
     названием vidpoke.c,  которая записывает строку непосредственно в
     видеопамять.   Исходя  из  предположения,  что  на  вашей  машине
     работает контроллер CGA,  программа формирует для каждого символа
     байт атрибута со значением 7, что соответствут отображению строки
     в  виде  белых   символов   на черном фоне.   Если вы используете
     Монохромный Адаптер,  измените в строке # define VSEG значение  с
     0xB800  на 0xB000.

             Листинг 5.1: vidpoke.c

     /* vidpoke.c */

     #define VSEG 0x6800
     char vdata [] =  "Что сделал Кан?";
     main()
     {
     char *vp;
     int v;
     for (v=0, vp = vdata; *vp; v +=2, vp++)
          poke ( VSEG, v, 0x700| *vp);
     }


                                                                       38

             "Снег" и обратный ход луча развертки
     -----------------------------------------------------------------

          Если вы   запустите   программу   vidpoke.exe  в  цикле  или
     значительно увеличите длину выводимой строки,  то сможете увидеть
     на   экране   так   называемый  "снег",  который  появляется  при
     выполнении программы.  Вы будете наблюдать "снег" только в случае
     использования контроллера CGA или его аналога.  Контроллеры ЕGA и
     МА не дают подобного  эффекта.  Из  нижеследующих  объяснений  вы
     узнаете,  почему  возникает  "снег"  и  как  его  можно устранить
     программнми средствами.

          "Снег" возникает при  использовании  контроллера  CGA  из-за
     особенностей  аппаратной  архитектуры  видеосистемы.  Поскольку и
     микропроцессор, и видеоконтроллер обращаются к одной видеопамяти,
     то  в  случае  одновременного обращения возникает необходимость в
     координировании   доступа   к   памяти.  Работа  видеоконтроллера
     синхронизирована по времени с работой схемы  развертки.  Во время
     формирования элемента  изображения   на   экране  видеоконтроллер
     должен  иметь  доступ  к  ячейке  памяти,  которая  содержит бит,
     соответствующий этому элементу  изображения.   Видеопроцессор при
     этом  не  может  ждать,  поскольку  он  жестко  синхронизирован с
     устройством    формирования    растра.     Следовательно,    если
     видеоконтроллер   и    микропроцессор     пытаются   одновременно
     обратиться  к одной и той же  ячейке  памяти,  то видеоконтроллер
     должен  иметь   при   этом   более  высокий приоритет.  В  хорошо
     разработанной системе микропроцессор будет находиться в состоянии
     ожидания,  при котором запросы микропроцессора  к  видеопамяти не
     поступают.   В контроллерах МА и EGA использован этот  принцип, и
     вы  можете  не  беспокоиться  о   конфликтных   ситуациях   между
     микропроцессором и видеоконтроллером при  доступе  к видеопамяти.
     Но в контроллере CGA в символьном режиме   этого  не выполняется,
     поэтому вы должны сами предпринимать некоторые действия.

          В случае использования контроллера CGA, если микропроцессору
     нужно обратиться к видеопамяти для чтения или записи,  то это ему
     разрешается,  а видеоконтроллеру доступ на это время запрещается.
     А поскольку работа видеоконтроллера жестко привязана по времени к
     формированию горизонтальной и вертикальной  разверток  на  экране
     ЭЛТ,  то вместо извлеченных из видеопамяти данных видеоконтроллер
     при формировании изображения в это  время  вынужден  использовать
     случайные  данные.   Поэтому,   когда  ваша   программа  изменяет
     содержимое   памяти,   на  экране  случайным   образом  возникают
     мерцающие светлые пятна, называемые "снегом".

          К счастью,  контроллер  CGA  позволяет  избавиться  от этого
     раздражающего мерцания.  При формировании изображения  на  экране
     ЭЛТ  электронная  пушка бомбардирует электронами пятна фосфора на
     поверхности  экрана.   Если  энергия электронов  будет достаточно
     высока,   то   пятна фосфора будут светиться,  в противном случае
     они будут темными.   Изображение на экране ЭЛТ формируется в виде
     последовательности  горизонтальных  линий,  называемых растровыми
     линиями.  Контроллер CGA  формирует  200  таких  линий. Развертка
     осуществляется электронным лучом  слева  направо  и  сверху вниз.
     (На самом деле используются три электронных пушки,   по одной для
     каждого из основных цветов:  красного,  зеленого и голубого). При
     достижении   конца   растровой   линии   электронный  луч  должен
     переместиться к   левому  краю экрана и на  одну  линию вниз. Это
     перемещение называется горизонтальным обратным  ходом луча. После
     формирования  самой нижней   растровой   линии   электронный  луч
     должен вернуться к  самой  верхней  растровой  линии  экрана. Это
     перемещение называется вертикальным обратным ходом луча. Во время
     этих двух перемещений энергия  электронного луча низкая,  и он не

                                                                       39

     подсвечивает  растровые   точки.    В  это  время  не  происходит
     отображения   символов   на   экране,    и   видеоконтроллер   не
     осуществляет   чтения   из    видеопамяти.    Следовательно,    в
     промежутки   времени,   соответствующие   обратному   ходу  луча,
     микропроцессор имеет беспрепятственный доступ к видеопамяти.

          Контроллер CGA имеет аппаратный регистр, содержимое которого
     указывает  на  состояние  схем  обратного  хода  луча.   Проверяя
     содержимое этого регистра,  программа может осуществлять доступ к
     видеопамяти    только   в  промежутки  времени,   соответствующие
     обратному  ходу  луча,   что   позволяет  избежать  возникновения
     "снега".    Проверка   содержимого    этого    регистра    должна
     осуществляться  за достаточно короткий  промежуток времени.  Если
     вы  попытаетесь осуществить   ее  из программы  на языке высокого
     уровня (например,  Си), то она работать не будет, поскольку время
     на проверку превысит в этом случае  время обратного хода  луча. И
     от "снега" вы не избавитесь.

          Проблема может   быть   решена   только   с   помощью  языка
     ассемблера.  Написанная  на  языке  ассемблера  программа   может
     дожидаться   периода   обратного   хода  луча,  продолжительность
     которого достоточна для чтения или записи символа в  память. Язык
     ассемблера  позволяет создать программу,  которая будет выполнять
     эти  действия  достаточно  быстро,  чтобы   соответствовать   тем
     ограничениям по времени, которые накладываются видеосистемой.

          Запомните, что   контроллеры   МА   и   EGA   избавляют   от
     необходимости использования такого рода  ассемблерной  программы.
     Операции  чтения  символов  из видеопамяти и записи в видеопамять
     будут выполняться быстрее при использовании этих контроллеров. Но
     эта ассемблерная программа является необходимой при использовании
     контроллера CGA в символьном режиме (если,  конечно, вы не имеете
     желания наблюдать "снег" на экране).

          Вам необходимо   знать,   что   некоторые   так   называемые
     "совместимые видеоконтроллеры" являются недостаточно эффективными
     для  IBM  РС  вследствие проблемы с сигналом обратного хода луча.
     Тактовая  частота  4,77  МГц  процессора  8088  является  слишком
     низкой,  и продолжительность сигнала,  соответствующего состоянию
     обратного хода луча, является слишком короткой. При использовании
     этого  сигнала  в программах на ассемблере уничтожить весь "снег"
     на экране не удается.  Поэтому такие видеоконтроллеры применяются
     обычно  в  ПЭВМ  с  более  высокой  тактовой частотой процессора,
     таких,  как IBM AT,  или использующих акселератор  для  ускорения
     выполнения машинных команд.

          Ниже приводится  описание  двух  функций из исходного модуля
     ibmpc.c,  полная информация о котором содержится в разделе 4. Эти
     функции  написаны  на языке  Си,   но включают фрагменты на языке
     ассемблера,   что  допускается компилятором  Турбо  Си.  Для того
     чтобы  использовать  эти функции,  необходимо  иметь транслятор с
     языка  ассемблера MASM.   Эти функции работают корректно  с любым
     видеоконтроллером   и   уничтожают "снег"  в случае использования
     контроллера CGA.

          Вам нет  необходимости  вызывать  эти   функции   из   своих
     программ,  они  используются программами для работы с "окнами" из
     этого раздела.  Вы  можете  однако  захотеть  модифицировать  эти
     функции, если используете контроллеры МА и EGA или если у вас нет
     программы МАSM.  Если вы пишете программы и при этом  неизвестно,
     кто  и на какой аппаратной конфигурации будет их использовать, то
     должны  оставить  эти  функции  без  изменений   и   использовать
     трансляторы Турбо Си и MASM для их трансляции.

                                                                       40

             vpoke(unsigned vseg, unsigned adr, unsigned chr)
             ------------------------------------------------

          Эта функция  заносит  байт  с  кодом  символа  и  байт с его
     атрибутами  в  видеопамять.  Параметр  adr   представляет   собой
     смещение в байтах от начала сегмента видеопамяти: 0 соответствует
     первому символу,  2 - второму и т.д.  Параметр chr содержит  байт
     атрибутов  символа  (старший) и ASCII-код символа.  Параметр vseg
     определяет адрес сегмента видеопамяти (0xB800 для CGA, 0xB000 для
     МА).  Эта  функция  осуществляет  вывод  символа  с  проверкой на
     обратный ход луча, там, где это необходимо.


             int vpeak(unsigned vseg,unsigned adr)
             -------------------------------------

          Эта функция возвращает код символа и его  атрибуты  (старший
     байт),   размещенные в видеопамяти по  адресу  vseg:adr,  то есть
     выполняют  чтение символа с  проверкой на обратный ход  луча, где
     это необходимо.



             Заключение
     -----------------------------------------------------------------

          Изложенные сведения об архитектуре  видеосистемы  IBM  PC  и
     основных  принципах  работы с экранными "окнами" позволяют понять
     представленные в разделе 6  исходные  тексты  библиотеки  функций
     управления   "окнами",  удовлетворяющие  требованиям  компилятора
     Турбо   Си.   Использование    этих    функций    облегчит    вам
     программирование видеоизображений.  Вы можете смело применять эти
     функции,  и сконцентрировать свое внимание на проблемах,  которые
     специфичны для вашей прикладной задачи.






























                                                                       41