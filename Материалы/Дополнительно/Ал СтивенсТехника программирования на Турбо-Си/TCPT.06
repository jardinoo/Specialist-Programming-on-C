
                                 Глава 6
                                 -------

                       Библиотека оконных функций
     -----------------------------------------------------------------

          Программы, описанные в этой и нескольких последующих главах,
     представляют  библиотеку  оконных  функций,  которая поддерживает
     широкий диапазон экранных оконных операций.  Функции подразделены
     на подсистемы, использование которых позволяет организовать меню,
     контекстно-управляемые    подсказки,   редактирование   текста  и
     форматирование  данных  в  прикладных  системах.  Эти  подсистемы
     поддерживаются  общецелевой  оконной  библиотекой,  которая может
     использоваться в прикладных программах так же,  как и подсистемы.
     В этой главе описывается общецелевая библиотека оконных функций.

          Оконные функции, описанные в данной главе, могут применяться
     для организации окон  в одной из  двух  конфигураций:  стековой и
     слоеной;  одна конфигурация является с  точки зрения использующей
     их программы подмножеством другой. Слоеные окна обладают большими
     возможностями, чем стековые, однако стековые более эффективны, то
     есть  выдача  на  экран  и  уничтожение  их  происходит  быстрее.
     Программа может быть связана либо со стековыми,  либо со слоеными
     оконными функциями, но не с теми и другими одновременно.

          При  компиляции оконных функций, вы должны принять решение о
     том,  какую именно оконную конфигурацию применить.   Для стековых
     окон определяется переменная времени  компиляции FASTWINDOWS, для
     слоеных  окон  она  удаляется.  Прикладная  программа  может быть
     связана с любой библиотекой до  тех пор,  пока  она не использует
     возможности,   поддерживаемые  только   для   слоеных   окон.  Те
     прикладные    программы,    которые    используют     возможности
     исключительно  слоеных  окон,  должны  быть связаны с библиотекой
     оконных  функций,  которая  была  компилирована  без  определения
     FASTWINDOWS.


               Стековые окна
     -----------------------------------------------------------------

          Конфигурация стековых    окон    предполагает,   что   любая
     выполняемая  вами  с  окном  операция  (запись  в  него   текста,
     изменение цвета, уничтожение его и т.д.) производится, когда окно
     является  полностью  видимым   пользователю.   Полная   видимость
     означает,  что  ни  одна часть окна не накрыта другим окном и что
     окно не скрыто функцией  hide_window  (о  которой  будет  сказано
     ниже).  Когда  установлено  стековое  окно,  оконное  программное
     обеспечение  строит  буфер  для  хранения  прежнего   содержимого
     видеопамяти, которую будет занимать окно. Видеопамять сохраняется
     в буфере, а окно записывается в видеопамять. При выполнении любых
     операций,   модифицирующих   окно,   все   изменения  выполняются
     непосредственно  в   видеопамяти,   а   программное   обеспечение
     предполагает,  что  окно  является полностью видимым.  Когда окно
     уничтожается,  содержимое  хранящего  его   буфера   записывается
     обратно  в  видеопамять,  восстанавливая таким образом видеообраз
     памяти к состоянию до образования окна.

          Вы   будете  обычно  обращаться   только  к  стековому окну,
     образованному последним.  Если вы сначала создали окно А, а затем
     окно В,  которое закрывает часть окна А,  то при  записи текста в
     окно А может случиться,  что часть текста попадет в часть окна В,
     закрывающую  окно  А.  Далее,  если  вы   уничтожите  окно  A  до
     уничтожения  окна  В,   то   часть   буфера   сохранения  окна  А
     запишется в начало части окна В.
                                                                       42

          Большинство коммерческих оконных пакетов поддерживает только
     стековые  окна,  поскольку  большинство  приложений, использующих
     окна,  могут  успешно  функционировать  в  среде  стековых  окон.
     Обычной  практикой  в  приложениях  является  использование окна,
     открытого  последним,  и уничтожение окон в  порядке, обратном их
     созданию.  Такие  приложения  должны  использовать  стековые окна
     из-за преимуществ их функционирования.

          Оконные операции,  описанные  в данной  книге, позволяют вам
     создавать одно или более окон и затем относить различные операции
     к  одному из созданных окон.  Вы можете  обращаться к конкретному
     окну или использовать пустую спецификацию для сообщения вызванной
     функции  о своем намерении выполнить операцию  в  окне, созданном
     последним.  Это соглашение используется  как для стековых,  так и
     для  слоеных окон,  однако пользователи  стековых оконных функций
     должны быть уверены,  что любое окно,  к которому они обращаются,
     либо создано последним, либо полностью видимо на экране.


                   Слоеные окна
     -----------------------------------------------------------------

          Слоеные окна   обладают   гораздо   большей  гибкостью,  чем
     стековые, к тому же они предоставляют пользователю гораздо больше
     возможностей  по  созданию  различных оконных интерфейсов.  Когда
     слоеное  окно  создано,  любая  оконная   операция   может   быть
     адресована ему, независимо от его видимости или близости к другим
     окнам.  В дополнение к обычному набору оконных  операций  слоеные
     окна  могут  перемещаться  в  двумерной  плоскости экрана и могут
     выдвигаться на передний или убираться на  задний  планы  в  слоях
     созданных окон.

          Когда создано слоеное окно,  распределяется буфер сохранения
     видеосодержимого,  но  окно  не  отображается.  Буфер  сохранения
     инициализируется   видеозначениями,   которые   окно   могло   бы
     содержать,  если бы оно было видимым. Любые последующие операции,
     производимые  в этом  окне,  пока  оно  невидимо,  производятся в
     буфере сохранения.

          Когда слоеное  окно  отображается,   видеопамять   и   буфер
     сохранения обмениваются содержимым.  Затем,  до тех пор пока окно
     является полностью видимым (не закрытым  полностью  или  частично
     другим окном), любые операции производятся с видеопамятью, а не с
     буфером сохранения.  Когда одно и  более  других  окон  покрывают
     адресуемое  окно  полностью  или  частично,  определение  области
     изменения является более сложным.  Для тех частей  окна,  которые
     являются видимыми,  изменение производится в видеопамяти.  Однако
     для областей,  закрытых другими окнами,  изменение производится в
     буфере  сохранения покрывающего окна.  Поскольку окно может иметь
     различные части, закрытые несколькими другими окнами, то алгоритм
     определения  места,  где  должно  быть сделано изменение,  обязан
     сначала просмотреть все окна,  созданные позже данного,  с  целью
     установления  факта  выполнения  изменения  в  области,  покрытой
     следующим окном последовательности.  Если такое окно найдено,  то
     изменение записывается в его буфер сохранения.  Если ни одно окно
     не закрывает модифицируемый участок,  то изменение производится в
     видеопамяти.

          Рассмотрим рисунок 6.1.  Три окна расположены так, что часть
     окна А видима, часть закрыта окном В и часть - окном С. В буферах
     сохранения каждого окна  вы можете видеть   границы частей других
     окон, которые закрыты.


                                                                       43

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │                                   .┌───────────┐              │
     │                                .   │           │              │
     │                             .      ├───────────┤ Буфер        │
     │                          .         │           │ сохранения В │
     │                       .            │           │              │
     │                    .               │           │              │
     │                 .                  └───────────┘              │
     │             .                                  .              │
     │         .                                                     │
     │      .                                    .                   │
     │      ┌──────────┐                                             │
     │ ┌────┤ B        ├────┐               .                        │
     │ │ A  │          │    │           .                            │
     │ │    │     ┌────┴────┴───┐.   .                               │
     │ │    │     │ C           │.        .                          │
     │ │    └─────│             │               .                    │
     │ └──────────│             │                       .            │
     │            │             │                              .     │
     │            │             │        ┌──────┬──────────┬───┐     │
     │            └─────────────┘        │      │          │   │     │
     │                 .                 │      │          │   │     │
     │                     .             │      │          │   │     │
     │                         .         ├──────┘          │   │     │
     │                              .    ├─────────────────┘   │     │
     │                                 . └─────────────────────┘     │
     │                                      Буфер сохранения С       │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

             Рисунок 6.1. Три слоеных перекрывающихся окна.


          Если вы запишите текстовую строку "now is the time"  в  окно
     А, текст будет направлен в три различных места. Результат показан
     на рисунке 6.2.  Так  как  часть  окна  А,  где  записано  "now",
     является   видимой,   то  слово  записывается  непосредственно  в
     видеопамять и может быть прочитано пользователем.  Слова "is the"
     являются  частью  окна  А,  которая закрыта окном В,  поэтому эти
     слова записываются  в  буфер  сохранения  окна  В.  Слово  "time"
     оказывается  в  той  части  окна  А,  которая  покрыта  окном  С,
     следовательно "time" записывается в буфер сохранения окна С.





















                                                                       44

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │                                                               │
     │                                                               │
     │                                                               │
     │                              . ┌─────────┐                    │
     │                        .       ├─────────┤                    │
     │                 .              │ is the  │ Буфер сохранения В │
     │          .                     │         │                    │
     │         ┌───────┐              └─────────┘                    │
     │ ┌───────┤ B     ├──────┐             .                        │
     │ │ A     │    ┌──┴──────┴─┐.    .                              │
     │ │   now │    │ C         │.              .                    │
     │ │       └────┤           │                            .       │
     │ └────────────┤           │           ┌─────┬────────┬──┐      │
     │              └───────────┘           │     │   time │  │      │
     │               .                      ├─────┘        │  │      │
     │                      .               ├──────────────┘  │      │
     │                                 .    └─────────────────┘      │
     │                                       Буфер сохранения С      │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

                 Рисунок 6.2. Слоеные окна с текстом.


          Рисунок 6.3. показывает, что происходит при уничтожении окна
     В.    Часть   окна  А  из  его  буфера   сохранения  поступает  в
     видеопамять,   и   слово   "is"   может  теперь   быть  прочитано
     пользователем.  Однако, поскольку часть окна В была покрыта окном
     С,   то  часть  буфера  сохранения  окна  В  копируется  в  буфер
     сохранения окна С, следовательно,  буфер сохранения окна С теперь
     содержит слова "the time".

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │                                                               │
     │                                                               │
     │                                                               │
     │ ┌──────────────────────┐                                      │
     │ │  A         ┌─────────┴──────┐ .                             │
     │ │            │  C             │        .                      │
     │ │    now is  │                │                 .             │
     │ │            │                │                          .    │
     │ └────────────┤                │      ┌───────────────────┬──┐ │
     │              └────────────────┘      │  the time         │  │ │
     │               .                      │                   │  │ │
     │                     .                │                   │  │ │
     │                            .         ├───────────────────┘  │ │
     │                                    . └──────────────────────┘ │
     │                                         Буфер сохранения С    │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

               Рисунок 6.3. Уничтожение слоеного окна.


          Независимо от  использования  стековых  или  слоеных   окон,
     работа  их  будет  зависеть  от требований вашей системы.  Каждый
     подход имеет свои преимущества и недостатки.  Если вы  начали  со
     стековых  окон  и обнаружили позже,  что вам нужны дополнительные
     свойства  слоеной  оконной  архитектуры,  вы   можете   выполнить
     изменение  путем  перекомпиляции  оконных функций без определения
     FASTWINDOWS и перередактировать связи ваших программ.
                                                                       45

                    Оконные функции
     -----------------------------------------------------------------

          Эти функции   включены  в  оконную  библиотеку.  Для  каждой
     функции  описаны  ее  назначение  и  способ   применения.   Далее
     приводятся примеры использования этих функций.


             WINDOW *establish_window(x,y,h,w)
             ---------------------------------

          Эта функция создает окно,  но не отображает его. (Для показа
     окна воспользуйтесь функцией display_window).  Параметры  x  и  y
     являются  координатами  верхнего левого угла окна.  Эти параметры
     выражаются в символьных позициях экрана,  где  координаты  левого
     верхнего угла самого экрана равны (0,0). Параметры h и w являются
     высотой и шириной окна в  символьных  позициях.  Эта  функция  не
     вызовет  никакого  изменения  экрана.  Если  вы  создадите  окно,
     позиция и  размеры  которого  не  позволяют  ему  быть  полностью
     видимым,  программное обеспечение установит позицию,  при которой
     оно полностью поместится на экране.  Если ширина  больше  80  или
     высота  больше 25,  функция преобразует соответствующий размер до
     максимально допустимого значения.

          Окно создается  с  умалчиваемыми   атрибутами.   Его   рамка
     образуется  одинарными линиями,  цвет содержимого - ярко-белый на
     черном фоне,  а заголовок отсутствует.  Эти атрибуты  могут  быть
     изменены  соответствующими  вызовами  других  функций,  описанных
     ниже.

          Окна располагаются в  обратном  порядке  по  отношению  к их
     созданию. Окно, созданное самым последним, является верхним окном
     экрана и будет (при выдаче)  закрывать окна, созданные ранее. Эта
     иерархия зависит от порядка,  в котором окна образуются,  а не от
     порядка их показа.

          Функция establish_window   возвращает указатель на структуру
     WINDOW,  которая  определена во включаемом  файле twindow.h. Этот
     указатель используется  при последующих  вызовах  оконных функций
     для идентификации окна,  к которому относится  вызов. Передавайте
     указатель NULL  другим  оконным функциям,  если хотите работать с
     окном, образованным последним.



               void set_border(WINDOW *wnd, int btype)
               ---------------------------------------

          Эта функция устанавливает тип оконной  рамки.  Целочисленный
     параметр btype должен принимать одно из следующих значений:

     .  0 - одинарные линии (по умолчанию);
     .  1 - двойные линии;
     .  2 - одинарные верх и низ, двойные боковые;
     .  3 - двойные верх и низ, одинарные боковые;
     .  4 - специальное проталкиваемое вниз окно меню с одинарными
            линиями и t-блоком от верхнего левого до верхнего
            правого угла.






                                                                       46

     void set_colors(WINDOW *wnd, int area, int bg, int fg, int inten)
     -----------------------------------------------------------------

          Эта функция устанавливает  цвета  для  окна.  Параметр  area
     может принимать следующие значения:

     .  ALL
     .  BORDER
     .  TITLE
     .  ACCENT
     .  NORMAL

          Этот    параметр    определяет    части   окна,   на которые
     распространяется действие.  ALL соответствует всем частям. BORDER
     устанавливает  цвета рамки окна,  которая занимает односимвольный
     ряд  позиций вокруг  него.  TITLE  устанавливает цвета заголовка,
     размещаемого на  верхней  границе  окна.  ACCENT  -  это область,
     используемая   для  блоков  меню  и  другого  выделенного текста,
     который  появляется  в  качестве  временно  подсвечиваемых частей
     области NORMAL,  где отображается весь текст.  Целые  числа bg  и
     fg   задают   цвета для фона  и  переднего плана различных частей
     окна. Допускаются следующие цвета:

     .  RED      - алый;
     .  GREEN    - зеленый;
     .  BLUE     - голубой;
     .  WHITE    - белый;
     .  YELLOW   - желтый;
     .  AQUA     - аквамариновый;
     .  MAGENTA  - красный;
     .  BLACK    - черный.

          Целое число    inten   определяет   интенсивность   символов
     переднего плана и может принимать два значения:

     .  BRIGHT   - яркая
     .  DIM      - обычная

          Все значения  определены в исходном файле twindow.h, который
     рассматривается позже в этой главе.


                void set_title(WINDOW *wnd, char *title)
                ----------------------------------------

          Эта функция    устанавливает    значение   заголовка   окна.
     Передаваемая вами  строка  должна  сохраняться  в  течение  всего
     существования окна, поэтому используйте литеральную константу или
     внешний массив символов.



                void set_intensity(WINDOW *wnd, int inten)
                ------------------------------------------

          Эта функция устанавливает интенсивность фона для всех частей
     окна. Значениями inten могут быть BRIGHT или DIM.







                                                                       47


                void display_window(WINDOW *wnd)
                --------------------------------

          Эта функция  отображает  окно,  которое  было ранее создано.
     Чтобы избежать  неудачного  отображения,  вызывайте  эту  функцию
     после установки всех атрибутов и,  если возможно, после того, как
     окно заполнено текстом, который оно должно выдавать.



                 void delete_window(WINDOW *wnd)
                 -------------------------------

          Эта  функция  уничтожает  созданное  ранее  окно.  Если окно
     является  видимым  (выдано  с  помощью  display_window),  то  оно
     очищается, и экран восстанавливается к его предыдущему образу.



                 void clear_window(WINDOW *wnd)
                 ------------------------------

          Эта функция заполняет текстовую область окна пробелами.



                  void hide_window(WINDOW *wnd)
                  -----------------------------

          Эта функция очищает выданное окно,  восстанавливая на экране
     его предыдущее содержимое.  Окно остается  существующим  и  может
     модифицироваться любым способом. Последующий вызов display_window
     восстановит  его  на  экране   в   соответствующем   расположении
     относительно других окон.



                   void wcursor(WINDOW *wnd, int x, int y)
                   ---------------------------------------

          Каждое окно  обладает  логической  позицией курсора, которая
     изменяется от 0,0  (верхний левый угол текстовой области окна) до
     граничных размеров окна. Эта функция переставляет курсор в  окне.

          Функции wputehar и wprintf выдают текст относительно  данной
     позиции курсора. Они изменяют позицию  курсора точно  также,  как
     это происходило бы,  если бы управление курсором осуществлялось с
     помощью   клавиатуры   дисплея.    Символ   новой   строки   (\n)
     устанавливает   курсор  в  нулевой   столбец   следующей  строки,
     перемещая  текст в  окне  вверх на  одну строку,  если курсор уже
     находится в нижней строке окна.  Символ табуляции (\t) перемещает
     курсор   к   следующей   позиции  табуляции  в  окне.   Табуляции
     располагаются с интервалом в четыре символа.


                    void wprintf(WINDOW *wnd, char *fmt, ...)
                    -----------------------------------------

          Эта  функция  является  оконной  версией стандартной функции
     printf языка Си.  Она использует стандартную  функцию sprintf для
     построения   строки,    выдаваемой   в   окно.   Убедитесь,   что
     результирующая строка не длиннее 100 символов, или измените длину
     в массиве dlin функции wprintf в исходном файле twindow.c.
                                                                       48


                     void wputchar(WINDOW *wnd, int ch)
                     ----------------------------------

          Эта функция является оконной версией putchar. Она записывает
     символ из ch  в окно в  текущую позицию курсора.  Курсор при этом
     продвигается дальше.  Если символ является  символом новой строки
     (\n),  курсор переставляется в нулевую  позицию следующей строки.
     Если  символ  является  табуляцией  (\t),  курсор  продвигается к
     следующей  позиции  табуляции  окна.  Оконные  позиции  табуляции
     располагаются в каждой четвертой позиции окна.



                      void reverse_video(WINDOW *wnd)
                      -------------------------------

          После обращения к этой функции все вызовы wprintf и wputchar
     будут при отображении использовать цвета ACCENT вместо NORMAL.



                       void normal_video(WINDOW *wnd)
                       ------------------------------

          После обращения к этой функции все вызовы wprintf и wputchar
     будут при отображении  использовать  цвета  NORMAL.  Эта  функция
     используется  для возврата к нормальному отображению после вызова
     reverse_video.



                        void close_all()
                        ----------------

          Эта функция уничтожает все образованные окна.



                 void move_windom(WINDOW *wnd, int x, int y)
                 -------------------------------------------

          Эта функция перемещает  окно таким  образом, что его верхний
     левый угол устанавливается в символьных координатах, заданных x и
     у. Эта функция может быть использована только для слоеных окон.



                  void rmove_window(WINDOW *wnd, int x, int y)
                  --------------------------------------------

          Эта функция перемещает окно путем добавления к значениям x и
     y текущих координат левого верхнего угла  окна.  Используйте  эту
     функцию только для слоеных окон.










                                                                       49


                         void forefront(WINDOW *wnd)
                         ---------------------------

          Эта  функция  перемещает  окно  в  самое  переднее положение
     относительно других  окон.  Окно,  если  оно видимо, отображается
     поверх остальных.  Используйте  эту  функцию  только  для слоеных
     окон.



                         void rear_window(WINDOW *wnd)
                         -----------------------------

          Эта функция  перемещает  окно  в  самое   заднее   положение
     относительно других окон. Окно, если оно видимо, отображается под
     всеми остальными.  Используйте эту  функцию  только  для  слоеных
     окон.



              int get_selection(WINDOW *wnd, int sel, char *keys)
              ---------------------------------------------------

          Эта функция позволяет использовать окно в  качестве меню. Вы
     должны создать окно  и записать  в него  несколько  строк текста,
     скажем,  функцией wprintf.  Вы можете использовать set_colors для
     установки  значений цветов ACCENT  в окне (по  умолчанию - черные
     буквы на белом фоне).  Затем вы  вызываете get_selection. Функция
     использует  окно  в   качестве  меню,   каждая   строка  которого
     представляет  альтернативу  выбора.  Альтернативы  подсвечиваются
     цветом  ACCENT.   Целочисленное  значение  sel  используется  для
     первоначального размещения яркого блока курсора меню на  одной из
     альтернатив.  Значение 1  соответствует первой альтернативе,  2 -
     второй и т.д.

          Пользователь может  перемещать  блок  меню  вверх   и   вниз
     клавишами управления курсором и производить выбор в меню клавишей
     <Ввод>.  Клавиша <Ключ> применяется для выхода из этого процесса.

          Cсылка keys  указывает  на  строку  значений клавиш, которые
     могут использоваться для выбора из меню.  Некоторые системы  меню
     разрешают  пользователю  применять   нажатия   клавиш   наряду  с
     перемещением  блока  курсора.  Для  выключения  этой  возможности
     передайте параметру keys ссылку NULL.

          Эта функция возвращает целочисленное значение, равное номеру
     выбранной в меню альтернативы.  Значение обычно равняется единице
     и более,  однако,  если  пользователь  нажимает  клавишу  <Ключ>,
     функция  возвращает нуль. Функция будет также возвращать значения
     FWD  или  BS,  если   пользователь  нажимает  клавиши  управления
     курсором вправо или влево. Эти значения определены в keys.h.



                     void error_message(char *s)
                     ---------------------------

          Эта функция выдает сообщение  об ошибке, указываемое ссылкой
     s,  и  включает   звуковой   сигнал.   Сообщение  отображается  в
     окне в нижнем  правом  квадранте экрана.  Сообщение  остается  на
     экране после завершения функции.


                                                                       50


                       void clear_message()
                       --------------------

          Эта функция удаляет  сообщение  об  ошибке,  если  оно  было
     выдано функцией error_message.



               Листинги оконных функций
     -----------------------------------------------------------------

          Данные листинги содержат исходные  файлы  функций  поддержки
     окна. Приводятся два  листинга:  twindow.h  и  twindow.c.  Каждый
     листинг сопровождается описанием его содержания.


                 Исходный листинг: twindow.h
                 ---------------------------

          Листинг 6.1,  twindow.h,  определяет  оконные  структуры   и
     содержит  прототипы  для  функций.  Вы должны включать их в любую
     исходную программу, которая использует оконные функции.

     Листинг 6.1: twindow.h

     /* twindow.h */
     /*  Выделите это определение из комментария для стековых окон,
     *   но не для слоеных окон.
     *
     * #define FASTWINDOWS
     *
     */
     /* window colors */

     #define RED   4
     #define GREEN 2
     #define BLUE  1
     #define WHITE (RED+GREEN+BLUE)
     #define YELLOW (RED+GREEN)
     #define AQUA (GREEN+BLUE)
     #define MAGENTA (RED+BLUE)
     #define BLACK 0
     #define BRIGHT 8
     #define DIM 0

     #define BORDER 0
     #define TITLE 1
     #define ACCENT 2
     #define NORMAL 3
     #define ALL 4

     #define TRUE 1
     #define FALSE 0
     #define ERROR -1
     #define OK 0








                                                                       51

     /* оконные управляющие структуры */
     typedef struct field {    /* описание поля ввода данных  */
         char *fmask;          /* маска поля ввода данных */
         int fprot;            /* защита поля */
         char *fbuff;          /* буфер поля */
         int ftype;            /* тип поля */
         int from;             /* строка поля */
         int fcol;             /* столбец поля */
         void (*fhelp)();      /* функция подсказки поля */
         char *fhwin;          /* функция подсказки окна */
         int flx, fly;         /* расположение подсказки окна */
         int (*fvalid)();      /* функция заполнения поля */
         struct field *fnxt;   /* следующее поле выдачи */
         struct field *fprv;   /* предыдущее поле выдачи */
     } FIELD;
     typedef struct _wnd {
         int _wv;            /* истина, если окно видимо */
         int _hd;            /* истина, если окно скрыто */
         char *_ws;         /* указывает на блок сохранения окна */
         char *_tl;         /* указывает на заголовок окна */
         int _wx;           /* nv x координата */
         int _wy;           /* nv y координата */
         int _ww;           /* ширина окна */
         int _wh;           /* высота окна */
         int _wsp;          /* указатель прокрутки */
         int _sp;           /* указатель выбора */
         int _cr;           /* позиция  х  курсора */
         int btype;         /* тип рамки */
         int wcolor[4];     /* цвета окна */
         int _pn;           /* предыдущий нормальный цвет */
         struct _wnd *_nx;  /* указывает на следующее окно */
         struct _wnd *_pv;  /* указывает на предыдущее окно */
         FIELD *_fh;        /* указывает на 1-е поле ввода данных */
         FIELD *_ft;    /* указывает на последнее поле ввода данных */
     } WINDOW;
     typedef struct w_menu {
         char *mname;
         char **mselcs;
         void (**func)();
     } MENU;
     #define SAV      (wnd->_ws)
     #define WTITLE   (wnd->_tl)
     #define COL      (wnd->_wx)
     #define ROW      (wnd->_wy)
     #define WIDTH    (wnd->_ww)
     #define HEIGHT   (wnd->_wh)
     #define SCROLL   (wnd->_wsp)
     #define SELECT   (wnd->_sp)
     #define WCURS    (wnd->_cr)
     #define WBORDER  (wnd->wcolor[BORDER])
     #define WTITLEC  (wnd->wcolor[TITLE])
     #define WACCENT  (wnd->wcolor[ACCENT])
     #define WNORMAL  (wnd->wcolor[NORMAL])
     #define PNORMAL  (wnd->_pn)
     #define BTYPE    (wnd->btype)
     #define NEXT     (wnd->_nx)
     #define PREV     (wnd->_pv)
     #define WCOLOR   (wnd->wcolor)
     #define VISIBLE  (wnd->_wv)
     #define HIDDEN   (wnd->_hd)
     #define FHEAD    (wnd->_fh)
     #define FTAIL    (wnd->_ft)
     #define NW       (wcs[wnd->btype].nw)

                                                                       52

     #define NE       (wcs[wnd->btype].ne)
     #define SE       (wcs[wnd->btype].se)
     #define SW       (wcs[wnd->btype].sw)
     #define SIDE     (wcs[wnd->btype].side)
     #define LINE     (wcs[wnd->btype].line)

     /* ПРОТОТИПЫ ФУНКЦИЙ И МАКРОСЫ */

     /* общецелевые функции и макросы */

     void clear_screen(void);
     int vmode(void);
     void cursor(int, int);
     void curr_cursor(int *, int *);
     int cursor_type(void);
     void set_cursor_type(int);
     int get_char(void);
     int scroll_lock(void);
     void vpoke(unsigned, unsigned, unsigned);
     int vpeek(unsigned, unsigned);

     /* оконные функции и макросы */
     WINDOW *establish_window(int, int, int, int);
     void set_border(WINDOW *, int);
     void set_colors(WINDOW *, int, int, int, int);
     void set_intensity(WINDOW *, int);
     void set_title(WINDOW *, char *);
     void display_window(WINDOW *);
     void delete_window(WINDOW *);
     void clear_window(WINDOW *);
     void hide_window(WINDOW *);
     void wprintf(WINDOW *, char *, ...);
     void wputchar(WINDOW *, int);
     void close_all(void);
     void wcursor(WINDOW *, int x, int y);
     void error_message(char *);
     void clear_message(void);
     int get_selection(WINDOW *, int, char *);

     #define reverse_video(wnd) wnd->wcolor[3]=wnd->wcolor[2]
     #define normal_video(wnd) wnd->wcolor[3]=wnd->_pn
     #define rmove_window(wnd,x,y) repos_wnd(wnd, x, y, 0)
     #define move_window(wnd,x,y) repos_wnd(wnd, COL-x, ROW-y, 0)
     #define forefront(wnd) repos_wnd(wnd, 0, 0, 1)
     #define rear_window(wnd) repos_wnd(wnd, 0, 0, -1)

     /* внутренние для оконных процессов */
     void accent(WINDOW *);
     void deaccent(WINDOW *);
     void scroll(WINDOW *, int);
     void repos_wnd(WINDOW *, int, int, int);
     void acline(WINDOW *, int);
     #define accent(wnd) acline(wnd, WACCENT)
     #define deaccent(wnd) acline(wnd, WNORMAL)
     #define clr(bg,fg,in) ((fg)|(bg<<4)|(in))
     #define vad(x,y) ((y)*160+(x)*2)
     #ifdef FASTWINDOWS
     #define cht(ch,at) (((ch)&255)|((at)<<8))
     #define displ(w,x,y,c,a) vpoke(VSG,vad(x+COL,y+ROW),cht(c,a))
     #define dget(w,x,y) vpeek(VSG,vad(x+COL,y+ROW))
     #define verify_wnd(w) (*(w)=listtail)!=0
     #else
     void displ(WINDOW *wnd, int x, int y, int ch, int at);
     #endif
                                                                       53

     /* функция редактора */
     void text_editor(WINDOW *, char *, unsigned);

     /* функция меню */
     void menu_select(char *name, MENU *mn);

     /* функция подсказки */
     void load_help(char *);
     void set_help(char *, int, int);

     /* функция ввода данных */
     void init_template(WINDOW *);
     FIELD *establish_field(WINDOW *, int, int, char *, char *, int);
     void clear_template(WINDOW *);
     void field_tally(WINDOW *);
     int data_entry(WINDOW *);
     void wprompt(WINDOW *, int, int, char *);
     void error_message(char *);
     void clear_notice(void);
     void field_window(FIELD *, char *, int, int);
     #define field_protect(f,s)   f->fprot=s
     #define field_help(f,h)      f->fhelp=h
     #define field_validate(f,v)  f->fvalid=v


               Описание программы: twindow.h
     -----------------------------------------------------------------

          Глобальная переменная    FASTWINDOWS    определена    внутри
     комментария  в  представленной  программе.  Включение  переменной
     рассчитано  на  применение  стековой  оконной  конфигурации.  Без
     изменений  при   компиляции   будет   принята   слоеная   оконная
     конфигурация.  Для компиляции стековой оконной системы необходимо
     выделить оператор #define из комментария.

          Структура   FIELD  используется  для определения полей ввода
     данных  внутри  области данных  в окнах.  Этот  процесс  описан в
     Главе 8.

          Структура  WINDOW  описывает окно для системы . Каждому окну
     назначается одна структура этого типа.

          Структура    MENU    используется  программным  обеспечением
     оконных меню  в Главе 10.  Должен быть  массив  структур  MENU  с
     одним элементом для каждого проталкиваемого вниз меню.

          Список   операторов    #define   используется  для  придания
     операторам  в   twindow.c  лучшей читаемости. Мнемонические имена
     соответствуют элементам   структуры    WINDOW,  указанной ссылкой
     wnd.  Все функции в   twindow.c  используют  имя  этой  ссылки по
     соглашению.

          twindow.h   содержит  прототипы  для  всех  оконных функций,
     которые будут вызываться прикладными программами.










                                                                       54

                   Исходный листинг: twindow.c.
                   ----------------------------

          Листинг  6.2  -  это   twindow.c.  Он содержит все описанные
     ранее в этой  главе  функции.  Вы  должны  откомпилировать  его и
     связывать  его  объектный  модуль  с  любой  программой,  которая
     использует окна.  Поскольку он вызывает функции из   ibmpc.c, его
     объектный  модуль  должен  быть  также  включен  в редактирование
     связей.

     Листинг 6-2: twindow.c

     /* twindow.c */
     #include <stdio.h>
     #include <ctype.h>
     #include <stdarg.h>
     #include <dos.h>
     #include <alloc.h>
     #include <stdlib.h>
     #include <string.h>
     #include "twindow.h"
     #include "keys.h"

     #define TABS 4
     #define SCRNHT 25
     #define SCRNWIDTH 80
     #define ON  1
     #define OFF 0
     #define ERROR -1

     /* локальные прототипы */
     redraw(WINDOW *wnd);
     wframe(WINDOW *wnd);
     dtitle(WINDOW *wnd);
     int *waddr(WINDOW *wnd, int x, int y);
     vswap(WINDOW *wnd);
     vsave(WINDOW *wnd);
     vrstr(WINDOW *wnd);
     add_list(WINDOW *wnd);
     beg_list(WINDOW *wnd);
     remove_list(WINDOW *wnd);
     insert_list(WINDOW *wl, WINDOW *w2);
     #ifndef FASTWINDOWS
     int dget(WINDOW *wnd, int x, int y);
     verify_wnd(WINDOW **wl);
     #endif

     /* массив наборов символов рамки */
     struct {
         int nw, ne, se, sw, side, line;
     } wcs[] = {
         {218,191,217,192,179,196},  /* одинарная линия */
         {201,187,188,200,186,205},  /* двойная линия */
         {214,183,189,211,186,196}, /* одинарный верх, двойные бока */
         {213,184,190,212,179,205}, /* двойной верх, одинарные бока */
         {194,194,217,192,179,196},  /* выталкиваемое вниз меню */
     };







                                                                       55

     /* голова и хвост связанного списка оконных структур */
     WINDOW *listhead = NULL;
     WINDOW *listtail = NULL;
     int VSG;    /*  адрес видеосегмента  */

     /* создание нового окна */
     WINDOW *establish_window(x, y, h, w)
     {
         WINDOW *wnd;
         VSG = (vmode() == 7 ? 0xb000 : 0xb800);
         if ((wnd = (WINDOW *) malloc(sizeof (WINDOW))) == NULL)
             return NULL;
     /* параметры ограничений */
     WTITLE = "";
     HEIGHT = min(h, SCRNHT);
     WIDTH = min(w, SCRNWIDTH);
     COL = max(0, min(x, SCRNWIDTH-WIDTH));
     ROW = max(0, min(y, SCRNHT-HEIGHT));
     WCURS = 0;
     SCROLL = 0;
     SELECT = 1;
     BTYPE = 0;
     VISIBLE = HIDDEN = 0;
     PREV = NEXT = NULL;
     FHEAD = FTAIL = NULL;
     WBORDER=WNORMAL=PNORMAL=WTITLEC =
                 clr(BLACK, WHITE, BRIGHT);
     WACCENT = clr(WHITE, BLACK, DIM);
         if ((SAV = malloc(WIDTH * HEIGHT * 2)) == (char *) 0)
             return NULL;
         add_list(wnd);
     #ifndef FASTWINDOWS
         clear_window(wnd);
         wframe(wnd);
     #endif
         return wnd;
     }

     /* установить рамку окна */
     void set_border(WINDOW *wnd, int btype)
     {
         if (verify_wnd(&wnd))   {
             BTYPE = btype;
             redraw(wnd);
         }
     }

     /* установить цвета */
     void set_colors(WINDOW *wnd,int area, int bg, int fg, int inten)
     {
         if (vmode() == 7)   {
             if (bg != WHITE && bg != BLACK)
                 return;
             if (fg != WHITE && fg != BLACK)
                 return;
         }
         if (verify_wnd(&wnd))   {
             if (area == ALL)
                 while (area)
                     WCOLOR [--area] = clr(bg, fg, inten);
             else
                 WCOLOR [area] = clr(bg, fg, inten);
             redraw(wnd);

                                                                       56

         }
     }

     /* установить яркость окна */
     void set_intensity(WINDOW *wnd, int inten)
     {
         int area = ALL;

         if (verify_wnd(&wnd))    {
             while (area)    {
                 WCOLOR [--area] &= ~BRIGHT;
                 WCOLOR [area] |= inten;
            }
            redraw(wnd);
         }
     }

     /* установить заголовок */
     void set_title(WINDOW *wnd, char *title)
     {
         if (verify_wnd(&wnd))   {
             WTITLE = title;
             redraw(wnd);
         }
     }

     /* перевыдать окно при изменении атрибута */
     static redraw(WINDOW *wnd)
     {
     #ifndef FASTWINDOWS
         int x, y, chat, atr;

          for (y = 1; y < HEIGHT-1; y++)
             for (x = 1; x < WIDTH-1; x++)       {
                 chat = dget(wnd, x, y);
                 atr = (((chat>>8)&255) ==
                     PNORMAL ? WNORMAL : WACCENT);
                 displ(wnd, x, y, chat&255, atr);
             }
         wframe(wnd);
     #endif
         PNORMAL = WNORMAL;
     }

     /* выдать созданное окно */
     void display_window(WINDOW *wnd)
     {
         if (verify_wnd(&wnd) && !VISIBLE)    {
             VISIBLE = 1;
     #ifdef FASTWINDOWS
             if (HIDDEN)  {
                 HIDDEN = 0;
                 vrstr(wnd);
            }
            else     {
                 vsave(wnd);
                 clear_window(wnd);
                 wframe(wnd);
            }
     #else
            vswap(wnd);
     #endif
         }
     }
                                                                       57

     /* закрыть все окна */
     void close_all()
     {
         WINDOW *sav, *wnd = listtail;

         while (wnd) {
             sav = PREV;
             delete_window(wnd);
             wnd = sav;
         }
     }

     /* удалить окно */
     void delete_window(WINDOW *wnd)
     {
         if (verify_wnd(&wnd))       {
             hide_window(wnd);
             free(SAV);
             remove_list(wnd);   /* удалить окно из списка */
             free(wnd);
         }
     }

     /* скрыть окно */
     void hide_window(WINDOW *wnd)
     {
         if (verify_wnd(&wnd) && VISIBLE)      {
     #ifndef FASTWINDOWS
             vswap(wnd);
     #else
             vrstr(wnd);
     #endif
             HIDDEN = 1;
             VISIBLE = 0;
         }
     }

     #ifndef FASTWINDOWS
     /* перемещение окна в его  3-х мерном плане */
     void repos_wnd(WINDOW *wnd, int x, int y, int z)
     {
         WINDOW *twnd;
         int x1, y1, chat;
         if (!verify_wnd(&wnd))
             return;
         twnd = establish_window(x+COL, y+ROW, HEIGHT, WIDTH);
         twnd -> _tl = WTITLE;
         twnd -> btype = BTYPE;
         twnd -> wcolor[BORDER] = WBORDER;
         twnd -> wcolor[TITLE] = WTITLEC;
         twnd -> wcolor[ACCENT] = WACCENT;
         twnd -> wcolor[NORMAL] = WNORMAL;
         twnd -> _wsp = SCROLL;
         twnd -> _cr = WCURS;










                                                                       58

         if (z != 1) {
             remove_list(twnd);
             if (z == 0)
                 insert_list(twnd, wnd);
             else
                 beg_list(twnd);
          }
          for (y1 = 0; y1 < twnd->_wh; y1++)
              for (x1 = 0; x1 < twnd->_ww; x1++)   {
                  chat = dget(wnd, x1, y1);
                  displ(twnd, x1, y1, chat&255, (chat>>8)&255);
              }
          twnd->_wv = 1;
          vswap(twnd);
          hide_window(wnd);
          free(SAV);
          remove_list(wnd);
          *wnd = *twnd;
          insert_list(wnd, twnd);
          remove_list(twnd);
          free(twnd);
     }
     #endif

     /* очистить область окна */
     void clear_window(WINDOW *wnd)
     {
        register int x1, y1;

        if (verify_wnd(&wnd))
            for (y1 = 1; y1 < HEIGHT-1; y1++)
                for (x1 = 1; x1 < WIDTH-1; x1++)
                    displ(wnd,x1, y1, ' ', WNORMAL);
     }

     /* изобразить окно */
     static wframe(WINDOW *wnd)
     {
         register int x1, y1;

         if (!verify_wnd(&wnd))
             return;
     /* заголовок окна */
     displ(wnd,0, 0, NW, WBORDER);
     dtitle(wnd);
     displ(wnd,WIDTH-1, 0, NE, WBORDER);
     /* боковые стороны окна */
     for (y1 = 1; y1 < HEIGHT-1; y1++)        {
         displ(wnd,0, y1, SIDE, WBORDER);
         displ(wnd,WIDTH-1, y1, SIDE, WBORDER);
     }
     /* низ окна */
     displ(wnd,0, y1, SW, WBORDER);
     for (x1 = 1; x1 < WIDTH-1; x1++)
         displ(wnd,x1, y1, LINE, WBORDER);
     displ(wnd,x1, y1, SE, WBORDER);
     }







                                                                       59

     /* выдать заголовок окна */
     static dtitle(WINDOW *wnd)
     {
         int x1 = 1, i, ln;
         char *s = WTITLE;

         if (!verify_wnd(&wnd))
             return;
         if (s)  {
             ln = strlen(s);
             if (ln > WIDTH-2)
                 i = 0;
             else
                 i = ((WIDTH-2-ln) / 2);
             if (i > 0)
                 while (i--)
                     displ(wnd, x1++, 0, LINE, WBORDER);
             while (*s && x1 < WIDTH-1)
                 displ(wnd, x1++, 0, *s++, WTITLEC);
         }
         while (x1 < WIDTH-1)
             displ(wnd, x1++, 0, LINE, WBORDER);
     }

     /* оконно-ориентированная printf */
     void wprintf(WINDOW *wnd, char *ln, ...)
     {
         char dlin [100], *dl = dlin;

         if (verify_wnd(&wnd))        {
             va_list ap;
             va_start(ap, ln);
             vsprintf(dlin, ln, ap);
             va_end(ap);
             while (*dl)
                 wputchar(wnd, *dl++);
         }
     }

     /* записать символ в окно */
     void wputchar(WINDOW *wnd, int c)
     {
        if (!verify_wnd(&wnd))
            return;
        switch (c)  {
            case '\n':
                if (SCROLL == HEIGHT-3)
                    scroll(wnd, UP);
                else
                    SCROLL++;
                WCURS = 0;
                break;
            case '\t':
                do displ(wnd,(WCURS++)+3,SCROLL+1,'',WNORMAL);
                    while ((WCURS%TABS) && (WCURS+1) < WIDTH-1);
                break;
            default: ;
                if ((WCURS+1) < WIDTH-1)    {
                    displ(wnd, WCURS+1, SCROLL+1, c, WNORMAL);
                    WCURS++;
                }
                break;
          }
     }
                                                                       60

     /* установить курсор окна */
     void wcursor(WINDOW *wnd, int x, int y)
     {
         if (verify_wnd(&wnd) && x < WIDTH-1 && y < HEIGHT-1)   {
             WCURS = x;
             SCROLL = y;
             cursor(COL+x+1, ROW+y+1);
         }
     }

     /* позволяет пользователю произвести оконный выбор */
     int get_selections(WINDOW *wnd, int s, char *keys)
     {
         int c = 0, ky;
         if (!verify_wnd(&wnd))
             return 0;
         SELECT = s;
         while (c != ESC && c != '\r' && c != BS && c != FWD)    {
             accent(wnd);
             c = get_char();
             deaccent(wnd);
             switch (c)      {
                 case UP:    if (SELECT > 1)
                                 SELECT--;
                             else
                                 SELECT = SCROLL+1;
                                     break;
                 case DN:    if (SELECT < SCROLL+1)
                                 SELECT++;
                             else
                                 SELECT = 1;
                             break;
                 case '\r':
                 case ESC:
                 case FWD:
                 case BS:    break;
                 default:    if (keys)    {
                                 ky = 0;
                                 while (*(keys + ky))     {
                                     if (*(keys+ky)==toupper(c) ||
                                         *(keys+ky)==tolower(c))
                                         return ky + 1;
                                     ky++;
                                 }
                              }
               break;
             }
          }
         return  c == '\r' ?  SELECT : c == ESC ? 0 : c;
     }

     union REGS rg;
     /* прокручивает содержимое окна вверх или вниз */
     void scroll(WINDOW *wnd, int dir)
     {
        int row = HEIGHT-1, col, chat;

        if (!verify_wnd(&wnd))
            return;
        if (NEXT == NULL && HEIGHT > 3 && VISIBLE)   {
            rg.h.ah = dir == UP ? 6 : 7;
            rg.h.al = 1;
            rg.h.bh = WNORMAL;
            rg.h.cl = COL + 1;
                                                                       61

            rg.h.ch = ROW + 1;
            rg.h.dl = COL + WIDTH - 2;
            rg.h.dh = ROW + HEIGHT - 2;
            int86(16, &rg, &rg);
            return;
        }
        if (dir == UP)  {
            for (row = 2; row < HEIGHT-1; row++)
                for (col = 1; col < WIDTH-1; col++)  {
                    chat = dget(wnd, col, row);
                    displ(wnd,col,row-1,chat&255,(chat>>8)&255);
                }
            for (col = 1; col < WIDTH-1; col++)
                displ(wnd, col, row-1, ' ', WNORMAL);
        }
        else    {
            for (row = HEIGHT-2; row > 1; --row)
                for (col = 1; col < WIDTH-1; col++)  {
                    chat = dget(wnd, col, row-1);
                    displ(wnd,col,row,chat&255,(chat>>8)&255);
                }
            for (col = 1; col < WIDTH-1; col++)
                displ(wnd, col, row, '', WNORMAL);
         }
     }

     #ifndef FASTWINDOWS
     /* вычисляет абрис отображаемого символа окна */

     static int *waddr(WINDOW *wnd, int x, int y)
     {
        WINDOW *nxt = NEXT;
        int *vp;

        if (!VISIBLE)
            return (int *) (SAV+y*(WIDTH*2)+x*2);
        x += COL;
        y += ROW;
        while (nxt) {
            if (nxt->_wv)
                if (x >= nxt->_wx && x <= nxt->_wx + nxt->_ww-1)
                    if (y >= nxt->_wy &&
                            y <= nxt->_wy + nxt->_wh-1) {
                        x -= nxt->_wx;
                        y -= nxt->_wy;
                        vp = (int *)
                            ((nxt->_ws) +y*(nxt->_ww*2)+x*2);
                        return vp;
                    }
            nxt = nxt->_nx;
         }
         return NULL;
     }











                                                                       62

     /* выдать символ в окно */
     void displ(WINDOW *wnd, int x, int y, int ch, int at)
     {

         int *vp;
         int vch = (ch&255)|(at<<8);

         if ((vp = waddr(wnd, x, y)) != NULL)
             *vp = vch;
         else
             vpoke(VSG,vad(x+COL,y+ROW),vch);
     }

     /* получить отображенный символ из окна */
     static int dget(WINDOW *wnd, int x, int y)
     {
         int *vp;

         if ((vp = waddr(wnd, x, y)) != NULL)
             return *vp;
         return vpeek(VSG,vad(x+COL,y+ROW));
     }

     /* видеофункции низкого уровня */

     /* обменивает содержимое видеообраза и буфера сохранения */
     static vswap(WINDOW *wnd)
     {
         int x, y, chat;
         int *bf = (int *) SAV;

         for (y = 0; y < HEIGHT; y++)
             for (x = 0; x < WIDTH; x++)  {
                 chat = *bf;
                 *bf++ = dget(wnd, x, y);
                 displ(wnd, x, y, chat&255, (chat>>8)&255);
             }
     }

     #else

     /* сохраняет видеопамять в буфере сохранения */
     static vsave(WINDOW *wnd)
     {
         int x, y;
         int *bf = (int *) SAV;

         for (y = 0; y < HEIGHT; y++)
             for (x = 0; x < WIDTH; x++)
                 *bf++ = vpeek(VSG, vad(x+COL, y+ROW));
     }

     /* восстанавливает видеопамять из буфера сохранения */
     static vrstr(WINDOW *wnd)
     {
         int x, y;
         int *bf = (int *) SAV;

         for (y = 0; y < HEIGHT; y++)
             for (x = 0; x < WIDTH; x++)
                 vpoke(VSG,vad(x+COL, y+ROW), *bf++);
     }
     #endif

                                                                       63

     /* заменяет яркость строки, указываемой SELECT */
     void acline(WINDOW *wnd, int set)
     {
         int x, ch;

         if (!verify_wnd(&wnd))
             return;
         for (x = 1; x < WIDTH - 1; x++) {
             ch = dget(wnd, x, SELECT) & 255;
             displ(wnd, x, SELECT, ch, set);
         }
     }

     /* ФУНКЦИИ ОБРАБОТКИ СПИСКА */

     /* добавляет окно в конец списка */
     static add_list(WINDOW *wnd)
     {
         if (listtail)    {
             PREV = listtail;
             listtail->_nx = wnd;
         }
         listtail = wnd;
         if (!listhead)
             listhead = wnd;
     }

     /* добавляет окно в начало списка */
     static beg_list(WINDOW *wnd)
     {
        if (listhead)    {
            NEXT = listhead;
            listhead->_pv = wnd;
        }
        listhead = wnd;
        if (!listtail)
            listtail = wnd;
     }

     /* удаляет окно из списка */
     static remove_list(WINDOW *wnd)
     {
        if (NEXT)
            NEXT->_pv = PREV;
        if (PREV)
            PREV->_nx = NEXT;
        if (listhead == wnd)
            listhead = NEXT;
        if (listtail == wnd)
            listtail = PREV;
        NEXT = PREV = NULL;
     }












                                                                       64

     /* вставляет w 1 после  w 2 */
     static insert_list(WINDOW *w1, WINDOW *w2)
     {
        w1->_pv = w2;
        w1->_nx = w2->_nx;
        w2->_nx = w1;
        if (w1->_nx == NULL)
            listtail = w1;
        else
            w1->_nx->_pv = w1;
     }
     #ifndef FASTWINDOWS
     /* проверяет наличие окна в списке */
     static verify_wnd(WINDOW **w1)
     {
        WINDOW *wnd;

        wnd = listhead;
        if (*w1 == NULL)
            *w1 = listtail;
        else    {
            while (wnd != NULL) {
                if (*w1 == wnd)
                    break;
                wnd = NEXT;
            }
        }
        return wnd != NULL;
     }
     #endif

     WINDOW *ewnd = NULL;

     /* сообщение об ошибках */
     void error_message(char *s)
     {
         ewnd = establish_window(50, 22, 3, max(10, strlen(s)+2));
         set_colors(ewnd, ALL, RED, YELLOW, BRIGHT);
         set_title(ewnd, " ERROR! ");
         display_window(ewnd);
         wprintf(ewnd, s);
         putchar(BELL);
     }

     void clear_message()
     {
        if (ewnd)
            delete_window(ewnd);
        ewnd = NULL;
     }














                                                                       65

                 Описание программы: twindow.c
                 -----------------------------

          Далее описывается исходная  программа  twindow.c. Для каждой
     функции описывается,  что она делает и как  работает. Программист
     может использовать  эти описания для понимания текста программы.

          Объявления внешних данных в twindow.c включают прототипы для
     каждой функции,  локальные в исходном файле,  массив структур для
     определения пяти типов рамки окна, головной и хвостовой указатели
     для списка структур WINDOW.

          Рамка окна  управляется элементом  структуры WINDOW, которая
     устанавливает окно. Этот элемент является целочисленным смещением
     в  таблице типов  рамки.  Вход,  на  который  указывает смещение,
     содержит шесть значений,  каждое из которых  представляет одну из
     сторон или узлов окна. Первое значение определяет   верхний левый
     или  северо-западный  угол.  Имя  переменной  (nw,  ne,  se,  sw)
     сообщает  вам,   какой  угол  определяется.   Целое   число  side
     относится  к  вертикальным  сторонам  рамки;   целое  число  line
     соответствует  верхней  и  нижней  горизонтальным  линиям  рамки.
     Значения относятся  к  символам  из  набора  графических символов
     ПЭВМ.

          Две  WINDOW-ссылки listhead   и listtail являются головным и
     хвостовым указателями для списка окон.  Когда создаются окна, они
     добавляются к этому списку. Первоначально эти два указателя равны
     NULL.   Когда  создается  первое  окно,   выделяется  память  для
     структуры WINDOW, и ее адрес копируется в оба указателя. У списка
     имеется  голова,  указывающая  на  первое  окно  списка, и хвост,
     указывающий на последнее.  Когда создается второе окно, его адрес
     копируется в хвостовой указатель.  Кроме того, адрес второго окна
     записывается в указатель  _nx  в первой структуре WINDOW, а адрес
     первой  записывается  в  указатель   _pv  второй.  Голова  списка
     указывает на  первое  окно,  которое  указывает на  второе и т.д.
     Хвост списка  указывает  на  последнее  окно.  Каждое  окно также
     указывает на своего предшественника в цепи, следовательно, список
     является двунаправленной структурой данных, называемой двусвязным
     списком.   (Для знакомства со списковыми  структурами данных см.:
     Brady. С Development Tools for the IBM PC. - 1986.).

          Функция establish_window   инициализирует   переменную   VSG
     адресом  сегмента  видеопамяти.  Функция  распределяет память для
     структуры  WINDOW  и  инициализирует   эту   структуру   оконными
     характеристиками,  принимаемыми по умолчанию,  а также размером и
     координатами,  заданными при вызове функции.  Она выделяет память
     для  буфера  сохранения  видеопамяти  и записывает адрес буфера в
     структуру WINDOW.  После инициализации структуры функция вызывает
     add_list  для  добавления  структуры  к  списку  окон.  Текстовая
     область  окна  очищается,   и   образ   окна   выделяется,   если
     обрабатываются  слоеные  окна.  Эти  функции  оперируют  в буфере
     сохранения, поэтому окно пока не изображается. Функция establish_
     window возвращает адрес структуры WINDOW в точку вызова.

          Функции  set_border,  set_colors,  set_intensity и set_title
     модифицируют характеристики созданного окна. Сначала они вызывают
     verify_wnd  для  проверки  того,  что  при  вызове  передан адрес
     созданного окна. Затем они модифицируют заданный атрибут. В конце
     они вызывают функцию redraw для записи изменений на экран.

          Функция redraw перевыдает окно,  если обрабатываются слоеные
     окна.


                                                                       66

          Функция  display_window оперирует  по-разному для стековых и
     слоеных окон.  В  любом случае  она ничего  не  делает, если окно
     является видимым для пользователя.   Если окно невидимо, то путем
     вызова  функции  vswap    display_window   замещает   видеопамять
     буфером сохранения,  если действуют  слоеные  окна.  Для стековых
     окон делается проверка,  не скрыто ли окно.  Если окно скрыто, то
     оконный  буфер  сохранения  записывается  в  видеопамять  вызовом
     vrstr.  Если окно не скрыто, то оно никогда не выдается,  поэтому
     вызывается   vsave   для   сохранения    текущего     содержимого
     видеопамяти,    a   clear_window  и  wframe вызываются для выдачи
     пустого окна.

          Функция  close_all  уничтожает  все  окна  путем прохода  по
     списку структур WINDOW и вызова delete_window.
          Функция  delete_window  удаляет  окно  из  системы путем его
     скрытия,   освобождения   памяти,   занятой  буфером  сохранения,
     удаления  структуры  WINDOW  из  списка  и  освобождения  памяти,
     содержащей структуру WINDOW.

          Функция hide_window  вызывает  vswap   для   замены   буфера
     сохранения  видеопамятью  для  слоеного  окна  и вызова vrstr для
     восстановления видеопамяти для стекового окна.

          Функция  repos_window  имеется только  для слоеных окон. Она
     вызывается   одним   из   макросов   move_window,   rmove_window,
     rear_window  и  forefront.  Она  изменяет  положение  окна  путем
     создания  временного  окна,  помещая  временное окно  в  список в
     соответствии  с  информацией,  полученной  из  макроса, записывая
     оригинальное содержимое окна в буфер  сохранения временного окна,
     выдавая временное окно и скрывая оригинал.

          Crear_window записывает  пробелы  в  область  данных окна, а
     wframe и dtitle изображают окно с заголовком наверху. Эти функции
     используют функцию displ для записи значений в окно.

          Функция  wprintf  является  примером  нового предполагаемого
     стандарта ANSI  для функций  с  переменным  числом  параметров. В
     прошлом   большинство   компиляторов   обрабатывали   printf   на
     ассемблере для  просмотра переменного числа параметров  из стека.
     Предполагаемый  стандарт  использует  многоточие  (...)  в списке
     параметров функции для указания  присутствия    переменного числа
     параметров с различными  типами  данных.  Специальный тип массива
     va_list   используется   для   объявления   списка,   а  va_start
     устанавливает  начало  и конец списка.  Функция vsprintf является
     версией  sprintf,  которая допускает параметр  va_list.  В данном
     случае       параметры,        передаваемые       в      wprintf,
     перерабатываются vsprintf в  строку с именем dlin.   Затем строка
     выдается в окно по одному  символу за раз  путем вызова wputchar.
     Если у вас получится вызов   wprintf,   который  образует  строку
     более  100  символов, придется увеличить длину массива dlin.

          Функция wputchar  выдает  символ  в  окно  в текущей позиции
     курсора.  Расположение оконного  курсора  является  функцией двух
     элементов  структуры WINDOW,  которые указываются макросами WCURS
     (столбец)   и SCROLL  (строка).   Функция  реагирует   на символы
     новой строки (\n)  и табуляции (\t)  следующим образом. Для новой
     строки,   если   переменная  SCROLL   соответствует   низу  окна,
     содержимое   окна  проворачивается   вверх  на одну строку; иначе
     значение переменной SCROLL    увеличивается.   В   любом   случае
     переменная    WCURS  устанавливается   на   столбец  0.   Если  в
     wputchar     послан   символ    табуляции,     переменная   WCURS
     продвигается  к  следующей позиции табуляции  в  окне.  Остальные
     символы   отображаются  в  окне, а переменная  WCURS  возрастает.
     Строки,   длина   которых превышает ширину  окна, не переносятся;
                                                                       67

     они обрезаются.

          Функция wcursor устанавливает переменные  WCURS  и SCROLL на
     координаты,   заданные  при   вызове.   Она  также  устанавливает
     видеокурсор   на  экранную   позицию,   соответствующую  оконному
     курсору.

          Функция get_selection  создает  блок  курсора   в   окне   и
     позволяет  пользователю  перемещать  блок  вверх и вниз,  а также
     производить  выбор  нажатием  клавиши  <Ввод>.   Макроопределение
     SELECT  ссылается на переменную в структуре WINDOW и используется
     для перемещения блока курсора в окне.  Функции accent и  deaccent
     используются  для  включения  и  выключения  блока  курсора путем
     изменения видеоатрибута строки на ACCENT и  NORMAL.  При  нажатии
     верхней  и  нижней  клавиш со стрелками функция изменяет значение
     переменной SELECT.  При вызове можно также передать адрес массива
     символов,  содержащего список клавиш,  используемых для выбора из
     окна.  Если  пользователь   нажимает   одну   из   этих   клавиш,
     производится  соответствующий  выбор  так  же,  как  если бы блок
     курсора находился в соответствующей строке и была  нажата клавиша
     <Ввод>.

          Функция scroll проворачивает порцию текста в  окне вверх или
     вниз  на  одну  строку.  Если окно является последним  и видимым,
     функция прокрутки ROM-BIOS применяется для ускорения по сравнению
     с программной прокруткой.  Функция ROM-BIOS не  применяется, если
     окно  имеет только  одну  строку текста из-за ошибки  в IBM  PC и
     некоторых моделях  АТ.  Эта  ошибка  вызывает  появление неверных
     видеорезультатов  при  попытке  провернуть  единственную  строку.
     Ошибка была устранена IBM в АТ  BIOS,  но в некоторых моделях она
     осталась. Если окно не является последним или если оно имеет одну
     строку  текста,  текстовая  область проворачивается  программно с
     помощью функций dget и displ для чтения и записи  символов текста
     из окна и в окно.

          Функция  waddr  оперирует  только  со  слоеными  окнами. Она
     возвращает целочисленный адрес позиции  в  окне,  где расположены
     символ и атрибут. Если окно не видимо, функция возвращает адрес в
     буфере сохранения, вычисленный  по  координатам x и y.  Если окно
     видимо,  сканируется список  для поиска окон,  более поздних, чем
     адресуемое  окно.  Если  более  позднее  окно  закрывает  позицию
     адресуемого   символа,    возвращается   адрес,   соответствующий
     сохраненному адресу этого окна.  Если ни одно  более позднее окно
     не закрывает позицию  символа,  возвращается  указатель  NULL для
     сообщения в точку вызова об использовании видеопамяти.

          Функция displ и функция dget вызываются для  выдачи и приема
     видеосимвола и  атрибута  в   и  из  слоеного  окна.  Эти функции
     вызывают waddr   для проверки  необходимости чтения  или записи в
     область сохранения. Если нет, адресуется видеопамять.

          Функция  wsvap меняет  местами  содержимое буфера сохранения
     слоеного  окна  и видеопамяти или,  возможно,  буферов сохранения
     более  поздних  окон,  которые  закрывают  адресуемое  окно.  Эта
     функция использует displ и dget для выполнения изменения.

          Функции  vsave и vrstr работают  со  стековыми окнами. Vsave
     копирует  содержимое  видеопамяти  в  буфер  сохранения,  а vrstr
     копирует буфер сохранения в видеопамять.

          Функция  acline вызывается  макросами  accent и deaccent для
     изменения выбранной строки  окна на цветовую  конфигурацию ACCENT
     или NORMAL.

                                                                       68

          Функция add_list  добавляет структуру WINDOW в конец списка.

          Функция beg_list добавляет структуру WINDOW в начало списка.

          Функция remove_list удаляет структуру WINDOW из списка.

          Функция iusert_list  вставляет  структуру  WINDOW  в  список
     после другой заданной структуры WINDOW.

          Функция verify_wnd  ищет  в списке  заданный адрес структуры
     WINDOW.  Она возвращает истину или ложь в  зависимости от наличия
     или отсутствия структуры WINDOW в списке. Если заданный указатель
     WINDOW равен  NULL,  функция возвращает адрес последней структуры
     WINDOW в списке.

          Функция  error_message создает окно  для выдачи специального
     сообщения  об  ошибке.  Сообщение  записывается  в  окно  вызовом
     wprintf, и включается звуковой сигнал.

          Функция clear_message очищает последнее сообщение об ошибке.



                      Примеры окон
     -----------------------------------------------------------------

          Далее рассматриваются   возможности   оконной    библиотеки.
     Приводятся  примеры  программ,  каждая  из  которых  иллюстрирует
     рассматриваемые  возможности.  Примеры   состоят   из   небольшой
     управляющей   программы  с  главной  функцией,  которая  вызывает
     функцию примера для демонстрируемой возможности.  Функция примера
     содержит вызовы ранее рассмотренных библиотечных функций и служит
     иллюстрацией их использования.  Каждый пример программы  включает
     проектный  (.prj)  файл,  используемый  Турбо  Си  для построения
     выполняемой программы.

          Затем эти же самые примеры функций  будут  объединены в один
     выполняемый модуль,  который демонстрирует  оконные меню. Поэтому
     они написаны без собственных main-функций.


                           Перемещение  окна
                           -----------------

          При использовании  слоеных  окон   вам   доступны   функции,
     позволяющие   перемещать  окно  в  абсолютную  или  относительную
     позицию на экране. Заметим, что эти функции - move_window и rmove
     _window - недоступны для стековых окон.

          Программа, иллюстрирующая  перемещение  окна,  приведена  на
     листингах  6.3,  6.4  и  6.5.  Листинг  6.3  является   маленькой
     управляющей программой, а листинг 6.5 представляет проектный make
     -файл. Обращайтесь к листингу 6.4, testmove.c, при чтении данного
     описания.

          Для запуска примера введите следующую команду:

     c>move

          (В этом   и   последующих  примерах  предполагается,  что  С
     является вашим системным дисководом. Не вводите подсказку с>.).



                                                                       69

          Помимо иллюстрации  движения  окна,  testmove.c   показывает
     также процесс создания окон, установку их цветов, выдачу на экран
     и запись текста в них.  Программа создает три  окна,  присваивает
     каждому  из них собственные цвета,  выдает их и записывает цитату
     во второе из трех  окон.  Этот  пример  иллюстрирует  возможность
     записи  текста  в  окно,  которое  частично закрыто другим окном.
     После запуска программы вы увидите на дисплее то, что показано на
     рисунке 6.4.

     ┌──────────────────────────────────────────────────────────────┐
     │                                                              │
     │  C>                                                          │
     │                                                              │
     │              ┌──────────────────────┐                        │
     │       ┌──────│ I wouldn't care who  │                        │
     │       │      │ wrote the laws if I  │                        │
     │       │      │ could write the      │                        │
     │       │      │ b ┌─────────┐        │                        │
     │       │      │   │         │ferson  │                        │
     │       │      └───│         ├────────┘                        │
     │       │          │         │                                 │
     │       └──────────┤         │                                 │
     │                  └─────────┘                                 │
     │                                                              │
     │                                                              │
     └──────────────────────────────────────────────────────────────┘

             Рисунок 6.4. Перемещение слоеных окон.


          Теперь программа   ожидает   нажатия   клавиши.    Программа
     специально  ждет  нажатия одной из клавиш управления курсором или
     клавиши <Ключ>.  Каждое  нажатие  клавиши  со  стрелкой  вызывает
     перемещение   окна  на  одну  символьную  позицию  в  направлении
     стрелки.  Функция rmove_window используется для перемещения окна.
     Обратите внимание на то,  как центральное окно перемещается между
     двумя остальными.

          Когда вы нажимаете  клавишу  <Ключ>,  открытое  первым  окно
     уничтожается.  Еще  одно  нажатие  вызывает  уничтожение верхнего
     окна.  Заключительное нажатие уничтожает среднее окно с цитатой и
     завершает программу.

          Перемещение окна  иллюстрирует использование оконных буферов
     сохранения, запрограммированное в библиотеке. Поскольку требуется
     определенная обработка  для  анализа  каждого  буфера  при записи
     символа  в окно,  работа функций усложняется  по  мере увеличения
     размера окон и их  количества.  При перемещении большого слоеного
     окна  на  старых  медленных  моделях  ПЭВМ  это  можно  наблюдать
     визуально.














                                                                       70

     Листинг 6.3: move.c

     /* move.c */
     void testmove(void);

     main()
     {
        testmove();
     }

     Листинг 6.4: testmove.c

     /* testmove.c */
     #include "twindow.h "
     #include "keys.h"

     void testmove()
     {
        WINDOW *wndA, *wndB, *wndC;
        int c;

        wndA = establish_window(5, 5, 9, 19);
        wndB = establish_window(10, 3, 9, 23);
        wndC = establish_window(13, 8, 9, 12);
        set_colors(wndA, ALL, RED,  YELLOW, BRIGHT);
        set_colors(wndB, ALL, AQUA, YELLOW, BRIGHT);
        set_colors(wndC, ALL, WHITE, YELLOW, BRIGHT);
        display_window(wndA);
        displey_window(wndB);
        display_window(wndC);
        wprintf(wndB, "\n I wouldn't care who");
        wprintf(wndB, "\n wrote the laws if I");
        wprintf(wndB, "\n could write the");
        wprintf(wndB, "\n ballads.");
        wprintf(wndB, "\n\n    Thomas Jefferson");
        do  {
            int x = 0, y = 0;
            c = get_char();
            switch (c)  {
                case FWD:   x++;
                            break;
                case BS:    --x;
                            break;
                case UP:    --y;
                            break;
                case DN:    y++;
                default:    break;
            }
            if (x || y)
                rmove_window(wndB, x, y);
        } while (c != ESC);
          delete_window(wndA);
          get_char();
          delete_window(wndC);
          get_char();
          delete_window(wndB);
     }

     Листинг 6.5: move.prj

     move
     testmove (twindow.h, keys.h)
     twindow (twindow.h, keys.h)
     ibmpc.obj
                                                                       71

                        Подъем и опускание окон
                        -----------------------

          С помощью функций forefront и rear_window  вы можете поднять
     окно в последнюю позицию,  помещая его поверх  всех  остальных, а
     также  опустить  окно  в первую  позицию,  помещая его  под всеми
     остальными.  Эта возможность применима в программах с несколькими
     окнами,  где пользователь выбирает одно из них для некоторой цели
     путем  временного  перевода  остальных  на  фон.  Эта возможность
     полезна  в  любых  приложениях,   в  которых  пользователь  часто
     переходит от окна к окну.

          Программа, иллюстрирующая   подъемы   и   опускания    окон,
     приведена  в  листингах  6.6,  6.7  и  6.8.  Листинг 6.6 является
     маленькой управляющей программой, а листинг 6.8 - проектным make-
     файлом.  Обращайтесь к листингу 6.7, promote.c, при чтении данных
     разъяснений.

          Для запуска примера введите следующую команду:

     c>prom

          Программа promote.c использует те же образцы трех  окон, что
     и программа testmove.c. Теперь все три окна включают записанный в
     них текст,  каждый из которых содержит имя окна: window A, window
     B  и  window  C.  На  рисунке  6.5 показан первоначально выданный
     экран.

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │  C>                                                           │
     │                                                               │
     │             ┌───────────────────┐                             │
     │             │  window B         │                             │
     │       ┌─────┤                   │                             │
     │       │     │    ┌──────────┐   │                             │
     │       │ win │    │          │   │                             │
     │       │     │    │          │   │                             │
     │       │     └────┤ window C ├───┘                             │
     │       │          │          │                                 │
     │       └──────────┤          │                                 │
     │                  └──────────┘                                 │
     │                                                               │
     │                                                               │
     │                                                               │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

              Рисунок 6.5. Подъем слоеных окон.

          Для подъема  и  опускания  окон   используется   клавиатура.
     Используйте  нажатия  клавиш  с  маленькими буквами а,  b и с для
     подъема окон,  названных этими  буквами.  Используйте  клавиши  с
     большими  буквами для их опускания.  Этот процесс продолжается до
     тех пор, пока вы не нажмете клавишу <Ключ> для уничтожения одного
     из окон. Еще два нажатия вызовут уничтожение остальных двух окон,
     и программа завершится.







                                                                       72

     Листинг 6.6: prom.c

     /* prom.c */
     void promote(void);

     main()
     {
        promote();
     }

     Листинг 6.7: promote.c

     /* promote.c */
     #include "twindow.h"
     #include "keys.h"

     void promote()
     {
         WINDOW *wndA, *wndB, *wndC;
         int c;
         wndA = establish_window(5, 5, 9, 19);
         wndB = establish_window(10, 3, 9, 20);
         wndC = establish_window(13, 8, 9, 12);
         set_colors(wndA, ALL, RED, YELLOW, BRIGHT);
         set_colors(wndB, ALL, AQUA, YELLOW, BRIGHT);
         set_colors(wndC, ALL, WHITE, YELLOW, BRIGHT);
         display_window(wndA);
         display_window(wndB);
         display_window(wndC);
         wprintf(wndA, "\n\n Window A");
         wprintf(wndB, "\n\n Window B");
         wprintf(wndC, "\n\n Window C");
         do  {
             c = get_char();
             switch (c)  {
                 case 'a':   forefront(wndA);
                             break;
                 case 'b':   forefront(wndB);
                             break;
                 case 'c':   forefront(wndC);
                             break;
                 case 'A':   rear_window(wndA);
                             break;
                 case 'B':   rear_window(wndB);
                             break;
                 case 'C':   rear_window(wndC);
                             break;
                 default:    break;
         }
     } while (c != ESC);
          delete_window(wndA);
          get_char();
          delete_window(wndC);
          get_char();
          delete_window(wndB);
     }

     Листинг 6.8: prom.prj

     prom
     promote (twindow.h, keys.h)
     twindow (twindow.h, keys.h)
     ibmpc.obj

                                                                       73


           Назначение заголовков и изменение цветов окна
           ---------------------------------------------

          Когда окно  создано,  вы  можете  назначить ему заголовок, а
     также установить цвета переднего плана и фона.

          Программа, иллюстрирующая заголовки и цвета  окон, приведена
     в листингах  6.9,  6.10  и  6.11.  Листинг 6.9 является маленькой
     управляющей  программой,  а листинг 6.11 - проектным make-файлом.
     Обращайтесь  к  листингу 6.10,  ccolor.c,   при   чтении   данных
     разъяснений.

          Для запуска примера вводите следующую команду

     c>color

          Снова выдается три окна. Каждое из них имеет свой цвет (если
     у вас цветной монитор), но ни у одного из них нет заголовка. Окна
     расположены  в  тех  же  местах  и  имеют те же размеры,  что и в
     предыдущих примерах. Программа ожидает нажатия клавиши с одной из
     букв:  r, g или b. Она будет использовать эти буквы для изменения
     заголовка среднего окна на "RED",  "GREEN" или  "BLUE",  а  также
     изменит  цвет  среднего окна на соответствующий новому заголовку.
     Рисунок 6.6 показывает экран после выбора алого (red) окна.

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │   C>                                                          │
     │                                                               │
     │                                                               │
     │                                                               │
     │               ┌───────RED───────┐                             │
     │               │                 │                             │
     │          ┌────┤                 │                             │
     │          │    │                 │                             │
     │          │    │   ┌─────────┐   │                             │
     │          │    │   │         │   │                             │
     │          │    └───┤         ├───┘                             │
     │          │        │         │                                 │
     │          └────────┤         │                                 │
     │                   └─────────┘                                 │
     │                                                               │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

               Рисунок 6.6. Изменение цветов и заголовков.


          Нажмите клавишу  <Ключ>  для  выхода  и уничтожения окна,  а
     также любые две другие клавиши  для  уничтожения  двух  остальных
     окон и завершения программы.

     Листинг 6.9: color.c

     /* color.c */

     void ccolor(void);

     main()
     {
        ccolor();
     }

                                                                       74

     Листинг 6.10: сcolor.c

     /* ccolor.c */

     #include "twindow.h"
     #include "keys.h"

     void ccolor()
     {
        WINDOW *wndA, *wndB, *wndC;
        int c;

        wndA = establish_window(8, 8, 9, 19);
        wndB = establish_window(13, 6, 9, 20);
        wndC = establish_window(16, 11, 9, 12);
        set_colors(wndA, ALL, RED, YELLOW, BRIGHT);
        set_colors(wndB, ALL, AQUA, YELLOW, BRIGHT);
        set_colors(wndC, ALL, WHITE, YELLOW, BRIGHT);
        display_window(wndA);
        display_window(wndB);
        display_window(wndC);
        do  {
            c = get_char();
            switch (c)  {
                case 'r':
                    set_title(wndB, " RED ");
                    set_colors(wndB, ALL, RED, WHITE, BRIGHT);
                    break;
                case 'b':
                    set_title(wndB, " BLUE ");
                    set_colors(wndB, ALL, BLUE, WHITE, BRIGHT);
                    break;
                case 'g':
                    set_title(wndB, " GREEN ");
                    set_colors(wndB, ALL, GREEN, WHITE, BRIGHT);
                    break;
                default:
                    break;
             }
          } while (c != ESC);
          delete_window(wndA);
          get_char();
          delete_window(wndC);
          get_char();
          delete_window(wndB);
     }

     Листинг 6.11: color.prj

     color
     ccolor (twindow.h, keys.h)
     twindow (twindow.h, keys.h)
     ibmpc.obj











                                                                       75

                Сравнение стековых и слоеных окон
                ---------------------------------

          Рассматриваемая здесь  программа  дает  возможность сравнить
     представления стековых и слоеных окон.  Вы можете откомпилировать
     ее  с  оконной библиотекой,  которая была компилирована для обоих
     типов окон.

          Программа, иллюстрирующая   различия   между   стековыми   и
     слоеными окнами, показана на листингах 6.12, 6.13 и 6.14. Листинг
     6.12 является маленькой управляющей программой,  а листинг 6.14 -
     проектным make-файлом.  Обращайтесь к листингу 6.13,  fast.c, при
     чтении данных разъяснений.

          Для запуска примера введите следующую команду:

     c>fast

          Помните, что программа сама по себе не показывает сравнение.
     Вам  необходимо  построить  две  версии  ее,  одну  - со стековой
     оконной библиотекой, а вторую - со слоеной оконной библиотекой, и
     сравнить представления обеих программ.

          После запуска программы она создаст и выдаст пятнадцать окон
     в  последовательности,  показанной  на  рисунке  6.7.  Когда   вы
     нажимаете  любую  клавишу,  программа  уничтожает  каждое  окно в
     обратном порядке.  Вы можете  сравнить  соответствующие  скорости
     работы программ, компилированных в двух средах.

     ┌───────────────────────────────────────────────────────────────┐
     │ ┌──────────────┐                                              │
     │ │ ┌───────────────┐                                           │
     │ │ │ ┌───────────────┐                                         │
     │ │ │ │ ┌───────────────┐                                       │
     │ └─│ │ │ ┌───────────────┐                                     │
     │   └─│ │ │ ┌───────────────┐                                   │
     │     └─│ │ │ ┌───────────────┐                                 │
     │       └─│ │ │ ┌───────────────┐                               │
     │         └─│ │ │ ┌────────────────┐                            │
     │           └─│ │ │ ┌─────────────────┐                         │
     │             └─│ │ │ ┌──────────────────┐                      │
     │               └─│ │ │ ┌───────────────────┐                   │
     │                 └─│ │ │ ┌───────────────────┐                 │
     │                   └─│ │ │ ┌───────────────────┐               │
     │                     └─│ │ │ ┌───────────────────┐             │
     │                       └─│ │ │                   │             │
     │                         └─│ │ Hello, Dolly # 14 │             │
     │                           └─│                   │             │
     │                             └───────────────────┘             │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘

                Рисунок 6.7. Сравнение стековых и слоеных окон.


     Листинг 6.12: fast.c

     /* fast.c */
     void fasttest(void);

     main()
     {
         fasttest();
     }
                                                                       76

     Листинг 6.13: fasttest.c

     /* fasttest.c */
     #include <stdio.h>
     #include "twindow.h"

     void fasttest()
     {
        int row, col;

        for (row = 0, col = 0; col < 15; row += 3, col++)   {
            establish_window(row, col, 10, 30);
            set_colors(NULL, ALL, RED, YELLOW, BRIGHT);
            display_window(NULL);
            wprintf(NULL, "\n\n\n  Hello, Dolly # %d", col);
        }
        get_char();
        while (col--)
            delete_window(NULL);
     }

     Листинг 6.14: fast.prj

     fast
     fasttest (twindow.h)
     twindow (twindow.h, keys.h)
     ibm.obj

     Перемещение, подъем, скрытие окон, меню, изменение интенсивности
     ----------------------------------------------------------------

          В следующем  примере  комбинируется несколько уже показанных
     возможностей   и   даются   примеры   еще   двух    возможностей:
     использование   get_selection   для  обработки  простого  меню  и
     использование set_intensity для изменения яркости переднего плана
     окон.

          Программа, иллюстрирующая  эти возможности,  представлена на
     листингах 6.15,  6.16 и 6.17.  Листинг  6.15  является  маленькой
     управляющей  программой,  а листинг 6.17 - проектным make-файлом.
     Обращайтесь  к  листингу  6.16,  poems.c,   при   чтении   данных
     разъяснений.

          Для запуска примера введите следующую команду:

     c>poetry

          Эта программа выдает пять различных стихотворений на экран и
     позволяет вам выбрать одно из них, перемещать его, поднять его на
     передний   план,  опустить  его  назад  и  уничтожить.  Программа
     начинает работу с выдачи оконного меню,  которое перечисляет  все
     стихотворения.  Вы  можете  переместить  курсор  вверх или вниз и
     выбрать одно стихотворение  нажатием  клавиши  <Ввод>.  Вы  также
     можете   нажать   одну   из   цифр  от  1  до  5,  выбирая  номер
     стихотворения.   В   результате    будет    показано    выбранное
     стихотворение. На рисунке 6.8 показано меню стихотворений.








                                                                       77

     ┌───────────────────────────────────────────────────────────────┐
     │                                                               │
     │   ┌────────────────── Select A Poem────────────┐              │
     │   │                                            │              │
     │   │ 1: TELL ALL THE TRUTH BUT TELL IT SLANT    │              │
     │   │ 2: AFTER LONG SILENSE                      │              │
     │   │ 3: A MAN SAID TO THE UNIVERSE              │              │
     │   │ 4: FLYING CROOKED                          │              │
     │   │ 5: THE IDLE LIFE I LEAD                    │              │
     │   │                                            │              │
     │   └────────────────────────────────────────────┘              │
     │                                                               │
     │                                                               │
     │                                                               │
     │                                                               │
     └───────────────────────────────────────────────────────────────┘
                    Рисунок 6.8. Меню стихотворений.

          После выбора  стихотворения  вы   можете   передвинуть   его
     клавишами  со  стрелками,  возвращаясь  к  меню  нажатием клавиши
     <Ключ> или выбирая другое стихотворение  нажатием соответствующей
     цифровой  клавиши.  Выбранное  текущее  стихотворение  выдается с
     повышенной яркостью,  а  все  остальные  -  с  обычной.  Если  вы
     выбираете  стихотворение,  выданное  с  обычной яркостью,  то оно
     становится  ярким,  а  остальные   -   обычными.   Для   перевода
     стихотворения  на  передний план нажмите клавишу <Плюс> (+);  для
     посылки его на фон нажмите клавишу <Минус> (-).  Для  уничтожения
     текущего   стихотворения   нажмите   клавишу   <Удл>.  Вы  можете
     восстановить его нажатием клавиши с номером.  После этого нажмите
     клавишу <Ключ> для возврата к меню,  а затем снова клавишу <Ключ>
     для выхода из программы.
          На рисунке  6.9  показаны  стихотворения,  разбросанные   по
     экрану в различных местах.

     ┌─────────────────────────────────────────────────────────────...
     │                          ┌ 1: TELL ALL THE TRUTH BUT TELL IT...
     │  C>                      │
     │                          │ Tell all the truth but tell it sl...
     │                          │
     │ ┌───────── 2: AFTER LONG SILENCE ─────────┐t lies
     │ │                                         │r infirm Delight
     │ │Speesh after long silense; it is right,  │b surprise
     │ │All other lovers being estranged or dead │ ┌─── 5: THE IDLE...
     │ │Unfriendly lamplight hid under its shade,│h│
     │ │The curtai┌──────── 4: FLYING CROOKED ──── │The idle life I...
     │ │That we de│                                │Is like a pleas...
     │ │Upon the s│The butterfly, a cabbare-white, │Wherein I rest ...
     │ │Bodily dec│(His honest idiocy of flight)   │The dreams that...
     │ │We loved e│Will never now, it is too late, │
     │ │          │Master the art of flying straigh│And still of al...
     │ │          │Yet has - who knows so well as I│In turt so swif...
     │ └─┌─3: A MAN SAID TO THE UNIVERSE───┐ o fly:│Each in its fan...
     │   │                                 │ by gue│A nobler than t...
     │   │A man said to the universe:      │lessnes│
     │   │"Sur, I exist!"                  │       │And every eve I...
     │   │"However," replied the uviverse, │d gift │Noting my step ...
     │   │"The fast has not created in me  │es     │That I have kvo...
     │   │A sense of obligation."          │       │In all my life ...
     │   │               Stephen Crane     ├───────┤         Robert...
     │   │                                 │       │
     │   └─────────────────────────────────┘       └───────────────...
     │
     └─────────────────────────────────────────────────────────────────────
                     Рисунок 6.9. Стихотворения.
                                                                       78

     Листинг 6.15: poetry.c

     /* poetry.c */
     #include "twindow.h"
     void poems(void);

     main()
     {
         load_help("tcprogs.hlp");
         poems();
     }

     Листинг 6.16: poems.c

     /* poems.c */
     #include <stdio.h>
     #include <string.h>
     #include <stdlib.h>
     #include "twindow.h"
     #include "keys.h"

     /* локальные прототипы */
     void get_poem(int s);
     int ht (char **tb);
     int wd (char **tb);
     char *titles [] = {
         " 1: TELL ALL THE TRUTH BUT TELL IT SLANT ",
         " 2: AFTER LONG SILENSE ",
         " 3: A MAN SAID TO THE UNIVERSE ",
         " 4: FLYING CROOKED ",
         " 5: THE IDLE LIFE I LEAD ",0 };
     WINDOW *pno [] = {0, 0, 0, 0, 0};
     static int x [] = {20, 15, 29, 10, 17};
     static int y [] = {5,10, 13, 18, 6};
     static int wcl [] [2] = {  {BLUE, WHITE},
                                {MAGENTA, WHITE},
                                {RED, WHITE},
                                {GREEN, WHITE},
                                {AQUA, WHITE}   };
     char *poem1 [] = {
         "Tell all the truth but tell it slant -",
         "Success in Circuit lies",
         "Too bright for our infirm Delight",
         "The Truth's superb surprise",
         "",
         "As Lightning to the Children eased",
         "With explanation kind",
         "The Truth must dazzle gradually",
         "Or every man be blind -",
         "                Emily Dickenson",0 };
     char *poem2 [] = {
         "Speech after long silence; it is right,",
         "All other lovers being estranged or dead,",
         "Unfriendly lamplight hid under its shade,",
         "The curtains drawn upon unfriendly night,",
         "That we descant and yet again descant",
         "Upon the supreme theme of Art and Song:",
         "Bodily decrepitude is wisdom; young",
         "We loved each other and were ignorant.",
         "              William Butler Yeats",0 };




                                                                       79

     char *poem3 [] = {
         "A man said to the universe:",
         "\"Sir, I exist!\"",
         "\"However,\" replied the universe,",
         "\"The fast has not created in me",
         "A sense of obligation.\"",
         "               Stephen Crane",0 };

     char *poem4 [] = {
         "The butterfly, a cabbage-white,",
         "(His honest idiocy of flight)",
         "Will never now, it is too late,",
         "Master the art of flying straight,",
         "Yet has - who knows so well as I? -",
         "A just sense of how not to fly:",
         "He lurches here and there by guess",
         "And God and hope and hopelessness.",
         "Even the aerobatic swift",
         "Has not his flyihg-crooked gift.",
         "              Robert Graves",0 };

     char *poem5 [] = {
         "The idle life I lead",
         "Is like a pleasant sleep,",
         "Wherein I rest and heed",
         "The dreams that by me sweep.",
         "",
         "And still of all my dreams",
         "In turn so swiftly past,",
         "Each in its fancy seems,",
         "A nobler than the last.",
         "",
         "And every eve I say,",
         "Noting my step in bliss,",
         "That I have known no  day",
         "In all my life like this.",
         "         Robert Bridges",0 };

     char **poem [] = { poem1, poem2, poem3, poem4, poem5, 0 };

     void poems()
     {
         int s = 0, i, c;
         WINDOW *mn;
         char **cp;

         cursor(0, 25);
         mn = establish_window(0, 0, 7, 45);
         set_title(mn, " Select A Poem ");
         set_colors(mn, ALL, BLUE, GREEN, BRIGHT);
         set_colors(mn, ACCENT, GREEN, WHITE, BRIGHT);
         display_window(mn);
         cp = titles;
         while (*cp)
             wprintf(mn, "\n%s", *cp++);









                                                                       80

         while (1)   {
             set_help("poemmenu", 40, 10);
             s = get_selection(mn, s+1, "12345");
             if (s == 0)
                 break;
             if (s == FWD || s == BS)       {
                 s = 0;
                 continue;
             }
             hide_window(mn);
             get_poem(--s);
             c = 0;
             set_help("poems   ", 5, 15);
             while (c != ESC)    {
                 c = get_char();
                 switch (c)  {
                     case FWD:   rmove_window(pno[s], 1, 0);
                                 break;
                     case BS:    rmove_window(pno[s], -1,0);
                                 break;
                     case UP:    rmove_window(pno[s], 0, -1);
                                 break;
                     case DN:    rmove_window(pno[s], 0, 1);
                                 break;
                     case DEL:   delete_window(pno[s]);
                                 pno[s] = NULL;
                                 break;
                     case '+':   forefront(pno[s]);
                                 break;
                     case '-':   rear_window(pno[s]);
                     default:    break;
                 }
                 if (c > '0' && c < '6')
                     get_poem(s = c - '1');
              }
              forefront(mn);
              display_window(mn);
          }
          close_all();
          for (i = 0; i < 5; i++)
              pno[i] = NULL;
     }
     /* активизирует стихотворение по номеру */
     static void get_poem(int s)
     {
         char **cp;
         static int lastp = -1;
         if (lastp != -1)
             set_intensity(pno[lastp], DIM);
         lastp = s;
         if (pno [s])
             set_intensity(pno[s], BRIGHT);
         else    {
             pno [s] = establish_window
                 (x[s], y[s], ht(poem[s]), wd(poem[s]));
             set_title(pno[s], titles[s]);
             set_colors(pno[s],ALL,wcl[s][0],wcl[s][1], BRIGHT);
             set_border(pno[s], 1);
             display_window(pno[s]);
             cp = poem[s];
             while (*cp)
                 wprintf(pno[s], "\n %s", *cp++);
         }
     }
                                                                       81

     /* вычисляет высоту показываемой таблицы окна */
     static int ht(char **tb)
     {
         int h = 0;
         while (*(tb + h++)) ;
         return h + 3;
     }
     /* вычисляет ширину показываемой таблицы окна */
     static int wd(char **tb)
     {
         int w = 0;
         while (*tb)     {
             w = max(w, strlen(*tb));
             tb++;
         }
         return w + 4;
     }

     Листинг 6.17: poetry.prj

     poetry
     poems (twindow.h, keys.h)
     thelp (twindow.h, keys.h)
     twindow (twindow.h, keys.h)
     ibmpc.obj

          В программе  poetry  клавиша  <F1>  используется в  качестве
     функциональеной клавиши контекстно-управляемой  подсказки.  Когда
     вы нажимаете <F1>,   появляется окно с подсказывающим сообщением,
     относящимся к тому, что вы сейчас делаете. В Главе 7 объясняется,
     как включается эта возможность.


                           Резюме
     -----------------------------------------------------------------

          Теперь у  вас   имеется   основа   для   создания   оконного
     программного  инструментария.  С  помощью  этих функций вы можете
     добавить  окна  к  своему  программному  обеспечению,   а   также
     отображать  в  них  текст.  Однако  приложение  окон может быть в
     дальнейшем развито до возможностей более высокого уровня, которые
     являются   общими   во   многих  прикладных  системах.  Несколько
     последующих  глав  добавляют  эти  возможности  к  вашей  оконной
     библиотеке.  Глава  7  вводит  использование  окон для добавления
     контекстно-управляемой   пользовательской   подсказки   в    ваши
     программы.


















                                                                       82