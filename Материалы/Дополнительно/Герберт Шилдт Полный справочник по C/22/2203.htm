<HTML><HEAD>
<TITLE>Стеки</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#22">Содержание</A> | <A href="2202.htm">&lt;&lt;&lt;</A> | <A href="2204.htm">&gt;&gt;&gt;</A><HR>
<H1>Стеки</H1>
<P class="tj"><I>Стек</I> (stack) является как бы противоположностью очереди, поскольку он работает по принципу "последним пришел — первым вышел" (last-in, first-out, LIFO)<SUP><A href="#11" name="1">[1]</A></SUP>. Чтобы наглядно представить себе стек, вспомните стопку тарелок. Первая тарелка, стоящая на столе, будет использована последней, а последняя тарелка, положенная наверх — первой. Стеки часто применяются в системном программном обеспечении, включая компиляторы и интерпретаторы.
<P class="tj">При работе со стеками операции занесения и извлечения элемента являются основными. Данные операции традиционно называются "затолкать в стек" (push)<SUP><A href="#22" name="2">[2]</A></SUP> и "вытолкнуть из стека" (pop)<SUP><A href="#33" name="3">[3]</A></SUP>. Поэтому для реализации стека необходимо написать две функции: <KBD>push()</KBD>, которая "заталкивает" значение в стек, и <KBD>pop()</KBD>, которая "выталкивает" значение из стека. Также необходимо выделить область памяти, которая будет использоваться в качестве стека. Для этой цели можно отвести массив или динамически выделить фрагмент памяти с помощью функций языка С, предусмотренных для динамического распределения памяти. Как и в случае очереди, функция извлечения получает из списка элемент и удаляет его, если он не хранится где-либо еше. Ниже приведена общая форма функций <KBD>push()</KBD> и <KBD>pop()</KBD>, работающих с целочисленным массивом. Стеки данных другого типа можно организовывать, изменив базовый тип данных массива.
<PRE>
int stack[MAX];
int tos=0;   /* вершина стека */

/* Затолкать элемент в стек. */
void push(int i)
{

  if(tos >= MAX) {
    printf("Стак полон\n");
    return;
  }
  stack[tos] = i;
  tos++;
}

/* Получить верхний элемент стека. */
int pop(void)
{
  tos--;
  if(tos < 0) {
    printf("Стек пуст\n");
    return 0;
  }
  return stack[tos];
}
</PRE>
<P class="tj">Переменная <KBD>tos</KBD> ("top of stack" — "вершина стека"<SUP><A href="#44" name="4">[4]</A></SUP>) содержит индекс вершины стека. При реализации данных функций необходимо учитывать случаи, когда стек заполнен или пуст. В нашем случае признаком пустого стека является равенство <KBD>tos</KBD> нулю, а признаком переполнения стека — такое увеличение <KBD>tos</KBD>, что его значение указывает куда-нибудь за пределы последней ячейки массива. Пример работы стека показан в табл. 22.2.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 22.2. Действие стека</B></CAPTION>
<TR><TH><I>Действие</I><TH><I>Содержимое стека</I>
<TR><TD><KBD>push(A)</KBD><TD>A
<TR><TD><KBD>push(B)</KBD><TD>В А
<TR><TD><KBD>push(C)</KBD><TD>C B A
<TR><TD><KBD>рор()</KBD> извлекает С<TD>В А
<TR><TD><KBD>push(F)</KBD><TD>F В А
<TR><TD><KBD>рор()</KBD> извлекает F<TD>В А
<TR><TD><KBD>рор()</KBD> извлекает В<TD>А
<TR><TD><KBD>рор()</KBD> извлекает А<TD>пусто
</TABLE>
<P class="tj">Прекрасный пример использования стека — калькулятор с четырьмя действиями. Большинство современных калькуляторов воспринимают стандартную запись выражений, называемую <I>инфиксной записью</I><SUP><A href="#55" name="5">[5]</A></SUP>, общая форма которой выглядит как <I>операнд-оператор-операнд</I>. Например, чтобы сложить 100 и 200, необходимо ввести <KBD>100</KBD>, нажать кнопку "плюс" ("+"), затем ввести <KBD>200</KBD> и нажать кнопку "равно" ("="). Напротив, во многих ранних калькуляторах (и некоторых из производимых сегодня) применяется <I>постфиксная запись</I><SUP><A href="#66" name="6">[6]</A></SUP>, в которой сначала вводятся оба операнда, а затем оператор. Например, чтобы сложить 100 и 200 в постфиксной записи, необходимо ввести <KBD>100</KBD>, затем <KBD>200</KBD>, а потом нажать клавишу "плюс". В этом методе операнды при вводе заталкиваются в стек. При вводе оператора операнды извлекаются (выталкиваются) из стека, а результат помещается обратно в стек. Одно из преимуществ постфиксной формы заключается в легкости ввода длинных сложных выражений.
<P class="tj">Следующий пример демонстрирует использование стека в программе, реализующей постфиксный калькулятор для целочисленных выражений. Для начала необходимо модифицировать функции <KBD>push()</KBD> и <KBD>pop()</KBD>, как показано ниже. Следует знать, что стек будет размешаться в динамически распределяемой памяти, а не в массиве фиксированного размера. Хотя применение динамического распределения памяти и не требуется в таком простом примере, мы увидим, как использовать динамическую память для хранения данных стека.
<PRE>
int *p;   /* указатель на область свободной памяти */
int *tos; /* указатель на вершину стека */
int *bos; /* указатель на дно стека */

/* Занесение элемента в стек. */
void push(int i)
{
  if(p > bos) {
    printf("Стек полон\n");
    return;
  }
  *p = i;
  p++;
}

/* Получение верхнего элемента из стека. */
int pop(void)
{
  p--;
  if(p < tos) {
    printf("Стек пуст\n");
    return 0;
  }
  return *p;
}
</PRE>
<P class="tj">Перед использованием этих функций необходимо выделить память из области свободной памяти с помощью функции <KBD>malloc()</KBD> и присвоить переменой <KBD>tos</KBD> адрес начала этой области, а переменной <KBD>bos</KBD> — адрес ее конца.
<P class="tj">Текст программы постфиксного калькулятора целиком приведен ниже.
<PRE>
/* Простой калькулятор с четырмя действиями. */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX 100

int *p;   /* указатель на область свободной памяти */
int *tos; /* указатель на вершину стека */
int *bos; /* указатель на дно стека */

void push(int i);
int pop(void);

int main(void)
{
  int a, b;
  char s[80];

  p = (int *) malloc(MAX*sizeof(int)); /* получить память для стека */
  if(!p) {
    printf("Ошибка при выделении памяти\n");
    exit(1);
  }
  tos = p;
  bos = p + MAX-1;

  printf("Калькулятор с четырьмя действиями\n");
  printf("Нажмите 'q' для выхода\n");

  do {
    printf(": ");
    gets(s);
    switch(*s) {
      case '+':
        a = pop();
        b = pop();
        printf("%d\n", a+b);
        push(a+b);
        break;
      case '-':
        a = pop();
        b = pop();
        printf("%d\n", b-a);
        push(b-a);
        break;
      case '*':
        a = pop();
        b = pop();
        printf("%d\n", b*a);
        push(b*a);
        break;
      case '/':
        a = pop();
        b = pop();
        if(a==0) {
          printf("Деление на 0.\n");
          break;
        }
        printf("%d\n", b/a);
        push(b/a);
        break;
      case '.': /* показать содержимое вершины стека */
        a = pop();
        push(a);
        printf("Текущее значение на вершине стека: %d\n", a);
        break;
      default:
        push(atoi(s));
    }
  } while(*s != 'q');

  return 0;
}

/* Занесение элемента в стек. */
void push(int i)
{
  if(p &gt; bos) {
    printf("Стек полон\n");
    return;
  }
  *p = i;
  p++;
}

/* Получение верхнего элемента из стека. */
int pop(void)
{
  p--;
  if(p &lt; tos) {
    printf("Стек пуст\n");
    return 0;
  }
  return *p;
}
</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Иными словами, в <I>магазинном порядке</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>А также: <I>проталкивать (в стек), помещать на стек, класть в стек, поместить в стек, положить в стек, сохранить в стеке</I>.
<P class="tj"><SUP><A href="#3" name="33">[3]</A></SUP>А также: <I>выталкивать данные из стека, выталкивание из стека, выталкивание данных из стека, снимать со стека, вынимать из стека, считывать из стека, вытаскивать из стека</I>.
<P class="tj"><SUP><A href="#4" name="44">[4]</A></SUP>Называется также <I>верхушкой</I>.
<P class="tj"><SUP><A href="#5" name="55">[5]</A></SUP>Другие названия: <I>инфиксное представление, инфиксная нотация</I>.
<P class="tj"><SUP><A href="#6" name="66">[6]</A></SUP>Другие названия: <I>постфиксная нотация, польская инверсная запись</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#22">Содержание</A> | <A href="2202.htm">&lt;&lt;&lt;</A> | <A href="2204.htm">&gt;&gt;&gt;</A>
</BODY></HTML>