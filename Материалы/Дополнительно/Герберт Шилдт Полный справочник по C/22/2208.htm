<HTML><HEAD>
<TITLE>Двоичные деревья</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#22">Содержание</A> | <A href="2207.htm">&lt;&lt;&lt;</A> | <A href="../23/23.htm">&gt;&gt;&gt;</A><HR>
<H1>Двоичные деревья</H1>
<P class="tj">Напоследок мы рассмотрим структуру данных, которая называется <I>двоичное дерево</I> (binary tree). Несмотря на то, что бывает много различных типов деревьев, двоичные деревья играют особую роль, так как в отсортированном состоянии позволяют очень быстро выполнять вставку, удаление и поиск. Каждый элемент двоичного дерева состоит из информационной части и указателей на левый и правый элементы. На рис. 22.8 показано небольшое двоичное дерево.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 22.8. Пример двоичного дерева, высота которого равна 3</I>
<TR><TD>
<PRE>
                                 корень
                               &#8601;
                      +-------+
                      |данные |
                      +---+---+
      левое           |   |   |           правое
     поддерево        +---+---+          поддерево
         &#8600;          &#8601;          &#8600;          &#8601;
           +-------+             +-------+
           |данные |             |данные |
           +---+---+             +---+---+
           |   |   |             | 0 |   |
           +---+---+             +---+---+
         &#8601;          &#8600;                     &#8600;
+-------+             +-------+             +-------+
|данные |             |данные |             |данные |
+---+---+             +---+---+             +---+---+
| 0 | 0 |             | 0 | 0 |             | 0 | 0 |
+---+---+             +---+---+             +---+---+
      &#8593;                   &#8593;                   &#8593;
      '----------------листья-----------------'
</PRE>
</TABLE>
<P class="tj">При обсуждении деревьев применяется специальная терминология. Программисты не являются специалистами в области филологии, и поэтому терминология, применяемая в теории графов (а ведь деревья представляют собой частный случай графов!), является классическим примером неправильного употребления слов. Первый элемент дерева называется <I>корнем</I> (root). Каждый элемент данных называется <I>вершиной дерева</I> (node), а любой фрагмент дерева называется <I>поддеревом</I> (subtree). Вершина, к которой не присоединены поддеревья, называется <I>заключительным узлом</I> (terminal node) или <I>листом</I> (leaf). <I>Высота</I> (height) дерева равняется максимальному количеству уровней от корня до листа. При работе с деревьями можно допустить, что в памяти они существуют в том же виде, что и на бумаге. Но помните, что дерево — всего лишь способ логической организации данных в памяти, а память линейна.
<P class="tj">В некотором смысле двоичное дерево является особым видом связанного списка. Элементы можно вставлять, удалять и извлекать в любом порядке. Кроме того, операция извлечения не является разрушающей. Несмотря на то, что деревья легко представить в воображении, в теории программирования с ними связан ряд сложных задач. В данном разделе деревья затрагиваются лишь поверхностно.
<P class="tj">Большинство функций, работающих с деревьями, рекурсивны, поскольку дерево по своей сути является рекурсивной структурой данных. Другими словами, каждое поддерево, в свою очередь, является деревом. Поэтому разрабатываемые здесь функции будут рекурсивными. Существуют и не рекурсивные версии этих функций, но их код понять намного сложнее.
<P class="tj">Способ упорядочивания дерева зависит от того, как к нему впоследствии будет осуществляться доступ. Процесс поочередного доступа к каждой вершине дерева называется <I>обходом (вершин) дерева</I> (tree traversal). Рассмотрим следующее дерево:
<PRE>
      d 
    &#8601;   &#8600;
   b      f
 &#8601;  &#8600;   &#8601;  &#8600;
a    c  e   g
</PRE>
<P class="tj">Существует три порядка обхода дерева: <I>обход симметричным способом</I>, или <I>симметричный обход</I> (inorder), <I>обход в прямом порядке, прямой обход, упорядоченный обход, обход сверху</I>, или <I>обход в ширину</I> (preorder) и обход в <I>обратном порядке, обход в глубину, обратный обход, обход снизу</I> (postorder). При симметричном обходе обрабатывается сначала левое поддерево, затем корень, а затем правое поддерево. При прямом обходе обрабатывается сначала корень, затем левое поддерево, а потом правое. При обходе снизу сначала обрабатывается левое поддерево, затем правое и, наконец корень. Последовательность доступа при каждом методе обхода показана ниже:
<PRE>
Симметричный обход       <B>a b c d e f g</B>
Прямой обход             <B>d b a c f e g</B>
Обход снизу              <B>a c b e g f d</B>
</PRE>
<P class="tj">Несмотря на то, что дерево не должно быть обязательно упорядоченным, в большинстве задач используются именно такие деревья. Конечно, структура упорядоченного дерева зависит от способа его обхода. В оставшейся части данной главы предполагается симметричный обход. Поэтому упорядоченным двоичным деревом будет считаться такое дерево, в котором левое поддерево содержит вершины, меньшие или равные корню, а правое содержит вершины, большие корня.
<P class="tj">Приведенная ниже функция <KBD>stree()</KBD> создает упорядоченное двоичное дерево:
<PRE>
struct tree {
  char info;
  struct tree *left;
  struct tree *right;
};

struct tree *stree(
  struct tree *root,
  struct tree *r,
  char info)
{
  if(!r) {
    r = (struct tree *) malloc(sizeof(struct tree));
    if(!r) {
      printf("Не хватает памяти\n");
      exit(0);
    }
    r->left = NULL;
    r->right = NULL;
    r->info = info;
    if(!root) return r; /* первый вход */
    if(info < root->info) root->left = r;
    else root->right = r;
    return r;
  }
  if(info < r->info)
    stree(r,r->left,info);
  else
    stree(r,r->right,info);

  return root; 
}
</PRE>
<P class="tj">Приведенный выше алгоритм просто следует по ссылкам дерева, переходя к левой или правой ветви очередной вершины на основании содержимого поля <KBD>info</KBD> до достижения места вставки нового элемента. Чтобы использовать эту функцию, необходимо иметь глобальную переменную-указатель на корень дерева. Этот указатель изначально должен иметь значение нуль (<KBD>NULL</KBD>). При первом вызове функция <KBD>stree()</KBD> возвращает указатель на корень дерева, который нужно присвоить глобальной переменной. При последующих вызовах функция продолжает возвращать указатель на корень. Допустим, что глобальная переменная, содержащая корень дерева, называется <KBD>rt</KBD>. Тогда функция <KBD>stree()</KBD> вызывается следующим образом:
<PRE>
/* вызов функции street() */
rt = street(rt, rt, info);
</PRE>
<P class="tj">Функция <KBD>stree()</KBD> использует рекурсивный алгоритм, как и большинство процедур работы с деревьями. Точно такая же функция, основанная на итеративных методах, была бы в несколько раз длиннее. Функцию <KBD>stree()</KBD> необходимо вызывать со следующими параметрами (слева направо): указатель на корень всего дерева, указатель на корень следующего поддерева, в котором осуществляется поиск, и сохраняемые данные. При первом вызове оба первых параметрах указывают на корень всего дерева. Для простоты в вершинах дерева хранятся одиночные символы. Тем не менее, вместо них можно использовать любой тип данных.
<P class="tj">Чтобы обойти созданное функцией <KBD>stree()</KBD> дерево в симметричном порядке и распечатать поле <KBD>info</KBD> в каждой вершине, можно применить приведенную ниже функцию <KBD>inorder()</KBD>:
<PRE>
void inorder(struct tree *root)
{
  if(!root) return;

  inorder(root->left);
  if(root->info) printf("%c ", root->info);
  inorder(root->right);
}
</PRE>
<P class="tj">Данная рекурсивная функция завершает работу тогда, когда находит заключительный узел (нулевой указатель).
<P class="tj">В следующем листинге показаны функции, выполняющие обход дерева в ширину и в глубину.
<PRE>
void preorder(struct tree *root)
{
  if(!root) return;

  if(root->info) printf("%c ", root->info);
  preorder(root->left);
  preorder(root->right);
}

void postorder(struct tree *root)
{
  if(!root) return;

  postorder(root->left);
  postorder(root->right);
  if(root->info) printf("%c ", root->info);
}
</PRE>
<P class="tj">Теперь давайте рассмотрим короткую, но интересную программу, которая строит упорядоченное двоичное дерево, а затем, обходя его симметричным образом, отображает его на экране боком. Для отображения дерева требуется лишь слегка модифицировать функцию <KBD>inorder()</KBD>. Поскольку на экране дерево распечатывается боком, для корректного отображения правое поддерево необходимо печатать прежде левого. (Технически это противоположность симметричного обхода.) Новая функция называется <KBD>printtree()</KBD>, а ее код показан ниже:
<PRE>
void print_tree(struct tree *r, int l)
{
  int i;

  if(r == NULL) return;

  print_tree(r->right, l+1);
  for(i=0; i<l; ++i) printf(" ");
  printf("%c\n", r->info);
  print_tree(r->left, l+1);
}
</PRE>
<P class="tj">Далее следует текст всей программы печати дерева. Попробуйте вводить различные деревья, чтобы увидеть, как они строятся.
<PRE>
/* Эта программа выводит на экран двоичное дерево. */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct tree {
  char info;
  struct tree *left;
  struct tree *right;
};

struct tree *root; /* начальная вершина дерева */
struct tree *stree(struct tree *root,
                   struct tree *r, char info);
void print_tree(struct tree *root, int l);

int main(void)
{
  char s[80];

  root = NULL;  /* инициализация корня дерева */

  do {
    printf("Введите букву: ");
    gets(s);
    root = stree(root, root, *s);
  } while(*s);

  print_tree(root, 0);

  return 0;
}

struct tree *stree(
  struct tree *root,
  struct tree *r,
  char info)
{

  if(!r) {
    r = (struct tree *) malloc(sizeof(struct tree));
    if(!r) {
      printf("Не хватает памяти\n");
      exit(0);
    }
    r->left = NULL;
    r->right = NULL;
    r->info = info;
    if(!root) return r; /* первый вход */
    if(info < root->info) root->left = r;
    else root->right = r;
    return r;
  }

  if(info < r->info)
    stree(r, r->left, info);
  else
    stree(r, r->right, info);

  return root;
}

void print_tree(struct tree *r, int l)
{
  int i;

  if(!r) return;

  print_tree(r->right, l+1);
  for(i=0; i<l; ++i) printf(" ");
  printf("%c\n", r->info);
  print_tree(r->left, l+1);
}
</PRE>
<P class="tj">По существу, данная программа сортирует вводимую информацию. Метод сортировки является одной из разновидностей сортировки методом вставок, которая была рассмотрена в предыдущей главе. В среднем случае производительность может быть вполне хорошей.
<P class="tj">Если вы запускали программу печати дерева, вы, вероятно, заметили, что некоторые деревья являются <I>сбалансированными</I> (balanced), т.е. каждое поддерево имеет примерно такую же высоту, как и остальные, а некоторые деревья очень далеки от этого состояния. Например, дерево <B>a</B>&#8658;<B>b</B>&#8658;<B>c</B>&#8658;<B>d</B> выглядит следующим образом:
<PRE>
a
 &#8600;
   b
    &#8600;
      c
       &#8600;
         d
</PRE>
<P class="tj">В этом дереве нет левых поддеревьев. Такое дерево называется <I>вырожденным</I>, поскольку фактически оно выродилось в линейный список. В общем случае, если при построении дерева вводимые данные являются случайными, то получаемое дерево оказывается близким к сбалансированному. Если же информация предварительно отсортирована, создается вырожденное дерево. (Поэтому иногда при каждой вставке дерево корректируют так, чтобы оно было сбалансированным, но этот процесс довольно сложен и выходит за рамки данной главы.)
<P class="tj">В двоичных деревьях легко реализовываются функции поиска. Приведенная ниже функция возвращает указатель на вершину дерева, в которой информация совпадает с ключом поиска, либо нуль (<KBD>NULL</KBD>), если такой вершины нет.
<PRE>
struct tree *search_tree(struct tree *root, char key)
{
  if(!root) return root;  /* пустое дерево */
  while(root->info != key) {
    if(key<root->info) root = root->left;
    else root = root->right;
    if(root == NULL) break;
  }
  return root;
}
</PRE>
<P class="tj">К сожалению, удалить вершину дерева не так просто, как отыскать. Удаляемая вершина может быть либо корнем, либо левой, либо правой вершиной. Помимо того, к вершине могут быть присоединены поддеревья (количество присоединенных поддеревьев может равняться 0, 1 или 2). Процесс переустановки указателей подсказывает рекурсивный алгоритм, приведенный ниже:
<PRE>
struct tree *dtree(struct tree *root, char key)
{
  struct tree *p,*p2;

  if(!root) return root; /* вершина не найдена */

  if(root->info == key) { /* удаление корня */
    /* это означает пустое дерево */
    if(root->left == root->right){
      free(root);
      return NULL;
    }
    /* или если одно из поддеревьев пустое */
    else if(root->left == NULL) {
      p = root->right;
      free(root);
      return p;
    }
    else if(root->right == NULL) {
      p = root->left;
      free(root);
      return p;
    }
    /* или есть оба поддерева */
    else {
      p2 = root->right;
      p = root->right;
      while(p->left) p = p->left;
      p->left = root->left;
      free(root);
      return p2;
    }
  }
  if(root->info < key) root->right = dtree(root->right, key);
  else root->left = dtree(root->left, key);
  return root;
}
</PRE>
<P class="tj">Необходимо также следить за правильным обновлением указателя на корень дерева, описанного вне данной функции, поскольку удаляемая вершина может быть корнем. Лучше всего с этой целью указателю на корень присваивать значение, возвращаемое функцией <KBD>dtree()</KBD>:
<PRE>root = dtree(root, key);</PRE>
<P class="tj">Двоичные деревья — исключительно мощное, гибкое и эффективное средство. Поскольку при поиске в сбалансированном дереве выполняется в худшем случае log<SUB>2</SUB>n сравнений, оно намного лучше, чем связанный список, в котором возможен лишь последовательный поиск.
<HR><A href="../main.htm#22">Содержание</A> | <A href="2207.htm">&lt;&lt;&lt;</A> | <A href="../23/23.htm">&gt;&gt;&gt;</A>
</BODY></HTML>