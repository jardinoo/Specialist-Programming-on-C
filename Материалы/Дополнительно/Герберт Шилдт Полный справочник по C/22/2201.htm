<HTML><HEAD>
<TITLE>Очереди</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#22">Содержание</A> | <A href="22.htm">&lt;&lt;&lt;</A> | <A href="2202.htm">&gt;&gt;&gt;</A><HR>
<H1>Очереди</H1>
<P class="tj">Очередь — это линейный список информации, работа с которой происходит по принципу "первым пришел — первым вышел" (first-in, first-out); этот принцип (и очередь как структура данных) иногда еще называется FIFO<SUP><A href="#11" name="1">[1]</A></SUP>. Это значит, что первый помещенный в очередь элемент будет получен из нее первым, второй помещенный элемент будет извлечен вторым и т.д. Это единственный способ работы с очередью; произвольный доступ к отдельным элементам не разрешается.
<P class="tj">Очереди очень часто встречаются в реальной жизни, например, около банков или ресторанов быстрого обслуживания. Чтобы представить себе работу очереди, давайте введем две функции: <KBD>qstore()</KBD> и <KBD>qretrieve()</KBD> (от "store"— "сохранять", "retrieve" — "получать"). Функция <KBD>qstore()</KBD> помещает элемент в конец очереди, а функция <KBD>qretrieve()</KBD> удаляет элемент из начала очереди и возвращает его значение. В табл. 22.1 показано действие последовательности таких операций.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 22.1. Работа очереди</B></CAPTION>
<TR><TH><I>Действие</I><TH><I>Содержимое очереди</I>
<TR><TD><KBD>qstore(A)</KBD><TD>A
<TR><TD><KBD>qstore(B)</KBD><TD>А В
<TR><TD><KBD>qstore(C)</KBD><TD>A B C
<TR><TD><KBD>qretrieve()</KBD> возвращает А<TD>В С
<TR><TD><KBD>qstore(D)</KBD><TD>B C D
<TR><TD><KBD>qretrieve()</KBD> возвращает В<TD>C D
<TR><TD><KBD>qretrieve()</KBD> возвращает С<TD>D
</TABLE>
<P class="tj">Следует иметь в виду, что операция извлечения удаляет элемент из очереди и уничтожает его, если он не хранится где-нибудь в другом месте. Поэтому после извлечения всех элементов очередь будет пуста.
<P class="tj">В программировании очереди применяются при решении многих задач. Один из наиболее популярных видов таких задач — симуляция. Очереди также применяются в планировщиках задач операционных систем и при буферизации ввода/вывода.
<P class="tj">Чтобы проиллюстрировать работу очереди, мы напишем простую программу планирования встреч. Эта программа позволяет сохранять информацию о некотором количестве встреч; потом по мере прохождения каждой встречи она удаляется из списка. Для упрощения описание встреч ограничено 255 символами, а количество встреч — произвольным числом 100.
<P class="tj">При разработке этой простой программы планирования необходимо прежде всего реализовать описанные здесь функции <KBD>qstore()</KBD> и <KBD>qretrieve()</KBD>. Они будут хранить указатели на строки, содержащие описания встреч.
<PRE>
#define MAX 100

char *p[MAX];
int spos = 0;
int rpos = 0;

/* Сохранение встречи. */
void qstore(char *q)
{
  if(spos==MAX) {
    printf("Список переполнен\n");
    return;
  }
  p[spos] = q;
  spos++;
}

/* Получение встречи. */
char *qretrieve()
{
  if(rpos==spos) {
    printf("Встреч больше нет.\n");
    return '\0';
  }
  rpos++;
  return p[rpos-1];
}
</PRE>
<P class="tj">Обратите внимание, что этим двум функциям требуются две глобальные переменные: <KBD>spos</KBD>, в которой хранится индекс следующего свободного места в списке, и <KBD>rpos</KBD>, в которой хранится индекс следующего элемента, подлежащего выборке. С помощью этих функций можно организовать очередь данных другого типа, просто поменяв базовый тип обрабатываемого ими массива.
<P class="tj">Функция <KBD>qstore()</KBD> помещает описания новых встреч в конец списка и проверяет, не переполнен ли список. Функция <KBD>qretrieve()</KBD> извлекает встречи из очереди, если таковые имеются. При назначении встреч увеличивается значение переменной <KBD>spos</KBD>, а по мере их прохождения увеличивается значение переменной <KBD>rpos</KBD>. По существу, <KBD>rpos</KBD> "догоняет" <KBD>spos</KBD> в очереди. На рис 22.1 показано, что может происходить в памяти при выполнении программы. Если <KBD>rpos</KBD> и <KBD>spos</KBD> равны, назначенные события отсутствуют. Даже несмотря на то, что функция <KBD>qretrieve()</KBD> не уничтожает хранящуюся в очереди информацию физически, эту информацию можно считать уничтоженной, так как повторно получить доступ к ней невозможно.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 22.1. Индекс выборки "догоняет" индекс вставки</I>
<TR><TD>
<PRE>
	<B>Начальное сосотояние очереди</B>

  &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos

	<B>qstore('A')</B>

      &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
| A |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos

	<B>qstore('B')</B>

          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
| A | B |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos

	<B>qretrive()</B>

          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   | B |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
      &#8593;rpos

	<B>qretrive()</B>

          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
          &#8593;rpos

	<B>qstore('A')</B>

              &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   | C |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
          &#8593;rpos
</PRE>
</TABLE>
<P class="tj">Текст программы простого планировщика встреч целиком приведен ниже. Вы можете доработать эту программу по своему усмотрению.
<PRE>
/* Мини-планировщик событий */

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

#define MAX 100

char *p[MAX], *qretrieve(void);
int spos = 0;
int rpos = 0;
void enter(void), qstore(char *q), review(void), delete_ap(void);

int main(void)
{
  char s[80];
  register int t;

  for(t=0; t &lt; MAX; ++t) p[t] = NULL; /* иницилизировать массив
                                         пустыми указателями */

  for(;;) {
    printf("Ввести (E), Список (L), Удалить (R), Выход (Q): ");
    gets(s);
    *s = toupper(*s);

    switch(*s) {
      case 'E':
        enter();
        break;
      case 'L':
        review();
        break;
      case 'R':
        delete_ap();
        break;
      case 'Q':
        exit(0);
    }
  }
  return 0;
}

/* Вставка в очередь новой встречи. */
void enter(void)
{
  char s[256], *p;

  do {
    printf("Введите встречу %d: ", spos+1);
    gets(s);
    if(*s==0) break; /* запись не была произведена */
    p = (char *) malloc(strlen(s)+1);
    if(!p) {
      printf("Не хватает памяти.\n");
      return;
    }
    strcpy(p, s);
    if(*s) qstore(p);
  } while(*s);
}

/* Просмотр содержимого очереди. */
void review(void)
{
  register int t;

  for(t=rpos; t &lt; spos; ++t)
    printf("%d. %s\n", t+1, p[t]);
}

/* Удаление встречи из очереди. */
void delete_ap(void)
{
  char *p;

  if((p=qretrieve())==NULL) return;
  printf("%s\n", p);
}

/* Вставка встречи. */
void qstore(char *q)
{
  if(spos==MAX) {
    printf("List Full\n");
    return;
  }
  p[spos] = q;
  spos++;
}

/* Извлечение встречи. */
char *qretrieve(void)
{
  if(rpos==spos) {
    printf("Встречь больше нет.\n");
    return NULL;
  }
  rpos++;
  return p[rpos-1];
}
</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Этот принцип имеет и другие названия: <I>"первым пришел — первым обслужен", "в порядке поступления", "первым пришел — первым вышел", "обратного магазинного типа".</I>
</BLOCKQUOTE>
<HR><A href="../main.htm#22">Содержание</A> | <A href="22.htm">&lt;&lt;&lt;</A> | <A href="2202.htm">&gt;&gt;&gt;</A>
</BODY></HTML>