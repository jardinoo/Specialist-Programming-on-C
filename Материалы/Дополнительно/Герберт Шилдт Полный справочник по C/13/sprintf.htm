<HTML><HEAD>
<TITLE>Функция sprintf</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#13">Содержание</A> | <A href="13.htm#00">Глава 13</A><HR>
<H1>Функция sprintf</H1>
<PRE>
#include &lt;stdio.h&gt;
int sprintf(char *<I>buf</I>, const char *<I>format</I>, ...);
</PRE>
<P class="tj">Функция <KBD>sprintf()</KBD> идентична функции <KBD>printf()</KBD> за исключением того, что поток вывода записывается в массив, адресуемый указателем <I>buf</I>, а не в стандартный поток <KBD>stdout</KBD>. По окончании работы функции этот массив будет завершаться символом конца строки (нуль-символом). Подробности рассматриваются в разделе, посвященном описанию функции <KBD>printf</KBD>.
<P class="tj">В версии C99 к параметрам <I>buf</I> и <I>format</I> применен квалификатор <KBD>restrict</KBD>.
<P class="tj">Возвращаемое значение равно числу символов, действительно помещенных в массив.
<P class="tj">Важно понимать, что функция <KBD>sprintf()</KBD> не обеспечивает никакой проверки переполнения массива, адресуемого указателем <I>buf</I>. Это значит, что массив будет переполнен, если объем выводимых символов превысит длину массива. В качестве альтернативного решения рассмотрите применение функции <KBD>snprintf()</KBD>.
<H2>Пример</H2>
<P class="tj">После выполнения этого фрагмента программы элементам массива <KBD>str</KBD> значения будут присвоены таким образом, что получится строка:
<PRE>один 2 3</PRE>
<PRE>
char str[80];

sprintf(str, "%s %d %c", "один", 2, '3');
</PRE>
<H2>Зависимые функции</H2>
<A href="printf.htm">printf()</A>  <A href="fsprintf.htm">fsprintf()</A>
<HR><A href="../main.htm#13">Содержание</A> | <A href="13.htm#00">Глава 13</A>
</BODY></HTML>