<HTML><HEAD>
<TITLE>Функция scanf</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#13">Содержание</A> | <A href="13.htm#00">Глава 13</A><HR>
<H1>Функция scanf</H1>
<PRE>
#include &lt;stdio.h&gt;
int scanf(const char *<I>format</I>, ...);
</PRE>
<P class="tj">Функция <KBD>scanf()</KBD> представляет собой процедуру ввода общего назначения, которая читает поток <KBD>stdin</KBD> и сохраняет информацию в переменных, перечисленных в списке аргументов. Она может читать все встроенные типы данных и автоматически преобразовывать их в соответствующий внутренний формат.
<P class="tj">В версии C99 к параметру <I>format</I> применен квалификатор <KBD>restrict</KBD>.
<P class="tj">Управляющая строка, задаваемая параметром <I>format</I>, состоит из символов трех категорий:
<UL type=square>
<LI>спецификаторов формата;<BR>
<LI>пробельных символов;<BR>
<LI>символов, отличных от пробельных.<BR>
</UL>
<P class="tj">Спецификации формата начинаются знаком <KBD>%</KBD> и сообщают функции <KBD>scanf()</KBD> тип данного, которое будет прочитано. Спецификации формата приведены в таблице 13.3. Например, по спецификации <KBD>%s</KBD> будет прочитана строка, а по спецификации <KBD>%d</KBD> — целое значение. Строка форматирования читается слева направо, и спецификации формата сопоставляются аргументам в порядке их перечисления в списке аргументов.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 13.3. Спецификации формата функции scanf()</B></CAPTION>
<TR><TH><I>Код</I><TH><I>Назначение</I>
<TR><TD><KBD>%a</KBD><TD>Читает значение с плавающей точкой (только C99)
<TR><TD><KBD>%A</KBD><TD>Аналогично коду <KBD>%a</KBD> (только C99)
<TR><TD><KBD>%c</KBD><TD>Читает один символ
<TR><TD><KBD>%d</KBD><TD>Читает десятичное целое
<TR><TD><KBD>%i</KBD><TD>Читает целое в любом формате (десятичное, восьмеричное или шестнадцатеричное)
<TR><TD><KBD>%e</KBD><TD>Читает число с плавающей точкой
<TR><TD><KBD>%E</KBD><TD>Аналогично коду <KBD>%e</KBD>
<TR><TD><KBD>%f</KBD><TD>Читает число с плавающей точкой
<TR><TD><KBD>%F</KBD><TD>Аналогично коду <KBD>%f</KBD> (только С99)
<TR><TD><KBD>%g</KBD><TD>Читает число с плавающей точкой
<TR><TD><KBD>%G</KBD><TD>Аналогично коду <KBD>%g</KBD>
<TR><TD><KBD>%o</KBD><TD>Читает восьмеричное число
<TR><TD><KBD>%s</KBD><TD>Читает строку
<TR><TD><KBD>%x</KBD><TD>Читает шестнадцатеричное число
<TR><TD><KBD>%X</KBD><TD>Аналогично коду <KBD>%x</KBD>
<TR><TD><KBD>%p</KBD><TD>Читает указатель
<TR><TD><KBD>%n</KBD><TD>Принимает целое значение, равное количеству прочитанных до сих пор символов
<TR><TD><KBD>%u</KBD><TD>Читает десятичное целое без знака
<TR><TD><KBD>%[]</KBD><TD>Просматривает набор символов
<TR><TD><KBD>%%</KBD><TD>Читает знак процента
</TABLE>
<P class="tj">По умолчанию спецификации <KBD>a</KBD>, <KBD>f</KBD>, <KBD>e</KBD> и <KBD>g</KBD> заставляют функцию <KBD>scanf()</KBD> присваивать данные переменным типа <KBD>float</KBD>. Если перед одной из этих спецификаций поставить модификатор <KBD>l</KBD>, функция <KBD>scanf()</KBD> присвоит прочитанные данные переменной типа <KBD>double</KBD>. Использование же модификатора <KBD>L</KBD> означает, что полученное значение присвоится переменной типа <KBD>long double</KBD>.
<P class="tj">Современные компиляторы, поддерживающие добавленные в 1995 году средства работы с двухбайтовыми символами, позволяют к спецификации <KBD>c</KBD> применить модификатор <KBD>l</KBD>; тогда будет считаться, что соответствующий указатель указывает на двухбайтовый символ (т.е. на данное типа <KBD>whcar_t</KBD>). Модификатор <KBD>l</KBD> также можно использовать с кодом формата <KBD>s</KBD>; тогда будет считаться, что соответствующий указатель указывает на строку двухбайтовых символов. Кроме того, модификатор <KBD>l</KBD> можно использовать для того, чтобы указать, что набор сканируемых символов состоит из двухбайтовых символов.
<P class="tj">Если в строке форматирования встретится разделитель, то функция <KBD>scanf()</KBD> пропустит один или несколько разделителей во входном потоке. Под разделителем, или пробельным символом, подразумевается пробел, символ табуляции или разделитель строк (символ новой строки). По сути, наличие одного разделителя в управляющей строке приведет к тому, что функция <KBD>scanf()</KBD> будет читать, не сохраняя, любое количество (возможно, даже нулевое) разделителей до первого символа, отличного от разделителя.
<P class="tj">Если в строке форматирования встретился символ, отличный от разделителя, то функция <KBD>scanf()</KBD> прочитает и отбросит его. Например, если в строке форматирования встретится <KBD>%d</KBD>, <KBD>%d</KBD>, то функция <KBD>scanf()</KBD> сначала прочитает целое значение, затем прочитает и отбросит запятую и, наконец, прочитает еще одно целое. Если заданный символ не найден, функция <KBD>scanf()</KBD> завершает работу.
<P class="tj">Все переменные, получающие значения с помощью функции <KBD>scanf()</KBD>, должны передаваться посредством своих адресов. Это значит, что все аргументы должны быть указателями на переменные.
<P class="tj">Элементы входного потока должны быть разделены пробелами, символами табуляции или разделителями строк. Такие символы, как запятая, точка с запятой и т.п., не распознаются в качестве разделителей. Это означает, что оператор
<PRE>
scanf("%d%d", &r, &c);
</PRE>
примет значения, введенные как <KBD>10 20</KBD>, но откажется от последовательности символов <KBD>10, 20</KBD>.
<P class="tj">Символ <KBD>*</KBD>, стоящий после знака <KBD>%</KBD> и перед кодом формата, прочитает данные заданного типа, но запретит их присваивание. Следовательно, оператор
<PRE>
scanf("%d%*c%d", &x, &y); 
</PRE>
при вводе данных в виде <KBD>10/20</KBD> поместит значение 10 в переменную <KBD>x</KBD>, отбросит знак деления и присвоит значение 20 переменной <KBD>у</KBD>.
<P class="tj">Команды форматирования могут содержать модификатор максимальной длины поля. Он представляет собой целое число, располагаемое между знаком <KBD>%</KBD> и кодом формата, которое ограничивает количество читаемых для всех полей символов. Например, если в переменную <KBD>address</KBD> нужно прочитать не более 20 символов, используется следующий оператор.
<PRE>
scanf("%20s", address); 
</PRE>
<P class="tj">Если входной поток содержит более 20 символов, то при последующем обращении к операции ввода чтение начнется с того места, в котором "остановился" предыдущий вызов функции <KBD>scanf()</KBD>. Если разделитель встретится раньше, чем достигнута максимальная длина поля, ввод данных завершится. В этом случае функция <KBD>scanf()</KBD> переходит к чтению следующего поля.
<P class="tj">Хотя пробелы, символы табуляции и разделители строк используются в качестве разделителей полей, при чтении одиночного символа они читаются подобно любому другому символу. Например, если входной поток состоит из символов <KBD>x у</KBD>, то оператор
<PRE>
scanf("%c%c%c", &a, &b, &c);
</PRE>
поместит символ x в переменную <KBD>а</KBD>, пробел — в переменную <KBD>b</KBD>, а символ у — в переменную <KBD>с</KBD>.
<P class="tj">Помните, что любые символы управляющей строки (включая пробелы, символы табуляции и новой строки), не являющиеся спецификациями формата, используются для установки соответствия и отбрасывания символов из входного потока. Любой соответствующий им символ отбрасывается. Например, если поток ввода выглядит, как <KBD>10t20</KBD>, оператор
<PRE>
scanf("%dt%d", &x, &y);
</PRE>
присвоит переменной <KBD>x</KBD> значение 10, а переменной <KBD>у</KBD> — значение 20. Символ <KBD>t</KBD> отбрасывается, так как он присутствует в управляющей строке.
<P class="tj">Функция <KBD>scanf()</KBD> поддерживает спецификатор формата общего назначения, называемый <I>набором сканируемых символов (scanset)</I>. В этом случае определяется набор символов, которые могут быть прочитаны функцией <KBD>scanf()</KBD> и присвоены соответствующему массиву символов. Для определения такого набора символы, подлежащие сканированию, необходимо заключить в квадратные скобки. Открывающая квадратная скобка должна следовать сразу за знаком процента. Например, следующий набор сканируемых символов указывает на то, что необходимо читать только символы <KBD>A</KBD>, <KBD>B</KBD> и <KBD>C</KBD>.
<PRE>
%[ABC]
</PRE>
<P class="tj">При использовании набора сканируемых символов функция <KBD>scanf()</KBD> продолжает читать символы и помещать их в соответствующий массив символов до тех пор, пока не встретится символ, отсутствующий в заданном наборе. Соответствующая набору переменная должна быть указателем на массив символов. При возврате из функции <KBD>scanf()</KBD> этот массив будет содержать строку из прочитанных символов, завершающуюся символом конца строки.
<P class="tj">Если первый символ в наборе является знаком <KBD>^</KBD>, то получаем обратный эффект: входное поле читается до тех пор, пока не встретится символ из заданного набора сканируемых символов, т.е. знак <KBD>^</KBD> заставляет функцию <KBD>scanf()</KBD> читать только те символы, которые отсутствуют в наборе сканируемых символов.
<P class="tj">Во многих реализациях допускается задавать диапазон с помощью дефиса. Например, функция <KBD>scanf</KBD>(), встречая набор сканируемых символов в виде <KBD>%[A-z]</KBD>, будет читать символы, попадающие в диапазон от А до Z.
<P class="tj">Важно помнить, что в наборе сканируемых символов различаются прописные и строчные буквы. Следовательно, чтобы сканировать как прописные, так и строчные буквы, в наборе сканируемых символов придется задать их отдельно.
<P class="tj">Функция <KBD>scanf()</KBD> возвращает число, равное количеству полей, для которых успешно присвоены значения. К этим полям не относятся поля, которые были прочитаны, но присвоение не состоялось в связи с использованием модификатора <KBD>*</KBD>, подавляющего присваивание. При обнаружении ошибки до присвоения значения первого поля функция <KBD>scanf()</KBD> возвращает значение <KBD>EOF</KBD>.
<H2>Модификаторы формата, добавленные к функции scanf() Стандартом C99</H2>
<P class="tj">В версии C99 для использования в функции <KBD>scanf()</KBD> добавлены модификаторы формата <KBD>hh</KBD>, <KBD>ll</KBD>, <KBD>j</KBD>, <KBD>z</KBD> и <KBD>t</KBD>. Модификатор <KBD>hh</KBD> можно применять к спецификациям <KBD>d</KBD>, <KBD>i</KBD>, <KBD>о</KBD>, <KBD>u</KBD>, <KBD>x</KBD> и <KBD>n</KBD>. Он означает, что соответствующий аргумент является указателем на значение типа <KBD>signed char</KBD> или <KBD>unsigned char</KBD>. Модификатор <KBD>ll</KBD> также можно применять к спецификациям <KBD>d</KBD>, <KBD>i</KBD>, <KBD>о</KBD>, <KBD>u</KBD>, <KBD>x</KBD> и <KBD>n</KBD>. Он означает, что соответствующий аргумент является указателем на значение типа <KBD>signed long long int</KBD> или <KBD>unsigned long long int</KBD>.
<P class="tj">Moдификaтop фopмaтa <KBD>j</KBD>, кoтopый пpимeняeтcя к cпeцификaциям <KBD>d</KBD>, <KBD>i</KBD>, <KBD>о</KBD>, <KBD>u</KBD>, <KBD>х</KBD> и <KBD>n</KBD> означает, что соответствующий аргумент является указателем на значение типа <KBD>intmax_t</KBD> или <KBD>uintmax_t</KBD>. Эти типы объявлены в заголовке <KBD>&lt;stdint.h&gt;</KBD> и служат для хранения целых максимально возможной разрядности.
<P class="tj">Модификатор формата <KBD>z</KBD>, который применяется к спецификациям <KBD>d</KBD>, <KBD>i</KBD>, <KBD>о</KBD>, <KBD>u</KBD>, <KBD>х</KBD> и <KBD>n</KBD> означает, что соответствующий аргумент является указателем на объект типа <KBD>size_t</KBD>. Этот тип объявлен в заголовке <KBD>&lt;stddef.h&gt;</KBD> и служит для хранения результата операции <KBD>sizeof</KBD>.
<P class="tj">Модификатор формата <KBD>t</KBD>, который применяется к спецификациям <KBD>d</KBD>, <KBD>i</KBD>, <KBD>о</KBD>, <KBD>u</KBD>, <KBD>х</KBD> и <KBD>n</KBD> означает, что соответствующий аргумент является указателем на объект типа <KBD>ptrdiff_t</KBD>. Этот тип объявлен в заголовке <KBD>&lt;stddef.h&gt;</KBD> и служит для хранения значения разности между двумя указателями.
<H2>Пример</H2>
<P class="tj">Действие данных операторов <KBD>scanf()</KBD> объясняется в комментариях.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  char str[80], str2[80];
  int i;

  /* читается строка и целое значение */
  scanf("%s%d", str, &i);

  /* в переменную str считывается не более 79 символов */
  scanf("%79s", str);

  /* целое, расположенное между двумя строками, пропускается */
  scanf("%s%*d%s", str, str2);

  return 0;
}
</PRE>
<H2>Зависимые функции</H2>
<A href="printf.htm">printf()</A>  <A href="fscanf.htm">fscanf()</A>
<HR><A href="../main.htm#13">Содержание</A> | <A href="13.htm#00">Глава 13</A>
</BODY></HTML>