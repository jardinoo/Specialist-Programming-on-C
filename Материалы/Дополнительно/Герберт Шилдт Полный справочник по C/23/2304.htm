<HTML><HEAD>
<TITLE>Представление разреженного массива в виде массива указателей</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#23">Содержание</A> | <A href="2303.htm">&lt;&lt;&lt;</A> | <A href="2305.htm">&gt;&gt;&gt;</A><HR>
<H1>Представление разреженного массива в виде массива указателей</H1>
<P class="tj">Допустим, что электронная таблица имеет размер 26x100 (от А1 до Z100), то есть состоит из 2`600 элементов. Теоретически можно хранить элементы таблицы в следующем массиве структур:
<PRE>
struct cell {
  char cell_name[9];
  char  formula[128];
} list_entry[2600];   /* 2600 ячеек */
</PRE>
<P class="tj">Ho 2`600, умноженное на 137 байтов (размер этой структуры в байтах), равняется 356`200 байтов памяти. Это слишком большой объем памяти, чтобы тратить его на не полностью используемый массив. Тем не менее, можно создать <I>массив указателей</I> (pointer array) на структуры типа <KBD>cell</KBD>. Для хранения массива указателей требуется намного меньше памяти, чем для массива структур. При каждом присвоении ячейке логического массива данных под эти данные выделяется память, а соответствующему указателю в массиве указателей присваивается адрес выделенного фрагмента. Такая схема позволяет добиться более высокой производительности, чем при связанном списке или двоичном дереве. Описание массива указателей выглядит следующим образом:
<PRE>
struct cell {
  char cell_name[9]; 
  char formula[128];
} list_entry;

struct cell *sheet[2600]; /* массив из 2600 указателей */
</PRE>
<P class="tj">Этот меньший по объему занимаемой памяти массив используется для хранения указателей на вводимые в электронную таблицу данные. При вводе очередной записи в соответствующую ячейку массива заносится указатель на введенные данные.  На рис. 23.2 показано, как выглядит в памяти разреженный массив, представленный в виде массива указателей.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 23.2. Представление разреженного массива в виде массива указателей</I>
<TR><TD>
<PRE>
+-+-+-+-+-+-+-+-+-+-+-+-+
|.|.|0|0|.|0|0|0|.|0|0|0|
+|+|+-+-+|+-+-+-+|+-+-+-+
 | |     |       |  +----+
 | |     |       '->|A[8]|
 | |     |          +----+
 | |     |  +----+
 | |     '->|A[4]|
 | |        +----+
 | |  +----+
 | '->|A[1]|
 |    +----+
 |  +----+
 '->|A[0]|
    +----+
</PRE>
</TABLE>
<P class="tj">Перед использованием массива указателей каждый его элемент необходимо проинициализировать нулем (<KBD>NULL</KBD>), что означает отсутствие данной записи. Ниже показана функция инициализации массива:
<PRE>
void init_sheet(void)
{
  register int t;

  for(t=0; t < 2600; ++t) sheet[t] = NULL;
}
</PRE>
<P class="tj">Когда пользователь вводит формулу в ячейку, занимающую определенное положение в электронной таблице (а положение ячейки, как известно, определяется ее именем), вычисляется индекс в массиве указателей <KBD>sheet</KBD>. Этот индекс получается путем преобразования строкового представления имени ячейки в число, как показано в следующем листинге:
<PRE>
void store(struct cell *i)
{
  int loc;
  char *p;

  /* вычисление индекса по заданному имени */
  loc = *(i->cell_name) - 'A'; /* столбец */
  p = &(i->cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количество строк * ширина строки +
                              столбец */

  if(loc >= 2600) {
    printf("Ячейка за пределами массива.\n");
    return;
  }
  sheet[loc] = i; /* поместить указатель в массив */
}
</PRE>
<P class="tj">При вычислении индекса в функции <KBD>store()</KBD> предполагается, что все имена ячеек начинаются с прописной буквы, за которой следует целое число, например, В34, С19 и т.д. Поэтому в результате вычислений по формуле, запрограммированной в функции <KBD>store()</KBD>, имя ячейки А1 соответствует индексу 0, имя В1 соответствует индексу 1, А2 — 26 и т.д. Поскольку имена ячеек уникальны, индексы также уникальны и указатель на каждую запись хранится в соответствующей позиции массива. Если сравнить эту процедуру с версиями, использующими связанный список или двоичное дерево, становится понятно, насколько она проще и короче.
<P class="tj">Функция удаления ячейки <KBD>deletecell()</KBD> также становится очень короткой. При вызове она просто обнуляет указатель на элемент и возвращает системе память.
<PRE>
void deletecell(struct cell *i)
{
  int loc;
  char *p;

  /* вычисление индекса по заданному имени ячейки */
  loc = *(i->cell_name) - 'A'; /* столбец */
  p = &(i->cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количества строк * ширина строки + 
                              столбец */

  if(loc >= 2600) {
    printf("Ячейка за пределами массива.\n");
    return;
  }
  if(!sheet[loc]) return; /* не освобождать, если указатель нулевой
                             (null) */

  free(sheet[loc]);  /* освободить системную память */
  sheet[loc] = NULL;
}
</PRE>
<P class="tj">Этот код также намного быстрее и проще, чем в версии со связанным списком.
<P class="tj">Процесс поиска ячейки по имени прост, поскольку имя ячейки однозначно определяет индекс в массиве указателей. Поэтому функция поиска принимает следующий вид:
<PRE>
struct cell *find(char *cell_name)
{
  int loc;
  char *p;

  /* вычисление индекса по заданному имени ячейки */
  loc = *(cell_name) - 'A'; /* столбец */
  p = &(cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количества строк * ширина строки + 
                              столбец */

  if(loc>=2600 || !sheet[loc]) { /* эта ячейка пустая */
    printf("Ячейка не найдена.\n");
    return NULL;  /* поиск неуспешный */
  }
  else return sheet[loc];
}
</PRE>
<H2>Анализ метода представления разреженного массива в виде массива указателей</H2>
<P class="tj">Метод реализации разреженного массива на основе массива указателей обеспечивает намного более быстрый доступ к элементам, чем методы на основе связанного списка и двоичного дерева. Если массив не очень большой, выделение памяти для массива указателей лишь незначительно уменьшает объем свободной памяти системы. Тем не менее, в массиве указателей для каждой ячейки выделяется некоторый объем памяти независимо от того, используется она или нет. В некоторых приложениях это может быть ограничением, хотя в общем случае это не является проблемой.
<HR><A href="../main.htm#23">Содержание</A> | <A href="2303.htm">&lt;&lt;&lt;</A> | <A href="2305.htm">&gt;&gt;&gt;</A>
</BODY></HTML>