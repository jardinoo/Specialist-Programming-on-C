<HTML><HEAD>
<TITLE>Оператор перехода</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#03">Содержание</A> | <A href="0305.htm">&lt;&lt;&lt;</A> | <A href="0307.htm">&gt;&gt;&gt;</A><HR>
<H1>Оператор перехода</H1>
<P class="tj">В языке С определены четыре оператора перехода: <KBD>return</KBD>, <KBD>goto</KBD>, <KBD>break</KBD> и <KBD>continue</KBD>. Операторы <KBD>return</KBD> и <KBD>goto</KBD> можно использовать в любом месте внутри функции. Операторы <KBD>break</KBD> и <KBD>continue</KBD> можно использовать в любом из операторов цикла. Как указывалось ранее в этой главе, <KBD>break</KBD> можно также использовать в операторе <KBD>switch</KBD>.
<H2>Оператор return</H2>
<P class="tj">Оператор <KBD>return</KBD> используется для выхода из функции. Отнесение его к категории операторов перехода обусловлено тем, что он заставляет программу перейти в точку вызова функции. Оператор <KBD>return</KBD> может иметь ассоциированное с ним значение, тогда при выполнении данного оператора это значение возвращается в качестве значения функции. В функциях типа <KBD>void</KBD> используется оператор <KBD>return</KBD> без значения.
<P class="tj">Стандарт С89 допускает наличие оператора <KBD>return</KBD> без значения, даже если тип функции отличен от <KBD>void</KBD>. В этом случае функция возвращает неопределенное значение. Но что касается языков С99 и C++, если тип функции отличен от <KBD>void</KBD>, то ее оператор <KBD>return</KBD> обязательно должен иметь значение. Конечно, и в программе на С89 отсутствие возвращаемого значения в функции, тип которой отличен от <KBD>void</KBD>, является признаком плохого стиля!
<P class="tj">Общая форма оператора <KBD>return</KBD> следующая:
<PRE>return <I>выражение</I>;</PRE>
<P class="tj"><I>Выражение</I> присутствует только в том случае, если функция возвращает значение. Это значение <I>выражения</I> становится возвращаемым значением функции.
<P class="tj">Внутри функции может присутствовать произвольное количество операторов <KBD>return</KBD>. Выход из функции происходит тогда, когда встречается один из них. Закрывающаяся фигурная скобка <KBD>}</KBD> также вызывает выход из функции. Выход программы на нее эквивалентен оператору <KBD>return</KBD> без значения. В этом случае функция, тип которой отличен от <KBD>void</KBD>, возвращает неопределенное значение.
<P class="tj">Функция, определенная со спецификатором <KBD>void</KBD>, не может содержать <KBD>return</KBD> со значением. Так как эта функция не возвращает значения, в ней не может быть оператора <KBD>return</KBD>, возвращающего значение. Более подробно <KBD>return</KBD> рассматривается в <A href="../06/06.htm">главе 6</A>.
<H2>Оператор goto</H2>
<P class="tj">Кроме <KBD>goto</KBD>, в языке С есть другие операторы управления (например <KBD>break</KBD>, <KBD>continue</KBD>), поэтому необходимости в применении <KBD>goto</KBD> практически нет. В результате чрезмерного использования операторов <KBD>goto</KBD> программа плохо читается, она становится "похожей на спагетти". Чаще всего такими программами недовольна администрация фирм, производящих программный продукт. То есть оператор <KBD>goto</KBD> весьма непопулярен, более того, считается, что в программировании не существует ситуаций, в которых нельзя обойтись без оператора <KBD>goto</KBD>. Но в некоторых случаях его применение все же уместно. Иногда, при умелом использовании, этот оператор может оказаться весьма полезным, например, если нужно покинуть глубоко вложенные циклы<SUP><A href="#11" name="1">[1]</A></SUP>. В данной книге оператор <KBD>goto</KBD> рассматривается только в этом разделе.
<P class="tj">Для оператора <KBD>goto</KBD> всегда необходима метка. <I>Метка</I> — это идентификатор с последующим двоеточием. Метка должна находится в той же функции, что и <KBD>goto</KBD>, переход в другую функцию невозможен. Общая форма оператора <KBD>goto</KBD> следующая:
<PRE>
goto <I>метка</I>;
.
.
.
<I>метка</I>:
</PRE>
<P class="tj">Метка может находиться как до, так и после оператора <KBD>goto</KBD>. Например, используя оператор <KBD>goto</KBD>, можно выполнить цикл от 1 до 100:
<PRE>
x = 1;
loop1:
  x++;
  if(x&lt;=100) goto loop1;
</PRE>
<H2>Оператор break</H2>
<P class="tj">Оператор <KBD>break</KBD> применяется в двух случаях. Во-первых, в операторе <KBD>switch</KBD> с его помощью прерывается выполнение последовательности <KBD>case</KBD> (см. раздел "Оператор выбора — switch" ранее в этой главе). В этом случае оператор <KBD>break</KBD> не передает управление за пределы блока. Во-вторых, оператор <KBD>break</KBD> используется для немедленного прекращения выполнения цикла без проверки его условия, в этом случае оператор <KBD>break</KBD> передает управление оператору, следующему после оператора цикла.
<P class="tj">Когда внутри цикла встречается оператор <KBD>break</KBD>, выполнение цикла безусловно (т.е. без проверки каких-либо условий.) прекращается и управление передается оператору, следующему за ним. Например, программа
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int t;

  for(t=0; t&lt;100; t++) {
    printf("%d ", t);
    if(t==10) break;
  }

  return 0;
}
</PRE>
<P class="t">выводит на экран числа от 0 до 10. После этого выполнение цикла прекращается оператором <KBD>break</KBD>, условие <KBD>t &lt; 100</KBD> при этом игнорируется.
<P class="tj">Оператор <KBD>break</KBD> часто используется в циклах, в которых некоторое событие должно вызвать немедленное прекращение выполнения цикла. В следующем примере нажатие клавиши прекращает выполнение функции <KBD>look_up()</KBD>:
<PRE>
void look_up(char *name)
{
  do {
    /* поиск имени 'name' */
    if(kbhit()) break;
  } while(!found);
  /* process match */
}
</PRE>
<P class="tj">Библиотечная функция <KBD>kbhit()</KBD> возвращает 0, если клавиша не нажата (то есть, буфер клавиатуры пуст), в противном случае она возвращает ненулевое значение. В стандарте С функция <KBD>kbhit()</KBD> не определена, однако практически она поставляется почти с каждым компилятором (возможно, под несколько другим именем).
<P class="tj">Оператор <KBD>break</KBD> вызывает выход только из внутреннего цикла. Например, программа
<PRE>
for(t=0; t&lt;100; ++t) {
  count = 1;
  for(;;) {
    printf("%d ", count);
    count++;
    if(count==10) break;
  }
}
</PRE>
<P class="t">100 раз выводит на экран числа от 1 до 9. Оператор <KBD>break</KBD> передает управление внешнему циклу <KBD>for</KBD>.
<P class="tj">Если оператор <KBD>break</KBD> присутствует внутри оператора <KBD>switch</KBD>, который вложен в какие-либо циклы, то <KBD>break</KBD> относится только к <KBD>switch</KBD>, выход из цикла не происходит.
<H2>Функция exit()</H2>
<P class="tj">Функция <KBD>exit()</KBD> не является оператором языка, однако рассмотрим возможность ее применения. Аналогично прекращению выполнения цикла оператором <KBD>break</KBD>, можно прекратить работу программы и с помощью вызова стандартной библиотечной функции <KBD>exit()</KBD>. Эта функция вызывает немедленное прекращение работы всей программы и передает управление операционной системе.
<P class="tj">Общая форма функции <KBD>exit()</KBD> следующая:
<PRE>void exit (int <I>код_возврата</I>);</PRE>
<P class="tj">Значение переменной <I>код_возврата</I> передается вызвавшему программу процессу, обычно в качестве этого процесса выступает операционная система. Нулевое значение кода возврата обычно используется для указания нормального завершения работы программы. Другие значения указывают на характер ошибки. В качестве кода возврата можно использовать макросы <KBD>EXIT_SUCCESS</KBD> и <KBD>EXIT_FAILURE</KBD> (выход успешный и выход с ошибкой). Функция <KBD>exit()</KBD> объявлена в заголовочном файле <KBD>&lt;stdlib.h&gt;</KBD>.
<P class="tj">Функция <KBD>exit()</KBD> часто используется, когда обязательное условие работы программы не выполняется. Рассмотрим, например, компьютерную игру в виртуальной реальности, использующую специальный графический адаптер. Главная функция <KBD>main()</KBD> этой игры выглядит так:
<PRE>
#include &lt;stdlib.h&gt;

int main(void)
{
   if(!virtual_graphics()) exit(1);
   play();
   /* ... */
}
/* .... */
</PRE>
<P class="tj">Здесь <KBD>virtual_graphics()</KBD> возвращает значение ИСТИНА, если присутствует нужный графический адаптер. Если требуемого адаптера нет, вызов функции <KBD>exit(1)</KBD> прекращает работу программы.
<P class="tj">В следующем примере в новой версии ранее рассмотренной функции <KBD>menu()</KBD> вызов <KBD>exit()</KBD> используется для выхода из программы и возврата в операционную систему:
<PRE>
void menu(void)
{
  char ch;

  printf("1. Проверка правописания\n");
  printf("2. Коррекция ошибок\n");
  printf("3. Вывод ошибок\n");
  printf("4. Выход\n");
  printf("      Введите Ваш выбор: ");

  do {
    ch = getchar(); /* чтение клавиши */
      switch(ch) {
        case '1':
          check_spelling();
          break;
        case '2':
          correct_errors();
          break;
        case '3':
          display_errors();
          break;
        case '4':
          exit(0); /* Возврат в ОС */
      }
    } while(ch!='1' && ch!='2' && ch!='3');
  }
</PRE>
<H2>Оператор continue</H2>
<P class="tj">Можно сказать, что оператор <KBD>continue</KBD> немного похож на <KBD>break</KBD>. Оператор <KBD>break</KBD> вызывает прерывание цикла, a <KBD>continue</KBD> — прерывание текущей итерации цикла и осуществляет переход к следующей итерации. При этом все операторы до конца тела цикла пропускаются. В цикле <KBD>for</KBD> оператор <KBD>continue</KBD> вызывает выполнение операторов приращения и проверки условия цикла. В циклах <KBD>while</KBD> и <KBD>do-while</KBD> оператор <KBD>continue</KBD> передает управление операторам проверки условий цикла. В следующем примере программа подсчитывает количество пробелов в строке, введенной пользователем:
<PRE>
/* Подсчет количества пробелов */
#include &lt;stdio.h&gt;

int main(void)
{
  char s[80], *str;
  int space;

  printf("Введите строку: ");
  gets(s);
  str = s; 

  for(space=0; *str; str++) {
    if(*str != ' ') continue;
    space++;
  }
  printf("%d пробелов\n", space);

  return 0;
}
</PRE>
<P class="tj">Каждый символ строки сравнивается с пробелом. Если сравниваемый символ не является пробелом, оператор <KBD>continue</KBD> передает управление в конец цикла <KBD>for</KBD> и выполняется следующая итерация. Если символ является пробелом, значение переменной <KBD>space</KBD> увеличивается на 1.
<P class="tj">В следующем примере оператор <KBD>continue</KBD> применяется для выхода из цикла <KBD>while</KBD> путем передачи управления на условие цикла:
<PRE>
void code(void)
{
  char done, ch;

  done = 0;
  while(!done) {
    ch = getchar();
    if(ch=='$') {
      done = 1;
      continue;
    }
    putchar(ch+1); /* печать следующего в алфавитном
                      порядке символа */
  }
}
</PRE>
<P class="tj">Функция <KBD>code</KBD> предназначена для кодирования сообщения путем замены каждого символа символом, код которого на 1 больше кода исходного символа в коде ASCII. Например, символ А заменяется символом В (если это латинские символы.). Функция прекращает работу при вводе символа <KBD>$</KBD>. При этом переменной <KBD>done</KBD> присваивается значение 1 и оператор <KBD>continue</KBD> передает управление на условие цикла, что и прекращает выполнение цикла.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Уже одно это (чрезмерная вложенность и неожиданный выход сразу из нескольких циклов) может свидетельствовать о плохой структуре программы.
</BLOCKQUOTE> 
<HR><A href="../main.htm#03">Содержание</A> | <A href="0305.htm">&lt;&lt;&lt;</A> | <A href="0307.htm">&gt;&gt;&gt;</A>
</BODY></HTML>