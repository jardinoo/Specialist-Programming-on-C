<HTML><HEAD>
<TITLE>Лестница if-else-if</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#03">Содержание</A> | <A href="0303.htm">&lt;&lt;&lt;</A> | <A href="0305.htm">&gt;&gt;&gt;</A><HR>
<H1>Лестница if-else-if</H1>
<P class="tj">В программах часто используется конструкция, которую называют <I>лестницей if-else-if</I><SUP><A href="#11" name="1">[1]</A></SUP>. Общая форма лестницы имеет вид
<PRE>
if (<I>выражение</I>) <I>оператор</I>;
else
  if (<I>выражение</I>) <I>оператор</I>;
  else
    if (<I>выражение</I>) <I>оператор</I>;
    .
    .
    .
    else <I>оператор</I>; 
</PRE>
<P class="tj">Работает эта конструкция следующим образом. Условные выражения операторов <KBD>if</KBD> вычисляются сверху вниз. После выполнения некоторого условия, т.е. когда встретится выражение, принимающее значение ИСТИНА, выполняется ассоциированный с этим выражением оператор, а оставшаяся часть лестницы пропускается. Если все условия ложны, то выполняется оператор в последней фразе <KBD>else</KBD>, а если последняя фраза <KBD>else</KBD> отсутствует, то в этом случае не выполняется ни один оператор.
<P class="tj">Недостаток предыдущей записи лестницы состоит в том, что с ростом глубины вложенности увеличивается количество отступов в строке. Это становится неудобным с технической точки зрения. Поэтому лестницу <KBD>if-else-if</KBD> обычно записывают так:
<PRE>
if (<I>выражение</I>)
  <I>оператор</I>;
else if (<I>выражение</I>)
  <I>оператор</I>;
else if (<I>выражение</I>)
  <I>оператор</I>;
    .
    .
    .
else
  <I>оператор</I>; 
</PRE>
<P class="tj">Используя лестницу <KBD>if-else-if</KBD>, программу для игры в "магическое число" можно записать так:
<PRE>
/* Магическое число, программа №4. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) 
{
  int magic; /* магическое число */
  int guess; /* попытка игрока */

  magic = rand(); /* генерация магического числа */

  printf("Угадай магическое число: ");
  scanf("%d", &guess);

  if(guess == magic) {
    printf("** Верно ** ");
    printf("Магическое число равно %d\n", magic);
  }
  else if(guess &gt; magic)
    printf("Неверно, слишкое большое");
  else printf("Неверно, слишком малое");

  return 0;
}
</PRE>
<H2>Оператор "?", альтернативный условному</H2>
<P class="tj">Оператор <KBD>?</KBD> можно использовать вместо оператора <KBD>if-else</KBD>, записанного в форме
<PRE>
if (<I>условие</I>) <I>переменная</I> = <I>выражение</I>;
else <I>переменная</I> = <I>выражение</I>;
</PRE>
<P class="tj">Оператор <KBD>?</KBD> является <I>тернарным</I>, потому что он имеет три операнда. Его общая форма следующая:
<PRE><I>Выражение1</I> ? <I>Выражение2</I> : <I>Выражение3</I>;</PRE>
<P class="tj">Обратите внимание на использование и расположение двоеточия.
<P class="tj">Результат операции <KBD>?</KBD> определяется следующим образом. Сначала вычисляется <I>Выражение1</I>. Если оно имеет значение ИСТИНА, вычисляется <I>Выражение2</I> и его значение становится результатом операции <KBD>?</KBD>. Если <I>Выражение1</I> имеет значение ЛОЖЬ, вычисляется <I>Выражение3</I> и его значение становится результатом операции <KBD>?</KBD>. Например:
<PRE>
x = 10; 
y = x&gt;9 ? 100 : 200;
</PRE>
<P class="tj">В этом примере переменной <KBD>y</KBD> присваивается значение 100. Если бы <KBD>x</KBD> было меньше 9, то переменная <KBD>у</KBD> получила бы значение 200. То же самое можно записать, используя оператор <KBD>if-else</KBD>:
<PRE>
x = 10;
if(x&gt;9) y = 100;
else y = 200;
</PRE>
<P class="tj">В следующем примере оператор <KBD>?</KBD> используется для присвоения квадрату числа знака числа. (Само число вводится пользователем.) В этой программе при возведении в квадрат фактически сохраняется знак числа. Например, если пользователь введет 10, это число будет возведено в квадрат и в результате программа напечатает 100, а если пользователь введет число -10, то оно будет возведено в квадрат и результату будет приписан знак числа; в этом случае будет напечатано -100.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int isqrd, i;

  printf("Введите число: ");
  scanf("%d", &i);

  isqrd = i&gt;0 ? i*i : -(i*i);

  printf("%d число в квадрате %d", i, isqrd);

  return 0;
}
</PRE>
<P class="tj">(Обратите внимание, что в результате выполнения данной программы могут быть напечатаны не только верные утверждения. Не всегда компьютеры печатают только правильные результаты, если даже они работают без сбоев!)
<P class="tj">Оператор <KBD>?</KBD> можно использовать вместо <KBD>if-else</KBD> не только в операторе присваивания. Как известно, все функции (за исключением имеющих тип результата <KBD>void</KBD>) возвращают значение. Следовательно, в операторе <KBD>?</KBD> можно использовать вызовы функций. Когда в выражении встречается вызов функции, она выполняется, а возвращаемое ею значение используется при вычислении выражения. Это значит, что можно выполнить одну или несколько функций путем размещения их вызовов в выражениях оператора <KBD>?</KBD> в качестве операндов. Например:
<PRE>
#include &lt;stdio.h&gt;

int f1(int n);
int f2(void);

int main(void)
{
  int t;

  printf("Введите число: ");
  scanf("%d", &t);

  /* печать соответствующего сообщения */
  t ? f1(t) + f2() : printf("Введен нуль.");
  printf("\n");

  return 0;
}

int f1(int n)
{
  printf("%d ", n);
  return 0;
}

int f2(void)
{
  printf(" введено ");
  return 0;
}
</PRE>
<P class="tj">Эта программа сначала запрашивает число. При вводе нуля вызывается функция <KBD>printf()</KBD>, выводящая на экран сообщение введен нуль. При вводе отличного от нуля числа выполняются как <KBD>f1()</KBD>, так и <KBD>f2()</KBD>. Обратите внимание на то, что значение выражения <KBD>?</KBD> в этом примере не присваивается никакой переменной, оно просто отбрасывается.
<P class="tj">Следует помнить, что компилятор, пытаясь оптимизировать объектный код, может установить любой порядок вычисления значений операндов. В данном примере это значит, что функции <KBD>f1()</KBD> и <KBD>f2()</KBD> выполняются в произвольном порядке и сообщение введено может появиться как до, так и после числа.
<P class="tj">Используя оператор <KBD>?</KBD>, программу для игры в "магическое число" можно переписать следующим образом:
<PRE>
/* Магическое число, программа №5. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  int magic; /* магическое число */
  int guess; /* попытка игрока */

  magic = rand(); /* генерация магического числа */

  printf("Угадай магическое число: ");
  scanf("%d", &guess);

  if(guess == magic) {
    printf("** Верно ** ");
    printf("Магическое число равно %d\n", magic);
  }
  else
    guess &gt; magic ? printf("Слишком большое") :
                       printf("Слишком малое");

  return 0;
} 
</PRE>
<P class="tj">В этой программе оператор <KBD>?</KBD> печатает соответствующее сообщение на основе проверки условия <KBD>guess &gt; magic</KBD>.
<H2>Условное выражение</H2>
<P class="tj">У начинающих программистов иногда возникают трудности в связи с тем, что в условном (управляющем) выражении операторов <KBD>if</KBD> или <KBD>?</KBD> могут стоять любые операторы, причем это не обязательно операторы отношения или логические (как в языках Basic или Pascal). В языке С значением результата управляющего выражения являются ИСТИНА или ЛОЖЬ, однако тип результата может быть любым скалярным типом. Считается, что любой ненулевой результат представляет значение ИСТИНА, а нулевой — ЛОЖЬ.
<P class="tj">В следующем примере программа считывает с клавиатуры два числа, вычисляет их отношение и выводит его на экран. Оператор <KBD>if</KBD> используется для того, чтобы избежать деления на нуль, если второе число равно нулю.
<PRE>
/* Деление первого числа на второе. */

#include &lt;stdio.h&gt;

int main(void)
{
  int a, b;

  printf("Введите два числа: ");
  scanf("%d%d", &a, &b);

  if(b) printf("%d\n", a/b);
  else printf("Делить на нуль нельзя.\n");

  return 0;
}
</PRE>
<P class="tj">Если управляющее выражение <KBD>b</KBD> равно 0, то его результат представляет значение ЛОЖЬ и выполняется оператор <KBD>else</KBD>. В противном случае (<KBD>b</KBD> не равно нулю) результат представляет значение ИСТИНА и выполняется деление чисел.
<P class="tj">В последнем примере оператор <KBD>if</KBD> можно записать так:
<PRE>if(b != 0) printf("%d\n", a/b);</PRE>
<P class="tj">Но следует отметить, что такая форма записи избыточна, она может привести к генерации неоптимального кода, кроме того, это считается признаком плохого стиля. Переменная <KBD>b</KBD> сама по себе представляет значение ИСТИНА или ЛОЖЬ, поэтому сравнивать ее с нулем нет необходимости.
<H2>Оператор выбора - switch</H2>
<P class="tj">Оператор выбора <KBD>switch</KBD> (часто его называют переключателем) предназначен для выбора ветви вычислительного процесса исходя из значения управляющего выражения. (При этом значение управляющего выражения сравнивается со значениями в списке целых или символьных констант. Если будет найдено совпадение, то выполнится ассоциированный с совпавшей константой оператор.) Общая форма оператора <KBD>switch</KBD> следующая:
<PRE>
switch (<I>выражение</I>) {
  case <I>постоянная1</I>:
    <I>последовательность операторов</I>
    break;
  case <I>постоянная2</I>:
    <I>последовательность операторов</I>
    break;
  case <I>постоянная3</I>:
    <I>последовательность операторов</I>
    break;
  default:
    <I>последовательность операторов</I>;
}
</PRE>
<P class="tj">Значение <I>выражения</I> оператора <KBD>switch</KBD> должно быть таким, чтобы его можно было выразить целым числом. Это означает, что в управляющем выражении можно использовать переменные целого или символьного типа, но только не с плавающей точкой. Значение управляющего <I>выражения</I> по очереди сравнивается с <I>постоянными</I> в операторах <KBD>case</KBD>. Если значение управляющего <I>выражения</I> совпадет с какой-то из <I>постоянных</I>, управление передается на соответствующую метку <KBD>case</KBD> и выполняется <I>последовательность операторов</I> до оператора <KBD>break</KBD>. Если оператор <KBD>break</KBD> отсутствует, выполнение последовательности операторов продолжается до тех пор, пока не встретится <KBD>break</KBD> (в другой метке) или не кончится тело оператора <KBD>switch</KBD> (т.е. блок, следующий за <KBD>switch</KBD>). Оператор <KBD>default</KBD> выполняется в том случае, когда значение управляющего выражения не совпало ни с одной постоянной. Оператор <KBD>default</KBD> также может отсутствовать. В этом случае при отсутствии совпадений не выполняется ни один оператор.
<P class="tj">Согласно Стандарту С89, оператор <KBD>switch</KBD> может иметь как минимум 257 операторов <KBD>case</KBD>. Стандарт С99 требует поддержки как минимум 1023 операторов <KBD>case</KBD>. Ели вы пишете программы вручную, такое большое количество операторов вам никогда не понадобится<SUP><A href="#22" name="2">[2]</A></SUP>. Оператор <KBD>case</KBD> — это метка, однако он не может быть использован сам по себе, вне оператора <KBD>switch</KBD>.
<P class="tj">Оператор <KBD>break</KBD> — это один из операторов безусловного перехода. Он может применяться не только в операторе <KBD>switch</KBD>, но и в циклах, (см. раздел "Операторы цикла"). Когда в теле оператора <KBD>switch</KBD> встречается оператор <KBD>break</KBD>, программа выходит из оператора <KBD>switch</KBD> и выполняет оператор, следующий за фигурной скобкой <KBD>}</KBD> оператора <KBD>switch</KBD>.
<P class="tj">Об операторе <KBD>switch</KBD> очень важно помнить следующее:
<UL type=square>
<LI class="t">Оператор <KBD>switch</KBD> отличается от <KBD>if</KBD> тем, что в нем управляющее выражение проверяется только на равенство с постоянными, в то время как в <KBD>if</KBD> проверя ется любой вид отношения или логического выражения.
<LI class="t">В одном и том же операторе <KBD>switch</KBD> никакие два оператора <KBD>case</KBD> не могут иметь равных постоянных. Конечно, если один <KBD>switch</KBD> вложен в другой, в их операторах <KBD>case</KBD> могут быть совпадающие постоянные.
<LI class="t">Если в управляющем выражении оператора <KBD>switch</KBD> встречаются символьные константы, они автоматически преобразуются к целому типу по принятым в языке С правилам приведения типов.
</UL>
<P class="tj">Оператор <KBD>switch</KBD> часто используется для обработки команд с клавиатуры, например, при выборе пунктов меню. В следующем примере программа выводит на экран меню проверки правописания и вызывает соответствующую процедуру:
<PRE>
void menu(void)
{
  char ch;

  printf("1. Проверка правописания\n");
  printf("2. Коррекция ошибок\n");
  printf("3. Вывод ошибок\n");
  printf("Для пропуска нажмите любую клавишу\n");
  printf("      Введите Ваш выбор: ");

  ch = getchar(); /* чтение клавиш */

  switch(ch) {
    case '1':
      check_spelling();
      break;
    case '2':
      correct_errors();
      break;
    case '3':
      display_errors();
      break;
    default :
      printf("Ни выбрана ниодна опция");
  }
} 
</PRE>
<P class="tj">С точки зрения синтаксиса, присутствие операторов <KBD>break</KBD> внутри <KBD>switch</KBD> не обязательно. Они прерывают выполнение последовательности операторов, ассоциированных с данной константой. Если оператор <KBD>break</KBD> отсутствует, то выполняется следующий оператор <KBD>case</KBD>, пока не встретится очередной <KBD>break</KBD>, или не будет достигнут конец тела оператора <KBD>switch</KBD>. Например, в функции <KBD>inp_handler()</KBD> (обработчик ввода драйвера) для упрощения программы несколько операторов <KBD>break</KBD> опущено, поэтому выполняются сразу несколько операторов <KBD>case</KBD>:
<PRE>
/* Обработка значения i */
void inp_handler(int i)
{
  int flag; 

  flag = -1; 

  switch(i) {
    case 1:  /* Эти case эти общую */
    case 2:  /* последовательность операторов. */
    case 3:
      flag = 0;
      break;
    case 4:
      flag = 1;
    case 5:
      error(flag);
      break;
    default:
      process(i);
  }
}
</PRE>
<P class="tj">Приведенный пример иллюстрирует следующие две особенности оператора <KBD>switch()</KBD>.
<P class="tj">Во-первых, оператор <KBD>case</KBD> может не иметь ассоциированной с ним последовательности операторов. Тогда управление переходит к следующему <KBD>case</KBD>. В этом примере три первых <KBD>case</KBD> вызывают выполнение одной и той же последовательности операторов, а именно:
<PRE>
flag = 0;
break;
</PRE>
<P class="tj">Во-вторых, если оператор <KBD>break</KBD> отсутствует, то выполняется последовательность операторов следующего <KBD>case</KBD>. Если <KBD>i</KBD> равно 4, то переменной <KBD>flag</KBD> присваивается значение 1 и, поскольку <KBD>break</KBD> отсутствует, выполнение продолжается и вызывается <KBD>error(flag)</KBD>. Если <KBD>i</KBD> равно 5, то <KBD>error()</KBD> будет вызвана со значением переменной <KBD>flag</KBD>, равным —1, а не 1.
<P class="tj">То, что при отсутствии <KBD>break</KBD> операторы <KBD>case</KBD> выполняются вместе, позволяет избежать ненужного дублирования операторов<SUP><A href="#33" name="3">[3]</A></SUP>.
<H2>Вложенные операторы switch</H2>
<P class="tj">Оператор <KBD>switch</KBD> может находиться в теле внешнего по отношению к нему оператора <KBD>switch</KBD>. Операторы <KBD>case</KBD> внутреннего и внешнего <KBD>switch</KBD> могут иметь одинаковые константы, в этом случае они не конфликтуют между собой. Например, следующий фрагмент программы вполне работоспособен:
<PRE>
switch(x) {
  case 1:
    switch(y) {
      case 0: printf("Деление на нуль.\n");
              break;
      case 1: process(x,y);
              break;
    }
    break;
  case 2:
    .
    .
    .
</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называется также <I>структурой выбора</I> или <I>конструкцией условного перехода</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>Если же для генерации программ вы используете макрогенераторы или генераторы компиляторов, например, уасс или lex, то на данное ограничение следует обратить внимание.
<P class="tj"><SUP><A href="#3" name="33">[3]</A></SUP>Но представляет собой опасность для забывчивых программистов.
</BLOCKQUOTE>
<HR><A href="../main.htm#03">Содержание</A> | <A href="0303.htm">&lt;&lt;&lt;</A> | <A href="0305.htm">&gt;&gt;&gt;</A>
</BODY></HTML>