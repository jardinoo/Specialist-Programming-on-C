<HTML><HEAD>
<TITLE>Оператор цикла</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#03">Содержание</A> | <A href="0304.htm">&lt;&lt;&lt;</A> | <A href="0306.htm">&gt;&gt;&gt;</A><HR>
<H1>Оператор цикла</H1>
<P class="tj">В языке С, как и в других языках программирования, операторы цикла служат для многократного выполнения последовательности операторов до тех пор, пока выполняется некоторое условие. Условие может быть установленным заранее (как в операторе <KBD>for</KBD>) или меняться при выполнении тела цикла (как в <KBD>while</KBD> или <KBD>do-while</KBD>).
<H2>Цикл for</H2>
<P class="tj">Во всех процедурных языках программирования циклы <KBD>for</KBD> очень похожи. Однако в С этот цикл особенно гибкий и мощный. Общая форма оператора <KBD>for</KBD> следующая:
<PRE>for (<I>инициализация</I>; <I>условие</I>; <I>приращение</I>) <I>оператор</I>;</PRE>
<P class="tj">Цикл <KBD>for</KBD> может иметь большое количество вариаций. В наиболее общем виде принцип его работы следующий. <I>Инициализация</I> — это присваивание начального значения переменной, которая называется параметром цикла. <I>Условие</I> представляет собой условное выражение, определяющее, следует ли выполнять <I>оператор</I> цикла (часто его называют <I>телом цикла</I>) в очередной раз. Оператор <I>приращение</I> осуществляет изменение параметра цикла при каждой итерации. Эти три оператора (они называются также <I>секциями</I> оператора <KBD>for</KBD>) обязательно разделяются точкой с запятой. Цикл <KBD>for</KBD> выполняется, если выражение <I>условие</I> принимает значение ИСТИНА. Если оно хотя бы один раз примет значение ЛОЖЬ, то программа выходит из цикла и выполняется оператор, следующий за телом цикла <KBD>for</KBD>.
<P class="tj">В следующем примере в цикле <KBD>for</KBD> выводятся на экран числа от 1 до 100:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int x; 

  for(x=1; x &lt;= 100; x++) printf("%d ", x);

  return 0;
} 
</PRE>
<P class="tj">В этом примере параметр цикла <KBD>х</KBD> инициализирован числом 1, а затем при каждой итерации сравнивается с числом 100. Пока переменная <KBD>х</KBD> меньше 100, вызывается функция <KBD>printf()</KBD> и цикл повторяется. При этом <KBD>х</KBD> увеличивается на 1 и опять проверяется условие цикла <KBD>х &lt;= 100</KBD>. Процесс повторяется, пока переменная <KBD>х</KBD> не станет больше 100. После этого процесс выходит из цикла, а управление передается оператору, следующему за ним. В этом примере параметром цикла является переменная <KBD>х</KBD>, при каждой итерации она изменяется и проверяется в секции условия цикла.
<P class="tj">В следующем примере в цикле <KBD>for</KBD> выполняется блок операторов:
<PRE>
for(x=100; x != 65; x -= 5) {
  z = x*x;
  printf("Квадрат %d равен %d", x, z);
}
</PRE>
<P class="tj">Операции возведения переменной <KBD>х</KBD> в квадрат и вызова функции <KBD>printf()</KBD> повторяются, пока <KBD>х</KBD> не примет значение 65. Обратите внимание на то, что здесь параметр цикла уменьшается, он инициализирован числом 100 и уменьшается на 5 при каждой итерации.
<P class="tj">В операторе <KBD>for</KBD> условие цикла всегда проверяется перед началом итерации. Это значит, что операторы цикла могут не выполняться ни разу, если перед первой итерацией условие примет значение ЛОЖЬ. Например, в следующем фрагменте программы
<PRE>
x = 10;
for(y=10; y!=x; ++y) printf("%d", y);
printf("%d", y);  /* Это единственный printf()
                     который будет выполнен */
</PRE>
<P class="t">цикл не выполнится ни разу, потому что при входе в цикл значения переменных <KBD>х</KBD> и <KBD>у</KBD> равны. Поэтому условие цикла принимает значение ЛОЖЬ, а тело цикла и оператор приращение не выполняются. Переменная <KBD>у</KBD> остается равной 10, единственный результат работы этой программы — вывод на экран числа 10 в результате вызова функции <KBD>printf()</KBD>, расположенной вне цикла.
<H2>Варианты цикла for</H2>
<P class="tj">В предыдущем разделе рассмотрена наиболее общая форма цикла <KBD>for</KBD>. Однако в языке С допускаются некоторые его варианты, позволяющие во многих случаях увеличить мощность и гибкость программы.
<P class="tj">Один из распространенных способов усиления мощности цикла <KBD>for</KBD> — применение оператора "запятая" для создания двух параметров цикла. Оператор "запятая" связывает несколько выражений, заставляя их выполняться вместе (см. <A href="../02/02.htm">главу 2</A>). В следующем примере обе переменные (<KBD>х</KBD> и <KBD>у</KBD>) являются параметрами цикла <KBD>for</KBD> и обе инициализируются в этом цикле:
<PRE>
for(x=0, y=0; x+y&lt;10; ++x) {
  y = getchar();
  y = y - '0'; /* Вычитание из y ASCII-кода нуля */
    .
    .
    .
}
</PRE>
<P class="tj">Здесь запятая разделяет два оператора инициализации. При каждой итерации значение переменной <KBD>х</KBD> увеличивается, а значение <KBD>у</KBD> вводится с клавиатуры. Для выполнения итерации как <KBD>х</KBD>, так и <KBD>у</KBD> должны иметь определенное значение. Несмотря на то что значение <KBD>у</KBD> вводится с клавиатуры, оно должно быть инициализировано таким образом, чтобы выполнилось условие цикла при первой итерации. Если <KBD>у</KBD> не инициализировать, то оно может случайно оказаться таким, что условие цикла примет значение ЛОЖЬ, тело цикла не будет выполнено ни разу.
<P class="tj">Следующий пример демонстрирует использование двух параметров цикла. Функция <KBD>converge()</KBD> копирует содержимое одной строки в другую, начиная с обоих концов строки и кончая в ее середине.
<PRE>
/* Демонстрация использования 2-х параметров цикла. */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void converge(char *targ, char *src);

int main(void)
{
  char target[80] = "XXXXXXXXXXXXXXXXXXXXXXXXXXXXX";

  converge(target, "Это проверка функции converge().");
  printf("Строка-результат: %s\n", target);

  return 0;
} 

/* Эта функция копирует содержимое одной строки в
   другую, начиная с обоих концов и сходясь посередине. */
void converge(char *targ, char *src)
{
  int i, j; 

  printf("%s\n", targ);
  for(i=0, j=strlen(src); i&lt;=j; i++, j--) {
    targ[i] = src[i];
    targ[j] = src[j];
    printf("%s\n", targ);
  }
}
</PRE>
<P class="tj">Программа выводит на экран следующее:
<PRE>
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
ЭXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
ЭтХХХХХХХХХХХХХХХХХХХХХХХХХХХХХ.
ЭтоХХХХХХХХХХХХХХХХХХХХХХХХХХХ).
Это ХХХХХХХХХХХХХХХХХХХХХХХХХ().
Это пХХХХХХХХХХХХХХХХХХХХХХХe().
Это прХХХХХХХХХХХХХХХХХХХХХge().
Это проХХХХХХХХХХХХХХХХХХХrge().
Это провХХХХХХХХХХХХХХХХХerge().
Это провeXXXXXXXXXXXXXXXverge().
Это провepXXXXXXXXXXXXXnverge().
Это провepKXXXXXXXXXXXonverge().
Это провepкaXXXXXXXXXconverge().
Это проверка ХХХХХХХ converge().
Это проверка фХХХХХи converge().
Это проверка фуХХХии converge().
Это проверка фунХции converge().
Это проверка функции converge().
Строка-результат: Это проверка функции converge().
</PRE>
<P class="tj">В функции <KBD>convergence()</KBD> цикл <KBD>for</KBD> использует два параметра цикла (<KBD>i</KBD> и <KBD>j</KBD>) для индексации строки с противоположных концов. Параметр <KBD>i</KBD> в цикле увеличивается, а <KBD>j</KBD> — уменьшается. Итерации прекращаются, когда <KBD>i</KBD> становится больше <KBD>j</KBD>. Это обеспечивает копирование всех символов.
<P class="tj">Проверка параметра цикла на соответствие некоторому условию не обязательна. Условие может быть любым логическим оператором или оператором отношения. Это значит, что условие выполнения цикла может состоять из нескольких условий, или операторов отношения. Следующий пример демонстрирует применение составного условия цикла для проверки пароля, вводимого пользователем. Пользователю предоставляются три попытки ввода пароля. Программа выходит из цикла, когда использованы все три попытки или когда введен верный пароль.
<PRE>
void sign_on(void)
{
  char str[20];
  int x;

  for(x=0; x&lt;3 && strcmp(str, "password"); ++x) {
    printf("Пожалуйста, введите пароль:");
    gets(str);
  }

  if(x==3) return;
  /* Иначе пользователь допускается */
}
</PRE>
<P class="tj">Функция <KBD>sign_on()</KBD> использует стандартную библиотечную функцию <KBD>strcmp()</KBD>, которая сравнивает две строки и возвращает 0, если они совпадают.
<P class="tj">Следует помнить, что каждая из трех секций оператора <KBD>for</KBD> может быть любым синтаксически правильным выражением. Эти выражения не всегда каким-либо образом отображают назначение секции. Рассмотрим следующий пример:
<PRE>
#include &lt;stdio.h&gt;

int sqrnum(int num);
int readnum(void);
int prompt(void);

int main(void)
{
  int t;

  for(prompt(); t=readnum(); prompt())
    sqrnum(t);

  return 0;
} 

int prompt(void) 
{
  printf("Введите число: ");
  return 0;
} 

int readnum(void)
{
  int t;

  scanf("%d", &t);
  return t;
}

int sqrnum(int num)
{
  printf("%d\n", num*num);
  return num*num;
}
</PRE>
<P class="tj">Здесь в <KBD>main()</KBD> каждая секция цикла <KBD>for</KBD> состоит из вызовов функций, которые предлагают пользователю ввести число и считывают его. Если пользователь ввел 0, то цикл прекращается, потому что тогда условие цикла принимает значение ЛОЖЬ. В противном случае число возводится в квадрат. Таким образом, в этом примере цикла <KBD>for</KBD> секции инициализации и приращения используются весьма необычно, но совершенно правильно.
<P class="tj">Другая интересная особенность цикла <KBD>for</KBD> состоит в том, что его секции могут быть вообще пустыми, присутствие в них какого-либо выражения не обязательно. В следующем примере цикл выполняется, пока пользователь не введет число 123:
<PRE>
for(x=0; x!=123; ) scanf("%d", &x);
</PRE>
<P class="tj">Секция приращения оператора <KBD>for</KBD> здесь оставлена пустой. Это значит, что перед каждой итерацией значение переменной <KBD>х</KBD> проверяется на неравенство числу 123, а приращения не происходит, оно здесь ненужно. Если с клавиатуры ввести число 123, то условие принимает значение ЛОЖЬ и программа выходит из цикла.
<P class="tj">Инициализацию параметра цикла <KBD>for</KBD> можно сделать за пределами этого цикла, но, конечно, до него. Это особенно уместно, если начальное значение параметра цикла вычисляется достаточно сложно, например:
<PRE>
gets(s);  /* читает строку в s */
if(*s) x = strlen(s); /* вычисление длины строки */
else x = 10;

for( ; x&lt;10; ) {
  printf("%d", x);
  ++x;
}
</PRE>
<P class="tj">В этом примере секция инициализации оставлена пустой, а переменная <KBD>х</KBD> инициализируется до входа в цикл.
<H2>Бесконечный цикл</H2>
<P class="tj">Для создания бесконечного цикла можно использовать любой оператор цикла, но чаще всего для этого выбирают оператор <KBD>for</KBD>. Так как в операторе <KBD>for</KBD> может отсутствовать любая секция, бесконечный цикл проще всего сделать, оставив пустыми все секции. Это хорошо показано в следующем примере:
<PRE>
for( ; ; ) printf("Этот цикл крутится бесконечно.\n");
</PRE>
<P class="tj">Если условие цикла <KBD>for</KBD> отсутствует, то предполагается, что его значение — ИСТИНА. В оператор <KBD>for</KBD> можно добавить выражения инициализации и приращения, хотя обычно для создания бесконечного цикла используют конструкцию <KBD>for( ; ; )</KBD>.
<P class="tj">Фактически конструкция <KBD>for( ; ; )</KBD> не гарантирует бесконечность итераций, потому что в нем может встретиться оператор <KBD>break</KBD>, вызывающий немедленный выход из цикла. (Подробно оператор <KBD>break</KBD> рассмотрен в этой главе далее.) В этом случае выполнение программы продолжается с оператора, следующего за закрывающейся фигурной скобкой цикла <KBD>for</KBD>:
<PRE>
ch = '\0'; 

for( ; ; ) {
  ch = getchar(); /* считывание символа */
  if(ch=='A') break; /* выход из цикла */
} 

printf("Вы напечатали 'A'");
</PRE>
<P class="tj">В данном примере цикл выполняется до тех пор, пока пользователь не введет с клавиатуры символ <KBD>А</KBD>.
<H2>Цикл for без тела цикла</H2>
<P class="tj">Следует учесть, что оператор может быть пустым. Это значит, что тело цикла <KBD>for</KBD> (или любого другого цикла) также может быть пустым. Такую особенность цикла <KBD>for</KBD> можно использовать для упрощения некоторых программ, а также в циклах, предназначенных для того, чтобы отложить выполнение последующей части программы на некоторое время.
<P class="tj">Программисту иногда приходится решать задачу удаления пробелов из входного потока. Допустим, программа, работающая с базой данных, обрабатывает запрос "показать все балансы меньше 400". База данных требует представления каждого слова отдельно, без пробелов, т.е. обработчик распознает слово "показать", но не " показать". В следующем примере цикл <KBD>for</KBD> удаляет начальные пробелы в строке <KBD>str</KBD>:
<PRE>for( ; *str == ' '; str++) ;</PRE>
<P class="tj">В этом примере указатель <KBD>str</KBD> переставляется на первый символ,  не являющийся пробелом. Цикл не имеет тела, так как в нем нет необходимости.<SUP><A href="#11" name="1">[1]</A></SUP>
<P class="tj">Иногда возникает необходимость отложить выполнение  последующей  части программы на определенное время.  Это можно сделать с помощью цикла <KBD>for</KBD> следующим образом:
<PRE>for(t=0; t&lt;SOME_VALUE; t++) ;</PRE>
<P class="tj">Единственное назначение этого цикла — задержка выполнения последующей части программы. Однако следует иметь в виду, что компилятор может оптимизировать объектный код таким образом, что пропустит этот цикл вообще, поскольку он не выполняет никаких действий, тогда желаемой задержки выполнения последующей части программы не произойдет.
<H2>Объявление переменных внутри цикла</H2>
<P class="tj">В стандартах С99 и C++ (но не С89!) допускается объявление переменных в секции инициализации цикла <KBD>for</KBD>. Объявленная таким образом переменная является локальной переменной цикла и ее область действия распространяется на тело цикла.
<P class="tj">Рассмотрим следующий пример:
<PRE>
/* 
    Здесь переменная i является локальной
    переменной цикла, а j видима вне цикла.

    *** Этот пример в C89 неправильный. ***
*/
int j; 
for(int i = 0; i&lt;10; i++)
  j = i * i;

/* i = 10;
Это ошибка, переменная i здесь недоступна! */
</PRE>
<P class="tj">В данном примере переменная <KBD>i</KBD> объявлена в секции инициализации цикла <KBD>for</KBD> и служит параметром цикла. Вне цикла переменная <KBD>i</KBD> невидима.
<P class="tj">Поскольку параметр цикла чаше всего необходим только внутри цикла, его объявление в секции инициализации очень удобно и входит в широкую практику<SUP><A href="#22" name="2">[2]</A></SUP>. Однако необходимо помнить, что это не поддерживается стандартом С89.
<H2>Цикл while</H2>
<P class="tj">Обшая форма цикла <KBD>while</KBD> имеет следующий вид:
<PRE>while (<I>условие</I>) <I>оператор</I>;</PRE>
<P class="tj">Здесь <I>оператор</I> (тело цикла) может быть пустым оператором, единственным оператором или блоком. <I>Условие</I> (управляющее выражение) может быть любым допустимым в языке выражением. <I>Условие</I> считается истинным, если значение выражения не равно нулю, а <I>оператор</I> выполняется, если условие принимает значение ИСТИНА. Если условие принимает значение ЛОЖЬ, программа выходит из цикла и выполняется следующий за циклом оператор.
<P class="tj">В следующем примере ввод с клавиатуры происходит до тех пор, пока пользователь не введет символ <KBD>А</KBD>:
<PRE>
char wait_for_char(void)
{
  char ch; 

  ch = '\0';  /* инициализация ch */
  while(ch != 'A') ch = getchar();
  return ch;
}
</PRE>
<P class="tj">Переменная <KBD>ch</KBD> является локальной, ее значение при входе в функцию произвольно, поэтому сначала значение <KBD>ch</KBD> инициализируется нулем. Условие цикла <KBD>while</KBD> истинно, если <KBD>ch</KBD> не равно <KBD>А</KBD>. Поскольку <KBD>ch</KBD> инициализировано нулем, условие истинно и цикл начинает выполняться. Условие проверяется при каждом нажатии клавиши пользователем. При вводе символа <KBD>А</KBD> условие становится ложным и выполнение цикла прекращается.
<P class="tj">Как и в цикле <KBD>for</KBD>, в цикле <KBD>while</KBD> условие проверяется перед началом итерации. Это значит, что если условие ложно, тело цикла не будет выполнено. Благодаря этому нет необходимости вводить в программу отдельное условие перед циклом. Рассмотрим это на примере функции <KBD>pad()</KBD>, которая добавляет пробелы в конец строки и делает ее длину равной предварительно заданной величине. Если строка уже имеет необходимую длину, то пробелы не добавляются:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void pad(char *s, int length);

int main(void)
{
  char str[80];

  strcpy(str, "это проверка");
  pad(str, 40);
  printf("%d", strlen(str));

  return 0;
} 

/* Добавление пробелов в конец строки. */
void pad(char *s, int length)
{
  int l;

  l = strlen(s); /* опредление длины строки */

  while(l&lt;length) {
    s[l] = ' '; /* вставка пробелов */
    l++;
  }
  s[l]= '\0'; /* строка должна заканиваться нулем */
}
</PRE>
<P class="tj">Аргументами функции <KBD>pad()</KBD> являются <KBD>s</KBD> (указатель на исходную строку) и <KBD>length</KBD> (требуемое количество символов в строке). Если длина строки <KBD>s</KBD> при входе в функцию равна или больше <KBD>length</KBD>, то цикл <KBD>while</KBD> не выполняется. В противном случае <KBD>pad()</KBD> добавляет требуемое количество пробелов, а библиотечная функция <KBD>strlen()</KBD> возвращает длину строки.
<P class="tj">Если выполнение цикла должно зависеть от нескольких условий, можно создать так называемую управляющую переменную, значения которой присваиваются разными операторами тела цикла. Рассмотрим следующий пример:
<PRE>
void func1(void)
{
  int working;

  working = 1; /* т.е. ИСТИНА */

  while(working) {
    working = process1();
    if(working)
      working = process2();
    if(working)
      working = process3();
  }
}
</PRE>
<P class="tj">В этом примере переменная <KBD>working</KBD> является управляющей. Любая из трех функций может возвратить значение 0 и этим прервать выполнение цикла. Тело цикла <KBD>while</KBD> может быть пустым. Например, цикл
<PRE>while((ch=getchar()) != 'A') ;</PRE>
<P class="t">выполняется до тех пор, пока пользователь не введет символ 'А'. Напоминаем, что оператор присваивания выполняет две задачи: присваивает значение выражения справа переменной слева и возвращает это значение как свое собственное.
<H2>Цикл do-while</H2>
<P class="tj">В отличие от циклов <KBD>for</KBD> и <KBD>while</KBD>, которые проверяют свое условие перед итерацией, <KBD>do-while</KBD> делает это после нее. Поэтому цикл <KBD>do-while</KBD> всегда выполняется как минимум один раз. Общая форма цикла <KBD>do-while</KBD> следующая:
<PRE>
do {
<I>оператор</I>;
} while (<I>условие</I>);
</PRE>
<P class="tj">Если оператор не является блоком, фигурные скобки не обязательны, но их почти всегда ставят, чтобы оператор достаточно наглядно отделялся от условия. Итерации оператора <KBD>do-while</KBD> выполняются, пока условие не примет значение ЛОЖЬ.
<P class="tj">В следующем примере в цикле <KBD>do-while</KBD> числа считываются с клавиатуры, пока не встретится число, меньшее или равное 100:
<PRE>
do {
  scanf("%d", &num);
} while(num &gt; 100);
</PRE>
<P class="tj">Цикл <KBD>do-while</KBD> часто используется в функциях выбора пунктов меню. Если пользователь вводит допустимое значение, оно возвращается в качестве значения функции. В противном случае цикл требует повторить ввод. Следующий пример демонстрирует усовершенствованную версию программы для выбора пункта меню проверки грамматики:
<PRE>
void menu(void)
{
  char ch;

  printf("1. Проверка правописания\n");
  printf("2. Коррекция ошибок\n");
  printf("3. Вывод ошибок\n");
  printf("      Введите Ваш выбор: ");

  do {
    ch = getchar(); /* чтение выбора с клавиатуры */
    switch(ch) {
      case '1':
        check_spelling();
        break;
      case '2':
        correct_errors();
        break;
      case '3':
        display_errors();
        break;
    }
  } while(ch!='1' && ch!='2' && ch!='3');
}
</PRE>
<P class="tj">В этом примере применение цикла <KBD>do-while</KBD> весьма уместно, потому что итерация, как уже упоминалось, всегда должна выполниться как минимум один раз. Цикл повторяется, пока его условие не станет ложным, т.е. пока пользователь не введет один из допустимых ответов.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Этот пример, конечно, учебный. На практике так поступать со строкой не рекомендуется, потому что начало строки <KBD>str</KBD>, "напрасно висящее" в памяти, впоследствии может создать некоторые трудности. Например, если вы захотите освободить память, занимаемую данной строкой, вам потребуется указать на начало строки, а не на первый отличный от пробела символ в этой строке.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>В некоторых языках (например АЛГОЛ 68) локализация параметра цикла выполняется автоматически.
</BLOCKQUOTE>
<HR><A href="../main.htm#03">Содержание</A> | <A href="0304.htm">&lt;&lt;&lt;</A> | <A href="0306.htm">&gt;&gt;&gt;</A>
</BODY></HTML>