<HTML><HEAD>
<TITLE>Основы файловой системы</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#09">Содержание</A> | <A href="0903.htm">&lt;&lt;&lt;</A> | <A href="0905.htm">&gt;&gt;&gt;</A><HR>
<H1>Основы файловой системы</H1>
<P class="tj">Файловая система языка С состоит из нескольких взаимосвязанных функций. Самые распространенные из них показаны в табл. 9.1. Для их работы требуется заголовок <KBD>&lt;stdio.h&gt;</KBD>.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 9.1. Часто используемые функции файловой системы С</B></CAPTION>
<TR><TH><I>Имя</I><TH><I>Что делает</I>
<TR><TD><KBD>fopen()</KBD><TD class="t">Открывает файл
<TR><TD><KBD>fclose()</KBD><TD class="t">Закрывает файл
<TR><TD><KBD>putc()</KBD><TD class="t">Записывает символ в файл
<TR><TD><KBD>fputc()</KBD><TD class="t">To же, что и <KBD>putc()</KBD>
<TR><TD><KBD>getc()</KBD><TD class="t">Читает символ из файла
<TR><TD><KBD>fgetc()</KBD><TD class="t">To же, что и <KBD>getc()</KBD>
<TR><TD><KBD>fgets()</KBD><TD class="t">Читает строку из файла
<TR><TD><KBD>fputs()</KBD><TD class="t">Записывает строку в файл
<TR><TD><KBD>fseek()</KBD><TD class="t">Устанавливает указатель текущей позиции на определенный байт файла
<TR><TD><KBD>ftell()</KBD><TD class="t">Возвращает текущее значение указателя текущей позиции в файле
<TR><TD><KBD>fprintf()</KBD><TD class="t">Для файла то же, что <KBD>printf()</KBD> для консоли
<TR><TD><KBD>fscanf()</KBD><TD class="t">Для файла то же, что <KBD>scanf()</KBD> для консоли
<TR><TD><KBD>feof()</KBD><TD class="t">Возвращает значение true (истина), если достигнут конец файла
<TR><TD><KBD>ferror()</KBD><TD class="t">Возвращает значение true, если произошла ошибка
<TR><TD><KBD>rewind()</KBD><TD class="t">Устанавливает указатель текущей позиции в начало файла
<TR><TD><KBD>remove()</KBD><TD class="t">Стирает файл
<TR><TD><KBD>fflush()</KBD><TD class="t">Дозапись потока в файл
</TABLE>
<P class="tj">Заголовок <KBD>&lt;stdio.h&gt;</KBD> предоставляет прототипы функций ввода/вывода и определяет следующие три типа: <KBD>size_t</KBD>, <KBD>fpos_t</KBD> и <KBD>FILE</KBD>. <KBD>size_t</KBD> и <KBD>fpos_t</KBD> представляют собой определенные разновидности такого типа, как целое без знака. А о третьем типе, <KBD>FILE</KBD>, рассказывается в следующем разделе.
<P class="tj">Кроме того, в <KBD>&lt;stdio.h&gt;</KBD> определяется несколько макросов. Из них к материалу этой главы относятся <KBD>NULL</KBD>, <KBD>EOF</KBD>, <KBD>FOPEN_MAX</KBD>, <KBD>SEEK_SET</KBD>, <KBD>SEEK_CUR</KBD> и <KBD>SEEK_END</KBD>. Макрос <KBD>NULL</KBD> определяет пустой (null) указатель. Макрос <KBD>EOF</KBD>, часто определяемый как -1, является значением, возвращаемым тогда, когда функция ввода пытается выполнить чтение после конца файла. <KBD>FOPEN_MAX</KBD> определяет целое значение, равное максимальному числу одновременно открытых файлов. Другие макросы используются вместе с <KBD>fseek()</KBD> — функцией, выполняющей операции прямого доступа к файлу.
<H2>Указатель файла</H2>
<P class="tj">Указатель файла — это то, что соединяет в единое целое всю систему ввода/вывода языка С. <I>Указатель файла</I> — это указатель на структуру типа <KBD>FILE</KBD>. Он указывает на структуру, содержащую различные сведения о файле, например, его имя, статус и указатель текущей позиции в начало файла. В сущности, указатель файла определяет конкретный файл и используется соответствующим потоком при выполнении функций ввода/вывода. Чтобы выполнять в файлах операции чтения и записи, программы должны использовать указатели соответствующих файлов. Чтобы объявить переменную-указатель файла, используйте такого рода оператор:
<PRE>FILE *fp;</PRE>
<H2>Открытие файла</H2>
<P class="tj">Функция <KBD>fopen()</KBD> открывает поток и связывает с этим потоком определенный файл. Затем она возвращает указатель этого файла. Чаще всего (а также в оставшейся части этой главы) под файлом подразумевается дисковый файл. Прототип функции <KBD>fopen()</KBD> такой:
<PRE>FILE *fopen(const char *<I>имя_файла</I>, const char *<I>режим</I>);</PRE>
<P class="t">где <I>имя_файла</I> — это указатель на строку символов, представляющую собой допустимое имя файла, в которое также может входить спецификация пути к этому файлу. Строка, на которую указывает <I>режим</I>, определяет, каким образом файл будет открыт. В табл. 9.2 показано, какие значения строки <I>режим</I> являются допустимыми. Строки, подобные "r+b" могут быть представлены и в виде "rb+".</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 9.2. Допустимые значения режим</B></CAPTION>
<TR><TH><I>Режим</I><TH><I>Что означает</I>
<TR><TD>r<TD class="t">Открыть текстовый файл для чтения
<TR><TD>w<TD class="t">Создать текстовый файл для записи
<TR><TD>a<TD class="t">Добавить в конец текстового файла
<TR><TD>rb<TD class="t">Открыть двоичный файл для чтения
<TR><TD>wb<TD class="t">Создать двоичный файл для записи
<TR><TD>ab<TD class="t">Добавить в конец двоичного файла
<TR><TD>r+<TD class="t">Открыть текстовый файл для чтения/записи
<TR><TD>w+<TD class="t">Создать текстовый файл для чтения/записи
<TR><TD>a+<TD class="t">Добавить  в конец текстового файла или создать текстовый файл для  чтения/записи
<TR><TD>r+b<TD class="t">Открыть двоичный файл для чтения/записи
<TR><TD>w+b<TD class="t">Создать двоичный файл для чтения/записи
<TR><TD>a+b<TD class="t">Добавить в конец двоичного файла или создать двоичный файл для чтения/записи
</TABLE>
<P class="tj">Как уже упоминалось, функция <KBD>fopen()</KBD> возвращает указатель файла. Никогда не следует изменять значение этого указателя в программе. Если при открытии файла происходит ошибка, то <KBD>fopen()</KBD> возвращает пустой (null) указатель.
<P class="tj">В следующем коде функция <KBD>fopen()</KBD> используется для открытия файла по имени TEST для записи.
<PRE>
FILE *fp;
fp = fopen("test", "w");
</PRE>
<P class="tj">Хотя предыдущий код технически правильный, но его обычно пишут немного по-другому:
<PRE>
FILE *fp;

if ((fp = fopen("test","w"))==NULL) {
  printf("Ошибка при открытии файла.\n");
  exit(1);
}
</PRE>
<P class="tj">Этот метод помогает при открытии файла обнаружить любую ошибку, например, защиту от записи или полный диск, причем обнаружить еще до того, как программа попытается в этот файл что-либо записать. Вообще говоря, всегда нужно вначале получить подтверждение, что функция - <KBD>fopen()</KBD> выполнилась успешно, и лишь затем выполнять с файлом другие операции.
<P class="tj">Хотя название большинства файловых режимов объясняет их смысл, однако не помешает сделать некоторые дополнения. Если попытаться открыть файл только для чтения, а он не существует, то работа <KBD>fopen()</KBD> завершится отказом. А если попытаться открыть файл в режиме дозаписи, а сам этот файл не существует, то он просто будет создан. Более того, если файл открыт в режиме дозаписи, то все новые данные, которые записываются в него, будут добавляться в конец файла. Содержимое, которое хранилось в нем до открытия (если только оно было), изменено не будет. Далее, если файл открывают для записи, но выясняется, что он не существует, то он будет создан. А если он существует, то содержимое, которое хранилось в нем до открытия, будет утеряно, причем будет создан новый файл. Разница между режимами <KBD>r+</KBD> и <KBD>w+</KBD> состоит в том, что если файл не существует, то в режиме открытия <KBD>r+</KBD> он создан не будет, а в режиме <KBD>w+</KBD> все произойдет наоборот: файл будет создан! Более того, если файл уже существует, то открытие его в режиме <KBD>w+</KBD> приведет к утрате его содержимого, а в режиме <KBD>r+</KBD> оно останется нетронутым.
<P class="tj">Из табл. 9.2 видно, что файл можно открыть либо в одном из текстовых, либо в одном из двоичных режимов. В большинстве реализаций в текстовых режимах каждая комбинация кодов возврата каретки (ASCII 13) и конца строки (ASCII 10) преобразуется при вводе в символ новой строки. При выводе же происходит обратный процесс: символы новой строки преобразуются в комбинацию кодов возврата каретки (ASCII 13) и конца строки (ASCII 10). В двоичных режимах такие преобразования не выполняются.
<P class="tj">Максимальное число одновременно открытых файлов определяется FOPEN_MAX. Это значение не меньше 8, но чему оно точно равняется — это должно быть написано в документации по компилятору.
<H2>Закрытие файла</H2>
<P class="tj">Функция <KBD>fclose()</KBD> закрывает поток, который был открыт с помощью вызова <KBD>fopen()</KBD>.Функция <KBD>fclose()</KBD> записывает в файл все данные, которые еще оставались в дисковом буфере, и проводит, так сказать, официальное закрытие файла на уровне операционной системы. Отказ при закрытии потока влечет всевозможные неприятности, включая потерю данных, испорченные файлы и возможные периодические ошибки в программе. Функция <KBD>fclose()</KBD> также освобождает блок управления файлом, связанный с этим потоком, давая возможность использовать этот блок снова. Так как количество одновременно открытых файлов ограничено, то, возможно, придется закрывать один файл, прежде чем открывать другой. Прототип функции <KBD>fclose()</KBD> такой:
<PRE>int fclose(FILE *<I>уф</I>);</PRE>
<P class="t">где <I>уф</I> — указатель файла, возвращенный в результате вызова <KBD>fopen()</KBD>. Возвращение нуля означает успешную операцию закрытия. В случае же ошибки возвращается <KBD>EOF</KBD>. Чтобы точно узнать, в чем причина этой ошибки, можно использовать стандартную функцию <KBD>ferror()</KBD> (о которой вскоре пойдет речь). Обычно отказ при выполнении <KBD>fclose()</KBD> происходит только тогда, когда диск был преждевременно удален (стерт) с дисковода или на диске не осталось свободного места.
<H2>Запись символа</H2>
<P class="tj">В системе ввода/вывода языка С определяются две эквивалентные функции, предназначенные для вывода символов: <KBD>putc()</KBD> и <KBD>fputc()</KBD>. (На самом деле <KBD>putc()</KBD> обычно реализуется в виде макроса.) Две идентичные функции имеются просто потому, чтобы сохранять совместимость со старыми версиями С. В этой книге используется <KBD>putc()</KBD>, но применение <KBD>fputc()</KBD> также вполне возможно.
<P class="tj">Функция <KBD>putc()</KBD> записывает символы в файл, который с помощью <KBD>fopen()</KBD> уже открыт в режиме записи. Прототип этой функции следующий:
<PRE>int putc(int <I>ch</I>, FILE *<I>уф</I>);</PRE>
<P class="t">где <I>уф</I> — это указатель файла, возвращенный функцией <KBD>fopen()</KBD>, a <I>ch</I> — выводимый символ. Указатель файла сообщает <KBD>putc()</KBD>, в какой именно файл следует записывать символ. Хотя <I>ch</I> и определяется как <KBD>int</KBD>, однако записывается только младший байт.
<P class="tj">Если функция <KBD>putc()</KBD> выполнилась успешно, то возвращается записанный символ. В противном же случае возвращается <KBD>EOF</KBD>.
<H2>Чтение символа</H2>
<P class="tj">Для ввода символа также имеются две эквивалентные функции: <KBD>getc()</KBD> и <KBD>fgetc()</KBD>. Обе определяются для сохранения совместимости со старыми версиями С. В этой книге используется <KBD>getc()</KBD> (которая обычно реализуется в виде макроса), но если хотите, применяйте <KBD>fgetc()</KBD>.
<P class="tj">Функция <KBD>getc()</KBD> записывает символы в файл, который с помощью <KBD>fopen()</KBD> уже открыт в режиме для чтения. Прототип этой функции следующий:
<PRE>int getc(FILE *<I>уф</I>);</PRE>
<P class="t">где <I>уф</I> — это указатель файла, имеющий тип <KBD>FILE</KBD> и возвращенный функцией <KBD>fopen()</KBD>. Функция <KBD>getc()</KBD> возвращает целое значение, но символ находится в младшем байте. Если не произошла ошибка, то старший байт (байты) будет обнулен.
<P class="tj">Если достигнут конец файла, то функция <KBD>getc()</KBD> возвращает <KBD>EOF</KBD>. Поэтому, чтобы прочитать символы до конца текстового файла, можно использовать следующий код;
<PRE>
do {
  ch = getc(fp);
} while(ch!=EOF);
</PRE>
<P class="tj">Однако <KBD>getc()</KBD> возвращает <KBD>EOF</KBD> и в случае ошибки. Для определения того, что же на самом деле произошло, можно использовать <KBD>ferror()</KBD>.
<H2>Использование fopen(), getc(), putc(), и fclose()</H2>
<P class="tj">Функции <KBD>fopen()</KBD>, <KBD>getc()</KBD>, <KBD>putc()</KBD> и <KBD>fclose()</KBD> — это минимальный набор функций для операций с файлами. Следующая программа, KTOD, представляет собой простой пример, в котором используются только функции <KBD>putc()</KBD>, <KBD>fopen()</KBD> и <KBD>fclose()</KBD>. В этой программе символы считываются с клавиатуры и записываются в дисковый файл до тех пор, пока пользователь не введет знак доллара. Имя файла определяется в командной строке. Например, если вызвать программу KTOD, введя в командной строке <KBD>KTOD TEST</KBD>, то строки текста будут вводиться в файл TEST.
<PRE>
/* KTOD: программа ввода с клавиатуры на диск. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if(argc!=2) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }

  if((fp=fopen(argv[1], "w"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }

  do {
    ch = getchar();
    putc(ch, fp);
  } while (ch != '$');

  fclose(fp);

  return 0;
}
</PRE>
<P class="tj">Программа DTOS, являющаяся дополнением к программе KTOD, читает любой текстовый файл и выводит его содержимое на экран.
<PRE>
/* DTOS: программа, которая читает файлы
         и выводит их на экран. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;

  if(argc!=2) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }

  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }

  ch = getc(fp);   /* чтение одного символа */

  while (ch!=EOF) {
    putchar(ch);  /* вывод на экран */
    ch = getc(fp);
  }

  fclose(fp);

  return 0;
}
</PRE>
<P class="tj">Испытывая эти две программы, вначале с помошью KTOD создайте текстовый файл, а затем с помошью DTOS прочитайте его содержимое.
<H2>Использование feof()</H2>
<P class="tj">Как уже говорилось, если достигнут конец файла, то <KBD>getc()</KBD> возвращает <KBD>EOF</KBD>. Однако проверка значения, возвращенного <KBD>getc()</KBD>, возможно, не является наилучшим способом узнать, достигнут ли конец файла. Во-первых, файловая система языка С может работать как с текстовыми, так и с двоичными файлами. Когда файл открывается для двоичного ввода, то может быть прочитано целое значение, которое, как выяснится при проверке, равняется <KBD>EOF</KBD>. В таком случае программа ввода сообщит о том, что достигнут конец файла, чего на самом деле может и не быть. Во-вторых, функция <KBD>getc()</KBD> возвращает <KBD>EOF</KBD> и в случае отказа, а не только тогда, когда достигнут конец файла. Если использовать только возвращаемое значение <KBD>getc()</KBD>, то невозможно определить, что же на самом деле произошло. Для решения этой проблемы в С имеется функция <KBD>feof()</KBD>, которая определяет, достигнут ли конец файла. Прототип функции <KBD>feof()</KBD> такой:
<PRE>int feof(FILE *<I>уф</I>);</PRE>
<P class="tj">Если достигнут конец файла, то <KBD>feof()</KBD> возвращает <I>true</I> (истина); в противном же случае эта функция возвращает нуль. Поэтому следующий код будет читать двоичный файл до тех пор, пока не будет достигнут конец файла:
<PRE>while(!feof(fp)) ch = getc(fp);</PRE>
<P class="tj">Ясно, что этот метод можно применять как к двоичным, так и к текстовым файлам.
<P class="tj">В следующей программе, которая копирует текстовые или двоичные файлы, имеется пример применения <KBD>feof()</KBD>. Файлы открываются в двоичном режиме, а затем <KBD>feof()</KBD> проверяет, не достигнут ли конец файла.
<PRE>
/* Копирование файла. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
  FILE *in, *out;
  char ch;

  if(argc!=3) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }

  if((in=fopen(argv[1], "rb"))==NULL) {
    printf("Нельзя открыть исходный файл.\n");
    exit(1);
  }
  if((out=fopen(argv[2], "wb")) == NULL) {
    printf("Нельзя открыть файл результатов.\n");
    exit(1);
  }

  /* Именно этот код копирует файл. */
  while(!feof(in)) {
    ch = getc(in);
    if(!feof(in)) putc(ch, out);
  }

  fclose(in);
  fclose(out);

  return 0;
}
</PRE>
<H2>Ввод / вывод строк: fputs() и fgets()</H2>
<P class="tj">Кроме <KBD>getc()</KBD> и <KBD>putc()</KBD>, в языке С также поддерживаются родственные им функции <KBD>fgets()</KBD> и <KBD>fputs()</KBD>. Первая из них читает строки символов из файла на диске, а вторая записывает строки такого же типа в файл, тоже находящийся на диске. Эти функции работают почти как <KBD>putc()</KBD> и <KBD>getc()</KBD>, но читают и записывают не один символ, а целую строку. Прототипы функций <KBD>fgets()</KBD> и <KBD>fputs()</KBD> следующие:
<PRE>
int fputs(const char *<I>cmp</I>, FILE *<I>уф</I>);
char *fgets(char *<I>cmp</I>, int <I>длина</I>, FILE *<I>уф</I>);
</PRE>
<P class="tj">Функция <KBD>fputs()</KBD> пишет в определенный поток строку, на которую указывает <I>cmp</I>. В случае ошибки эта функция возвращает <KBD>EOF</KBD>.
<P class="tj">Функция <KBD>fgets()</KBD> читает из определенного потока строку, и делает это до тех пор, пока не будет прочитан символ новой строки или количество прочитанных символов не станет равным <I>длина</I>-1. Если был прочитан разделитель строк, он записывается в строку, чем функция <KBD>fgets()</KBD> отличается от функции <KBD>gets()</KBD>. Полученная в результате строка будет оканчиваться символом конца строки ('0'). При успешном завершении работы функция возвращает <I>cmp</I>, а в случае ошибки — пустой указатель (null).
<P class="tj">В следующей программе показано использование функции <KBD>fputs()</KBD>. Она читает строки с клавиатуры и записывает их в файл, который называется TEST. Чтобы завершить выполнение программы, введите пустую строку. Так как функция <KBD>gets()</KBD> не записывает разделитель строк, то его приходится специально вставлять перед каждой строкой, записываемой в файл; это делается для того, чтобы файл было легче читать:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[80];
  FILE *fp;

  if((fp = fopen("TEST", "w"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }

  do {
    printf("Введите строку (пустую - для выхода):\n");
    gets(str);
    strcat(str, "\n");  /* добавление разделителя строк */
    fputs(str, fp);
  } while(*str!='\n');

  return 0;
}
</PRE>
<H2>Функция rewind()</H2>
<P class="tj">Функция <KBD>rewind()</KBD> устанавливает указатель текущей позиции в файле на начало файла, указанного в качестве аргумента этой функции. Иными словами, функция <KBD>rewind()</KBD> выполняет "перемотку" (rewind) файла. Вот ее прототип:
<PRE>void rewind(FILE *<I>уф</I>);</PRE>
<P class="t">где <I>уф</I> — это допустимый указатель файла.
<P class="tj">Чтобы познакомиться с <KBD>rewind()</KBD>, изменим программу из предыдущего раздела таким образом, чтобы она отображала содержимое файла сразу после его создания. Чтобы выполнить отображение, программа после завершения ввода "перематывает" файл, а затем с помощью <KBD>fback()</KBD> читает его с самого начала. Обратите внимание, что сейчас файл необходимо открыть в режиме чтения/записи, используя в качестве аргумента, задающего режим, строку "w+".
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[80];
  FILE *fp;

  if((fp = fopen("TEST", "w+"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }

  do {
    printf("Введите строку (пустую - для выхода):\n");
    gets(str);
    strcat(str, "\n");  /* ввод разделителя строк */
    fputs(str, fp);
  } while(*str!='\n');

  /* теперь выполняется чтение и отображение файла */
  rewind(fp);  /* установить указатель
                  текущей позиции на начало файла. */
  while(!feof(fp)) {
    fgets(str, 79, fp);
    printf(str);
  }

  return 0;
}
</PRE>
<H2>Функция ferror()</H2>
<P class="tj">Функция <KBD>ferror()</KBD> определяет, произошла ли ошибка во время выполнения операции с файлом. Прототип этой функции следующий:
<PRE>int ferror(FILE *<I>уф</I>);</PRE>
<P class="t">где <I>уф</I> — допустимый указатель файла. Она возвращает значение <I>true</I> (истина), если при последней операции с файлом произошла ошибка; в противном же случае она возвращает <I>false</I> (ложь). Так как при любой операции с файлом устанавливается свое условие ошибки, то после каждой такой операции следует сразу вызывать <KBD>ferror()</KBD>, а иначе данные об ошибке могут быть потеряны.
<P class="tj">В следующей программе показано применение <KBD>ferror()</KBD>. Программа удаляет табуляции из файла, заменяя их соответствующим количеством пробелов. Размер табуляции определяется макросом <KBD>TAB_SIZE</KBD>. Обратите внимание, что <KBD>ferror()</KBD> вызывается после каждой операции с файлом. При запуске этой программы указывайте в командной строке имена входного и выходного файлов.
<PRE>
/* Программа заменяет в текстовом файле символы
   табуляции пробелами и отслеживает ошибки. */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define TAB_SIZE 8
#define IN 0
#define OUT 1

void err(int e);

int main(int argc, char *argv[])
{
  FILE *in, *out;
  int tab, i;
  char ch;

  if(argc!=3) {
    printf("Синтаксис: detab &lt;входной_файл&gt; &lt;выходной файл&gt;\n");
    exit(1);
  }

  if((in = fopen(argv[1], "rb"))==NULL) {
    printf("Нельзя открыть %s.\n", argv[1]);
    exit(1);
  }

  if((out = fopen(argv[2], "wb"))==NULL) {
    printf("Нельзя открыть %s.\n", argv[2]);
    exit(1);
  }

  tab = 0;
  do {
    ch = getc(in);
    if(ferror(in)) err(IN);

    /* если найдена табуляция, выводится
       соответствующее число пробелов */
    if(ch=='\t') {
      for(i=tab; i&lt;8; i++) {
        putc(' ', out);
        if(ferror(out)) err(OUT);
      }
      tab = 0;
    }
    else {
      putc(ch, out);
      if(ferror(out)) err(OUT);
      tab++;
      if(tab==TAB_SIZE) tab = 0;
      if(ch=='\n' || ch=='\r') tab = 0;
    }
  } while(!feof(in));
  fclose(in);
  fclose(out);

  return 0;
}

void err(int e)
{
  if(e==IN) printf("Ошибка при вводе.\n");
  else printf("Ошибка привыводе.\n");
  exit(1);
}
</PRE>
<H2>Стирание файлов</H2>
<P class="tj">Функция <KBD>remove()</KBD> стирает указанный файл. Вот ее прототип:
<PRE>int remove(const char *<I>имя_файла</I>);</PRE>
<P class="tj">В случае успешного выполнения эта функция возвращает нуль, а в противном случае — ненулевое значение.
<P class="tj">Следующая программа стирает файл, указанный в командной строке. Однако вначале она дает возможность передумать. Утилита, подобная этой, может пригодиться компьютерным пользователям-новичкам.
<PRE>
/* Двойная проверка перед стиранием. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int main(int argc, char *argv[])
{
  char str[80];

  if(argc!=2) {
    printf("Синтаксис: xerase &lt;имя_файла&gt;\n");
    exit(1);
  }

  printf("Стереть %s? (Y/N): ", argv[1]);
  gets(str);

  if(toupper(*str)=='Y')
    if(remove(argv[1])) {
      printf("Нельзя стиреть файл.\n");
      exit(1);
    }
  return 0; 
}
</PRE>
<H2>Дозапись потока</H2>
<P class="tj">Для дозаписи содержимого выводного потока в файл применяется функция <KBD>fflush()</KBD>. Вот ее прототип:
<PRE>int fflush(FILE *<I>уф</I>);</PRE>
<P class="tj">Эта функция записывает все данные, находящиеся в буфере в файл, который указан с помощью <I>уф</I>. При вызове функции <KBD>fflush()</KBD> с пустым (null) указателем файла <I>уф</I> будет выполнена дозапись во все файлы, открытые для вывода.
<P class="tj">После своего успешного выполнения <KBD>fflush()</KBD> возвращает нуль, в противном случае — <KBD>EOF</KBD>.
<HR><A href="../main.htm#09">Содержание</A> | <A href="0903.htm">&lt;&lt;&lt;</A> | <A href="0905.htm">&gt;&gt;&gt;</A>
</BODY></HTML>