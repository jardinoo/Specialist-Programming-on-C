<HTML><HEAD>
<TITLE>Стандартные потоки</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#09">Содержание</A> | <A href="0907.htm">&lt;&lt;&lt;</A> | <A href="../10/10.htm">&gt;&gt;&gt;</A><HR>
<H1>Стандартные потоки</H1>
<P class="tj">Что касается файловой системы языка С, то в начале выполнения программы автоматически открываются три потока. Это <KBD>stdin</KBD> (стандартный поток ввода), <KBD>stdout</KBD> (стандартный поток вывода) и <KBD>stderr</KBD> (стандартный поток ошибок). Обычно эти потоки направляются к консоли, но в средах, которые поддерживают перенаправление ввода/вывода, они могут быть перенаправлены операционной системой на другое устройство. (Перенаправление ввода/вывода поддерживается, например, такими операционными системами, как Windows, DOS, UNIX и OS/2.)
<P class="tj">Так как стандартные потоки являются указателями файлов, то они могут использоваться системой ввода/вывода языка С также для выполнения операций ввода/вывода на консоль. Например, <KBD>putchar()</KBD> может быть определена таким образом:
<PRE>
int putchar(char c)
{
  return putc(c, stdout);
}
</PRE>
<P class="tj">Вообще говоря, <KBD>stdin</KBD> используется для считывания с консоли, a <KBD>stdout</KBD> и <KBD>stderr</KBD> — для записи на консоль.
<P class="tj">В роли указателей файлов потоки <KBD>stdin</KBD>, <KBD>stdout</KBD> и <KBD>stderr</KBD> можно применять в любой функции, где используется переменная типа <KBD>FILE *</KBD>. Например, для ввода строки с консоли можно написать примерно такой вызов <KBD>fgets()</KBD>:
<PRE>
char str[255];
fgets(str, 80, stdin);
</PRE>
<P class="tj">И действительно, такое применение <KBD>fgets()</KBD> может оказаться достаточно полезным. Как уже говорилось в этой книге, при использовании <KBD>gets()</KBD> не исключена возможность, что массив, который используется для приема вводимых пользователем символов, будет переполнен. Это возможно потому, что <KBD>gets()</KBD> не проводит проверку на отсутствие нарушения границ. Полезной альтернативой <KBD>gets()</KBD> является функция <KBD>fgets()</KBD> с аргументом <KBD>stdin</KBD>, так как эта функция может ограничивать число читаемых символов и таким образом не допустить переполнения массива. Единственная проблема, связанная с <KBD>fgets()</KBD>, состоит в том, что она не удаляет символ новой строки (в то время как <KBD>gets()</KBD> удаляет!), поэтому его приходится удалять "вручную", как показано в следующей программе:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[80];
  int i;

  printf("Введите строку: ");
  fgets(str, 10, stdin);

  /* удалить символ новой строки, если он есть */
  i = strlen(str)-1;
  if(str[i]=='\n') str[i] = '\0';

  printf("Это Ваша строка: %s", str);

  return 0;
}
</PRE>
<P class="tj">He забывайте, что <KBD>stdin</KBD>, <KBD>stdout</KBD> и <KBD>stderr</KBD> — это не переменные в обычном смысле, и им нельзя присваивать значение с помощью <KBD>fopen()</KBD>. Кроме того, именно потому, что в начале работы программы эти указатели файлов создаются автоматически, в конце работы они и закрываются автоматически. Так что и не пытайтесь самостоятельно их закрыть.
<H2>Связь с консольным вводом / выводом</H2>
<P class="tj">В языке С консольный и файловый ввод/вывод не слишком отличаются друг от друга. Функции консольного ввода/вывода, описанные в <A href="../08/08.htm">главе 8</A>, на самом деле направляют результаты своих операций на один из потоков — <KBD>stdin</KBD> или <KBD>stdout</KBD>, и по сути, каждая из них является специальной версией соответствующей файловой функции. Функции консольного ввода/вывода для того и существуют, чтобы было удобно именно программисту.
<P class="tj">Как говорилось в предыдущем разделе, ввод/вывод на консоль можно выполнять с помощью любой файловой функции языка С. Однако для вас может быть сюрпризом, что, оказывается, операции ввода/вывода на дисковых файлах можно выполнять с помощью функции консольного ввода/вывода, например, <KBD>printf()</KBD>! Дело в том, что все функции консольного ввода/вывода, о которых говорилось в <A href="../08/08.htm">главе 8</A>, выполняют свои операции с потоками <KBD>stdin</KBD> и <KBD>stdout</KBD>. В средах, поддерживающих перенаправление ввода/вывода, это равносильно тому, что <KBD>stdin</KBD> или <KBD>stdout</KBD> могут быть перенаправлены на устройство, отличное от клавиатуры или экрана. Проанализируйте, например, следующую программу:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  char str[80];

  printf("Введите строку: ");
  gets(str);
  printf(str);

  return 0;
}
</PRE>
<P class="tj">Предположим, что эта программа называется TEST. При ее нормальном выполнении на экран выводится подсказка, затем читается строка, введенная с клавиатуры, и, наконец, эта строка выводится на экран. Однако в средах, в которых поддерживается перенаправление ввода/вывода, один из потоков <KBD>stdin</KBD> или <KBD>stdout</KBD> (или оба одновременно) можно перенаправить в файл. Например, в среде DOS или Windows следующий запуск TEST
<PRE>TEST &gt; OUTPUT</PRE>
<P class="t">приводит к тому,  что вывод этой  программы  будет записан  в файл по имени OUTPUT. А следующий запуск TEST
<PRE>TEST &lt; INPUT &gt; OUTPUT</PRE>
<P class="t">направляет поток <KBD>stdin</KBD> в файл по имени INPUT, а поток стандартного вывода — в файл по имени OUTPUT.
<P class="tj">Когда С-программа завершается, то все перенаправленные потоки возвращаются в состояния, которые были установлены по умолчанию.
<H2>Перенаправление стандартных потоков: функция freopen()</H2>
<P class="tj">Для перенаправления стандартных потоков можно воспользоваться функцией <KBD>freopen()</KBD>. Эта функция связывает имеющийся поток с новым файлом. Так что она вполне может связать с новым файлом и стандартный поток. Вот прототип этой функции:
<PRE>FILE *freopen(const char *<I>имя_файла</I>, const char *<I>режим</I>, FILE *<I>поток</I>);</PRE>
<P class="t">где <I>имя_файла</I> — это указатель на имя файла, который требуется связать с потоком, на который указывает указатель <I>поток</I>. Файл открывается в режиме <I>режим</I>; этот параметр может принимать те же значения, что и соответствующий параметр функции <KBD>fopen()</KBD>. Если функция <KBD>freopen()</KBD> выполнилась успешно, то она возвращает <I>поток</I>, а если встретились ошибки, — то <KBD>NULL</KBD>.
<P class="tj">В следующей программе показано использование функции <KBD>freopen()</KBD> для перенаправления стандартного потока вывода <KBD>stdout</KBD> в файл с именем OUTPUT.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  char str[80];

  freopen("OUTPUT", "w", stdout);

  printf("Введите строку: ");
  gets(str);
  printf(str);

  return 0;
}
</PRE>
<P class="tj">Вообще говоря, перенаправление стандартных потоков с помощью <KBD>freopen()</KBD> в некоторых случаях может быть полезно, например, при отладке. Однако выполнение дисковых операций ввода/вывода на перенаправленных потоках <KBD>stdin</KBD> и <KBD>stdout</KBD> не настолько эффективно, как использование таких функций, как <KBD>fread()</KBD> или <KBD>fwrite()</KBD>.
<HR><A href="../main.htm#09">Содержание</A> | <A href="0907.htm">&lt;&lt;&lt;</A> | <A href="../10/10.htm">&gt;&gt;&gt;</A>
</BODY></HTML>