<HTML><HEAD>
<TITLE>Неформальная теория языка С</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#29">Содержание</A> | <A href="2903.htm">&lt;&lt;&lt;</A> | <A href="2905.htm">&gt;&gt;&gt;</A><HR>
<H1>Неформальная теория языка С</H1>
<P class="t">Перед тем как приступить к разработке интерпретатора языка С, необходимо уяснить структуру языка С. Формальное определение языка С (например, в стандарте ANSI/ISO) очень длинное, к тому же в нем довольно много зашифрованных для неискушенного читателя положений. Однако совершенно формальное определение языка С для разработки интерпретатора не понадобится, потому что этот язык является довольно прямолинейным. Полное формальное определение языка С необходимо для создания коммерческого компилятора, а для Little С оно не является необходимым. (Фактически, в одной главе невозможно изложить формальный синтаксис, определяющий С; это заняло бы целую книгу.)
<P class="tj">Эта глава предназначена для широкого круга читателей. Она не была задумана как формальное введение в теорию структурированных языков в целом и языка С в частности. Поэтому здесь некоторые концепции изложены упрощенно и разработка интерпретатора подмножества С ведется так, что от читатели не потребуется формальная подготовка по теории языков (структурной лингвистике).
<P class="tj">Несмотря на это для реализации и понимания интерпретатора Little С некоторые сведения об определении языка все же необходимы. Материал, изложенный далее, является вполне достаточным для наших целей. Желающим ознакомиться с более формализованным изложением материала следует обратиться к стандарту ANSI/ISO языка С.
<P class="tj">Все программы на С представляют собой набор из одной или более функций плюс глобальные переменные (если они есть). <I>Функция</I> состоит из спецификатора типа функции, имени функции, списка параметров и блока операторов, ассоциированного с функцией. <I>Блок</I> начинается скобкой <KBD>{</KBD>, за которой следует последовательность из одного или нескольких операторов, и заканчивается скобкой <KBD>}</KBD>. Оператор языка С либо начинается с одного из зарезервированных слов, например <KBD>if</KBD>, либо является выражением. (Что представляет собой выражение, будет рассмотрено в следующем разделе.) Изложенные выше порождающие правила могут быть сведены в следующую таблицу:
<PRE>
программа       -&gt; набор функций плюс глобальные переменные
функция         -&gt; спецификатор список_параметров блок_операторов
блок_операторов -&gt; { последовательность_операторов }
оператор        -&gt; зарезервированное_слово, выражение или блок_операторов
</PRE>
<P class="tj">Выполнение любой программы на С начинается вызовом функции <KBD>main()</KBD> и кончается последней закрывающейся скобкой <KBD>}</KBD> или первым оператором <KBD>return</KBD>, встретившимся в <KBD>main()</KBD>, если до этого не встретились <KBD>exit()</KBD> или <KBD>abort()</KBD>. Любая другая функция программы должна быть непосредственно или косвенно вызвана функцией <KBD>main()</KBD>. Таким образом, выполнение программы начинается с началом выполнения <KBD>main()</KBD> и кончается выходом из нее. Интерпретатор Little С именно так и работает.
<H2>Выражения языка С</H2>
<P class="tj">В языке С роль выражений несколько шире, чем в других языках программирования. В общем случае в программе на С оператор может начинаться с зарезервированного слова языка С, например, <KBD>while</KBD> или <KBD>switch</KBD>, а может и не начинаться с него. Для удобства дальнейшего изложения все операторы, начинающиеся с зарезервированного слова языка С, будем называть <I>операторами с зарезервированным словом</I>. Все остальные операторы (не начинающиеся с зарезервированного слова) будем называть <I>операторами-выражениями</I>. Таким образом, все следующие операторы языка С являются операторами-выражениями:
<PRE>
count = 100;              /* Строка 1 */
sample = i / 22 * (c-10); /* Строка 2 */
printf("Этo выражение");  /* Строка 3 */
</PRE>
<P class="tj">Рассмотрим каждый из этих операторов-выражений подробно. В языке С знак равенства является <I>оператором присваивания</I><SUP><A href="#11" name="1">[1]</A></SUP>. Здесь оператор присваивания работает не так, как, например, в BASIC. В языке BASIC значение, вычисленное в правой части знака равенства, присваивается переменной в левой части, однако, и это весьма существенно, это значение не является значением оператора присваивания. В то же время в языке С знак равенства является оператором присваивания и значение результата оператора присваивания равно значению, полученному в правой части. Следовательно, в языке С оператор присваивания фактически является <I>выражением присваивания</I>. Оператор присваивания имеет значение, поэтому он является выражением. Именно по этой причине правильными являются, например, следующие выражения:
<PRE>
а = b = с = 100;
printf("%d", a=4+5);
</PRE>
<P class="tj">Эти выражения в языке С допустимы, потому что присваивание является оператором, имеющим значение, как и любая другая операция.
<P class="tj">Продолжим рассмотрение предыдущего примера. Строка 2 содержит более сложное присваивание. В строке 3 вызывается функция <KBD>printf()</KBD>, выводящая на экран строку. В языке С все функции базовых типов, отличных от <KBD>void</KBD>, возвращают значение независимо от того, определен тип явно или нет. Следовательно, вызов функции, возвращающей значение, является выражением, имеющим значение, опять же независимо от того, присваивается оно чему-либо или нет. Вызов функции, не возвращающей значения (определенной со спецификатором <KBD>void</KBD>), также является выражением, однако его результат имеет тип <KBD>void</KBD>.
<H2>Определение значения выражения</H2>
<P class="tj">Перед тем как приступить к разработке программы, способной правильно вычислить значение выражения, нужно дать более формальное определение выражения. Фактически в каждом языке программирования выражения определяются рекурсивно с помощью порождающих правил, или продукций. Интерпретатор Little С поддерживает следующие операции: +, -, *, /, %, =, операторы сравнения (&lt;, ==, &gt; и так далее) и скобки. В языке Little С выражения определяются с помощью следующих порождающих правил:
<PRE>
выражение           -&gt; [присваивание] [значение_переменной]
присваивание        -&gt; именующее_выражение = значение_переменной
именующее_выражение -&gt; переменная
значение_переменной -&gt; часть [оператор_сравнения часть]
часть               -&gt; терм [+терм] [-терм]
терм                -&gt; множитель [*множитель] [/множитель] [%множитель]
множитель           -&gt; [+ или -] атом
атом                -&gt; переменная, константа, функция, или(выражение)
</PRE>
<P class="tj">Здесь термин <I>оператор_сравнения</I> может обозначать любой из операторов сравнения. Термины <I>именующее_выражение</I> и <I>значение_переменной</I> означают объекты в левой и правой частях оператора присваивания. Старшинство оператора определяется порождающим правилом. Чем выше старшинство оператора, тем ниже в списке операторов он расположен.
<P class="tj">Рассмотрим применение порождающих правил на примере вычисления выражения
<PRE>count = 10 - 5 * 3;</PRE>
<P class="tj">Сначала применяется правило 1, разделяющее выражение на три части:
<PRE>
      count                =              10-5*3
        ^                  ^                 ^
        |                  |                 |
именующее_выражение   присваивание   значение_переменной
</PRE>
<P class="tj">Поскольку значение нетерминала <I>значение_переменной</I> не содержит операторов сравнения, то оно может быть сгенерировано в результате применения порождающего правила для нетерминала <I>терм</I>:
<PRE>
 10        -        5*3
  ^        ^         ^
  |        |         |
терм     минус     терм
</PRE>
<P class="tj">Несомненно, второй терм составлен из двух множителей: 5 и 3. Эти два множителя являются константами, они порождаются с помощью порождающих правил более низкого уровня.
<P class="tj">Теперь, чтобы вычислить значение выражения, будем двигаться, следуя порождающим правилам, в обратном направлении. Сначала выполняется умножение 5*3, что дает 15. Потом это значение вычитается из 10, получается -5. И, наконец, последний шаг — присваивание этого значения переменной <KBD>count</KBD>, оно же является значением всего выражения.
<P class="tj">При создании интерпретатора Little С в первую очередь нужно построить алгоритмический эквивалент рассмотренной только что процедуры вычисления выражения.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Сам знак равенства является, конечно, знаком операции присваивания.
</BLOCKQUOTE> 
<HR><A href="../main.htm#29">Содержание</A> | <A href="2903.htm">&lt;&lt;&lt;</A> | <A href="2905.htm">&gt;&gt;&gt;</A>
</BODY></HTML>