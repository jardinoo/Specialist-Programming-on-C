<HTML><HEAD>
<TITLE>Усовершенствование интерпретатора Little C</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#29">Содержание</A> | <A href="2909.htm">&lt;&lt;&lt;</A> | <A href="2911.htm">&gt;&gt;&gt;</A><HR>
<H1>Усовершенствование интерпретатора Little C</H1>
<P class="tj">Рассмотренный в этой главе интерпретатор Little С разрабатывался таким образом, чтобы его принцип действия был, по возможности, очевидным. При разработке интерпретатора преследовалась цель сделать его максимально легким для понимания. Другой целью было сделать его легко расширяемым. Поскольку преследовались именно эти цели, интерпретатор Little С не обладает значительным быстродействием или эффективностью. Однако базовая структура интерпретатора корректна, а скорость выполнения программ можно увеличить, пользуясь указаниями, приведенными в этом разделе.
<P class="tj">Фактически во всех коммерческих интерпретаторах роль программы предварительного прохода значительно шире, чем в Little С. Интерпретируемый исходный текст программы преобразуется из формы ASCII, которая удобна программисту для чтения, во внутреннюю форму. В этой внутренней форме все, кроме заключенных в двойные кавычки строк и констант, преобразуется в лексемы, состоящие из одного числа, аналогично тому, как это делает Little С для зарезервированных слов. При работе интерпретатора Little С довольно часто сравниваются строки. Например, всякий раз при поиске переменной или функции выполняется несколько сравнений строк. Процедура сравнения строк занимает много времени, что конечно же значительно снижает быстродействие программы. Но если каждую лексему исходной программы преобразовать в целое число, то можно использовать намного более быстродействующую операцию сравнения целых чисел. Преобразование исходного текста программы во внутреннюю форму — <I>единственное наиболее существенное изменение</I>, повышающее эффективность Little С. Благодаря этому преобразованию повышение скорости будет весьма ощутимым.
<P class="tj">Другой способ улучшения, полезный главным образом для интерпретации больших программ, — создание специальных процедур для поиска переменных и функций. Применяющийся метод поиска основан на последовательном просмотре имен переменных и программ. Такой просмотр занимает много времени, даже если имена переменных и программ преобразованы в целочисленные лексемы. Однако можно заменить этот метод поиска другим, более быстрым методом, используя, например, двоичное дерево или один из методов хэширования.
<P class="tj">Как указывалось ранее, одним из ограничений Little С по сравнению с грамматикой полного С является требование заключать объекты некоторых операторов, таких как <KBD>if</KBD>, в фигурные скобки независимо от того, единственный это оператор или блок операторов. Это предусмотрено с целью существенного упрощения функции <KBD>find_eob()</KBD>, которая ищет конец блока после выполнения одного из управляющих операторов. Функция <KBD>find_eob()</KBD> попросту ищет закрывающуюся скобку, соответствующую скобке, открывающей блок. Устранение этого ограничения будет интересным упражнением для читателя. Для этого можно, например, усовершенствовать функцию <KBD>find_eob()</KBD> таким образом, чтобы она искала конец оператора, выражения или блока. Однако следует иметь в виду, что для операторов <KBD>if</KBD>, <KBD>while</KBD>, <KBD>do-while</KBD> и <KBD>for</KBD> потребуются различные подходы, если в них используется единственный оператор.
<HR><A href="../main.htm#29">Содержание</A> | <A href="2909.htm">&lt;&lt;&lt;</A> | <A href="2911.htm">&gt;&gt;&gt;</A>
</BODY></HTML>