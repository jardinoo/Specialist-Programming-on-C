<HTML><HEAD>
<TITLE>Интерпретатор Little C</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#29">Содержание</A> | <A href="2905.htm">&lt;&lt;&lt;</A> | <A href="2907.htm">&gt;&gt;&gt;</A><HR>
<H1>Интерпретатор Little C</H1>
<P class="tj">В этом разделе рассматривается наиболее важная часть интерпретатора Little С. Перед тем как приступить к подробному чтению текста программы интерпретатора, нужно понять, как вообще работает интерпретатор. Понять программу интерпретатора в некотором смысле легче, чем программу синтаксического анализатора выражений, потому что работа по интерпретации программы на С может быть выражена следующим простым алгоритмом:
<PRE>
while (есть_лексемы_во_входном_потоке) {
       читать следующую лексему;
       выполнить соответствующее действие;
}
</PRE>
<P class="tj">Этот алгоритм может показаться невероятно простым по сравнению с синтаксическим анализатором выражений, но это именно то, что делает интерпретатор. Нужно только иметь в виду следующее: шаг "выполнить соответствующее действие" может содержать чтение дополнительных лексем из входного потока. Для лучшего понимания этого алгоритма мысленно выполним интерпретацию следующего фрагмента программы:
<PRE>
int a;

a = 10;
if(a &lt; 100) printf("%d", a);
</PRE>
<P class="tj">Согласно алгоритму, прочтем первую лексему <KBD>int</KBD>. Эта лексема указывает на то, что следующим действием должно быть чтение следующей лексемы для того, чтобы узнать, как называется переменная (<KBD>a</KBD>), которую нужно объявить и для которой нужно выделить область памяти. Следующая лексема (точка с запятой) заканчивает строку. Соответствующее действие — проигнорировать ее. Далее, начинаем следующую итерацию алгоритма и считываем следующую лексему, это а из второй строки. Строка не начинается с зарезервированного слова, следовательно, это выражение языка С. Поэтому соответствующим действием является применение синтаксического анализатора выражений для вычисления значения выражения. Этот процесс "съедает" все лексемы во второй строке. Наконец, читаем лексему <KBD>if</KBD>. Она указывает на то, что начинается оператор <KBD>if</KBD>. Соответствующее действие — выполнить его. Аналогичный процесс выполняется многократно, пока не будет считана последняя лексема программы. Это относится к любой программе на С. Пользуясь этим алгоритмом, приступим к созданию интерпретатора.
<H2>Предварительный проход интерпритатора</H2>
<P class="tj">Перед тем как интерпретатор начнет выполнять программу, должны быть выполнены некоторые рутинные процедуры. Характерной чертой языков, предназначенных больше для интерпретации, чем для компиляции, является то, что выполнение программы начинается в начале текста программы и заканчивается в его конце. Так выполняются программы, написанные на старых версиях языка BASIC. Это, однако, не относится к языку С (как и к любому другому структурированному языку) по трем основным причинам.
<P class="tj">Во-первых, все программы на С начинают выполняться с функции <KBD>main()</KBD>. Вовсе не обязательно, чтобы эта функция была первой в программе. Поэтому интерпретатор, чтобы начать выполнение с нее, должен еще до начала выполнения программы узнать, где она находится. Следовательно, должен быть реализован некоторый метод, позволяющий начать выполнение программы с нужной точки. (Глобальные переменные также могут предшествовать функции <KBD>main()</KBD>, поэтому, даже если она является первой функцией программы, все равно и в этом случае она не начинается с первой строки.)
<P class="tj">Во-вторых, все глобатьные переменные должны быть известны перед началом выполнения <KBD>main()</KBD>. Операторы объявления глобальных переменных никогда не выполняются интерпретатором, потому что они находятся вне всех функций. (В языке С весь выполняющийся текст программы находится <I>внутри</I> функций, поэтому при выполнении программы интерпретатор Little С никогда не выходит за пределы функций.)
<P class="tj">И наконец, в-третьих, для повышения скорости выполнения необходимо (правда, не всегда) знать, где в программе расположена каждая функция; это позволит вызывать ее как можно быстрее. Если это условие не будет выполнено, то при каждом вызове функции понадобится длительный последовательный поиск этой функции в тексте программы.
<P class="tj">Эти проблемы решаются с помощью <I>предварительного прохода интерпретатора</I>. Программа предварительного прохода (иногда ее называют препроцессором, правда это название очень неудачное из-за того, что совпадает с названием препроцессора компилятора С, хотя практически ничего общего с ним не имеет) применяется во всех коммерческих компиляторах независимо от интерпретируемого языка. Программа предварительного прохода читает исходный текст программы перед ее выполнением и делает все, что нужно сделать до выполнения. В интерпретаторе Little С она выполняет две важные задачи: во-первых, находит и запоминает положение всех пользовательских функций, включая <KBD>main()</KBD>, и во-вторых, находит все глобальные переменные и определяет область их видимости. В интерпретаторе Little С предварительный проход выполняет функция <KBD>prescan()</KBD>:
<PRE>
/* Найти адреса всех функций в программе
   и запомнить глобальные переменные. */
void prescan(void)
{
  char *p, *tp;
  char temp[32];
  int datatype; 
  int brace = 0;  /* Если brace = 0, то текущая
                     позиция указателя программы находится
                     в не какой-либо функции. */

  p = prog;
  func_index = 0;
  do {
    while(brace) {  /* обход кода функции */
      get_token();
      if(*token == '{') brace++;
      if(*token == '}') brace--;
    }

    tp = prog; /* запоминание текущей позиции */
    get_token();
    /* тип глобальной переменной или возвращаемого значения функции */
    if(tok==CHAR || tok==INT) { 
      datatype = tok; /* запоминание типа данных */
      get_token();
      if(token_type == IDENTIFIER) {
        strcpy(temp, token);
        get_token();
        if(*token != '(') { /* это должна быть глобальная переменная */
          prog = tp; /* возврат в начало объявления */
          decl_global();
        }
        else if(*token == '(') {  /* это должна быть функция */
          func_table[func_index].loc = prog;
          func_table[func_index].ret_type = datatype;
          strcpy(func_table[func_index].func_name, temp);
          func_index++;
          while(*prog != ')') prog++;
          prog++;
          /* сейчас prog указывает на открывающуюся
             фигурную скобку функции */
        }
        else putback();
      }
    }
    else if(*token == '{') brace++;
  } while(tok != FINISHED);
  prog = p;
}
</PRE>
<P class="tj">Функция <KBD>prescan()</KBD> работает следующим образом. Каждый раз, когда встречается открывающаяся фигурная скобка, переменная <KBD>brace</KBD> увеличивается на 1, а когда закрывающаяся — уменьшается на 1. Следовательно, если <KBD>brace</KBD> больше нуля, то текущая лексема находится внутри функции<SUP><A href="#11" name="1">[1]</A></SUP>. Поэтому объявление переменной считается глобальным, если оно встретилось, когда <KBD>brace</KBD> равно нулю. Аналогично, если при <KBD>brace</KBD>, равном нулю, встретилось имя функции, значит, оно принадлежит определению функции (в Little С нет прототипов функций).
<P class="tj">Функция <KBD>decl_global()</KBD> запоминает глобальные переменные в таблице <KBD>global_vars</KBD>:
<PRE>
/* Массив этих структур содержит информацию
   о глобальных переменных.
*/
struct var_type {
  char var_name[ID_LEN];
  int v_type;
  int value;
}  global_vars[NUM_GLOBAL_VARS];

int gvar_index; /* индекс в таблице глобальных переменных */

/* Объявление глобальной переменной. */
void decl_global(void)
{
  int vartype;

  get_token();  /* определение типа */

  vartype = tok; /* запоминание типа переменной */

  do { /* обработка списка */
    global_vars[gvar_index].v_type = vartype;
    global_vars[gvar_index].value = 0;  /* инициализация нулем */
    get_token();  /* определение имени */
    strcpy(global_vars[gvar_index].var_name, token);
    get_token();
    gvar_index++;
  } while(*token == ',');
  if(*token != ';') sntx_err(SEMI_EXPECTED);
}
</PRE>
<P class="tj">Переменная целого типа <KBD>gvar_index</KBD> содержит индекс первого свободного элемента массива <KBD>global_vars</KBD>.
<P class="tj">Адрес каждой функции, определенной пользователем, помещается в массив <KBD>func_table</KBD>:
<PRE>
struct func_type {
  char func_name[ID_LEN];
  int ret_type; 
  char *loc;  /* адрес точки входа в файл */
} func_table[NUM_FUNC];

int func_index; /* индекс в таблице функций */
</PRE>
<P class="tj">Переменная <KBD>func_index</KBD> содержит индекс первой свободной позиции в таблице <KBD>func_table</KBD>.
<H2>Функция main()</H2>
<P class="tj">Главная функция интерпретатора Little С загружает исходный текст программы, инициализирует глобальные переменные, готовит интерпретатор к вызову <KBD>main()</KBD> и вызывает функцию <KBD>call()</KBD>, которая начинает выполнение программы. Работа <KBD>call()</KBD> будет рассмотрена далее в этой главе.
<PRE>
int main(int argc, char *argv[])
{
  if(argc != 2) {
    printf("Применение: littlec &lt;имя_файла&gt;\n");
    exit(1);
  }

  /* выделение памяти для программы */
  if((p_buf = (char *) malloc(PROG_SIZE))==NULL) {
    printf("Выделить память не удалось");
    exit(1);
  }

  /* загрузка программы для выполнения */
  if(!load_program(p_buf, argv[1])) exit(1);
  if(setjmp(e_buf)) exit(1); /* инициализация буфера long jump */

  gvar_index = 0;  /* инициализация индекса глобальных переменных */

  /* установка указателя программы на начало буфера программы */
  prog = p_buf;
  prescan(); /* определение адресов всех функций
                и глобальных переменных программы */

  lvartos = 0;     /* инициализация индекса стека локальных переменных */
  functos = 0;     /* инициализация индекса стека вызова (CALL) */

  /* первой вызывается main() */
  prog = find_func("main"); /* поиск точки входа программы */

  if(!prog) { /* функция main() неправильна или отсутствует */
    printf("main() не найдена.\n");
    exit(1);
  }

  prog--; /* возврат к открывающейся скобке ( */
  strcpy(token, "main");
  call(); /* начало интерпритации main() */

  return 0;
}
</PRE>
<H2>Функция interp_block()</H2>
<P class="tj">Функция <KBD>interp_block()</KBD> является сердцем интерпретатора. В этой функции принимается решение о том, какое действие выполнить при прочтении очередной лексемы из входного потока. Функция интерпретирует один блок программы, после чего возвращает управление. Если блок состоит из единственного оператора, этот оператор интерпретируется и функция возвращает управление вызвавшей программе. По умолчанию <KBD>interp_block()</KBD> интерпретирует один оператор, после чего возвращает управление вызвавшей программе. Однако, если встречается открывающаяся фигурная скобка, то флажок <KBD>block</KBD> устанавливается в 1 и функция продолжает интерпретацию операторов, пока не встретит закрывающуюся фигурную скобку. Текст функции <KBD>interp_block()</KBD> приведен ниже:
<PRE>
/* Интерпритация одного оператора или блока. Когда
   interp_block() возвращает управление после первого
   вызова, в main() встретилась последняя
   закрывающаяся фигурная скобка или оператор return.
*/
void interp_block(void)
{
  int value;
  char block = 0;

  do {
    token_type = get_token();

    /* При интерпритации одного операторавозврат
       после первой точки с запятой.
    */

    /* определение типа лексемы */
    if(token_type == IDENTIFIER) {
      /* Это не зарегестрированное слово,
         обрабатывается выражение. */
      putback();  /* возврат лексемыво входной поток
        для дальнейшей обработки функцией eval_exp() */
      eval_exp(&value);  /* обработка выражения */
      if(*token!=';') sntx_err(SEMI_EXPECTED);
    }
    else if(token_type==BLOCK) {
      /* если это граничитель блока */
      if(*token == '{') /* блок */
        block = 1; /* интерпритация блока, а не оператора */
      else return; /* это }, возврат */
    }
    else /* зарезервированное слово */
      switch(tok) {
        case CHAR:
        case INT:     /* объявление локальной переменной */
          putback();
          decl_local();
          break;
        case RETURN:  /* возврат из вызова функции */
          func_ret();
          return;
        case IF:      /* обработка оператора if */
          exec_if();
          break;
        case ELSE:    /* обработка оператора else */
          find_eob(); /* поиск конца блока else
                         и продолжение выполнения */
          break;
        case WHILE:   /* обработка цикла while */
          exec_while();
          break;
        case DO:      /* обработка цикла do-while */
          exec_do();
          break;
        case FOR:     /* обработка цикла for */
          exec_for();
          break;
        case END:
          exit(0);
      }
  } while (tok != FINISHED && block);
}
</PRE>
<P class="tj">Если не считать вызовов функции <KBD>exit()</KBD> или подобных ей, то интерпретация программы, написанной на языке С, кончается в одном из следующих случаев: встретилась последняя закрывающаяся фигурная скобка функции <KBD>main()</KBD>, или встретился оператор <KBD>return</KBD> из <KBD>main()</KBD>. Из-за того, что при встрече последней закрывающейся фигурной скобки <KBD>main()</KBD> программу нужно завершить, <KBD>interp_block()</KBD> выполняет только один оператор или блок, а не всю программу, хоть она и состоит из блоков. Таким образом, <KBD>interp_block()</KBD> вызывается каждый раз, когда встречается новый блок. Это относится не только к блокам функций, но и к блокам операторов (например, <KBD>if</KBD>). Следовательно, в процессе выполнения программы интерпретатор Little С вызывает <KBD>interp_block()</KBD> рекурсивно.
<P class="tj">Функция <KBD>interp_block()</KBD> работает следующим образом. Сначала из входного потока считывается очередная лексема программы. Если это точка с запятой, то выполняется единственный оператор и функция возвращает управление. В противном случае, выполняется проверка, является ли следующая лексема идентификатором; если да, то оператор является выражением и вызывается синтаксический анализатор выражений. Синтаксический анализатор должен прочесть все выражение, включая первую лексему, поэтому перед его вызовом функция <KBD>putback()</KBD> возвращает последнюю прочитанную лексему во входной поток. После возврата управления из <KBD>eval_exp()</KBD> <KBD>token</KBD> содержит последнюю лексему, прочитанную синтаксическим анализатором выражений. Если синтаксических ошибок нет, то это должна быть точка с запятой. Если <KBD>token</KBD> не содержит точку с запятой, то выводится сообщение об ошибке.
<P class="tj">Если очередная лексема программы является открывающейся фигурной скобкой, то переменная <KBD>block</KBD> устанавливается равной 1, а если закрывающейся, то <KBD>interp_block()</KBD> возвращает управление вызвавшей программе.
<P class="tj">Если лексема является зарезервированным словом, то выполняется оператор <KBD>switch</KBD>, который вызывает соответствующую процедуру обработки оператора. Нумерация зарезервированных слов в функции <KBD>get_token()</KBD> нужна для того, чтобы можно было применить <KBD>switch</KBD>, а не <KBD>if</KBD>, которому пришлось бы сравнивать строки, что значительно медленнее.
<P class="tj">Функции, выполняющие операторы с зарезервированным словом, будут рассмотрены в дальнейших разделах.
<P class="tj">Ниже приведен листинг файла с текстом программы интерпретатора. Он называется LITTLEC.C.
<PRE>
/* Интерпритатор языка Little C. */

#include &lt;stdio.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define NUM_FUNC        100
#define NUM_GLOBAL_VARS 100
#define NUM_LOCAL_VARS  200
#define NUM_BLOCK       100
#define ID_LEN          31
#define FUNC_CALLS      31
#define NUM_PARAMS      31
#define PROG_SIZE       10000
#define LOOP_NEST       31

enum tok_types {DELIMITER, IDENTIFIER, NUMBER, KEYWORD,
                TEMP, STRING, BLOCK};

/* сюда можно добавить дополнительные лексемы
   зарезервированных слов */
enum tokens {ARG, CHAR, INT, IF, ELSE, FOR, DO, WHILE,
             SWITCH, RETURN, EOL, FINISHED, END};

/* сюда можно добавить дополнительные двухсимвольные операторы,
   например, -&gt; */
enum double_ops {LT=1, LE, GT, GE, EQ, NE};

/* Эти константы используются для вызова функции sntx_err()
   в случае синтаксической ошибки. При необходимости список
   констант можно расширить.
   ВНИМАНИЕ: константа SYNTAX используется тогда, когда
   интерпритатор не может квалифицировать ошибку.
*/
enum error_msg
     {SYNTAX, UNBAL_PARENS, NO_EXP, EQUALS_EXPECTED,
      NOT_VAR, PARAM_ERR, SEMI_EXPECTED,
      UNBAL_BRACES, FUNC_UNDEF, TYPE_EXPECTED,
      NEST_FUNC, RET_NOCALL, PAREN_EXPECTED,
      WHILE_EXPECTED, QUOTE_EXPECTED, NOT_TEMP,
      TOO_MANY_LVARS, DIV_BY_ZERO};

char *prog;    /* текущая позиция в исходном тексте программы */
char *p_buf;   /* указывает на начало буфера программы */
jmp_buf e_buf; /* содержит информацию для longjmp() */

/* Массив этих структур содержит информацию
   о глобальных переменных.
*/
struct var_type {
  char var_name[ID_LEN];
  int v_type;
  int value;
}  global_vars[NUM_GLOBAL_VARS];

struct var_type local_var_stack[NUM_LOCAL_VARS];

struct func_type {
  char func_name[ID_LEN];
  int ret_type; 
  char *loc;  /* адрес точки входа в файл */
} func_table[NUM_FUNC];

int call_stack[NUM_FUNC];

struct commands { /* таблица зарезервированных слов */
  char command[20];
  char tok;
} table[] = { /* В эту таблицу */
  "if", IF, /* команды должны быть введены на нижнем регистре. */
  "else", ELSE,
  "for", FOR,
  "do", DO,
  "while", WHILE,
  "char", CHAR,
  "int", INT,
  "return", RETURN,
  "end", END,
  "", END  /* конец таблицы */
};

char token[80];
char token_type, tok;

int functos;  /* индекс вершины стека вызова функции */
int func_index; /* индекс в таблице функций */
int gvar_index; /* индекс в таблице глобальных переменных */
int lvartos; /* индекс в стеке локальных переменных */

int ret_value; /* возвращаемое значение функции */

void print(void), prescan(void);
void decl_global(void), call(void), putback(void);
void decl_local(void), local_push(struct var_type i);
void eval_exp(int *value), sntx_err(int error);
void exec_if(void), find_eob(void), exec_for(void);
void get_params(void), get_args(void);
void exec_while(void), func_push(int i), exec_do(void);
void assign_var(char *var_name, int value);
int load_program(char *p, char *fname), find_var(char *s);
void interp_block(void), func_ret(void);
int func_pop(void), is_var(char *s), get_token(void);
char *find_func(char *name);

int main(int argc, char *argv[])
{
  if(argc != 2) {
    printf("Применение: littlec &lt;имя_файла&gt;\n");
    exit(1);
  }

  /* выделение памяти для программы */
  if((p_buf = (char *) malloc(PROG_SIZE))==NULL) {
    printf("Выделить память не удалось");
    exit(1);
  }

  /* загрузка программы для выполнения */
  if(!load_program(p_buf, argv[1])) exit(1);
  if(setjmp(e_buf)) exit(1); /* инициализация буфера long jump */

  gvar_index = 0;  /* инициализация индекса глобальных переменных */

  /* установка указателя программы на начало буфера программы */
  prog = p_buf;
  prescan(); /* определение адресов всех функций
                и глобальных переменных программы */

  lvartos = 0;     /* инициализация индекса стека локальных переменных */
  functos = 0;     /* инициализация индекса стека вызова (CALL) */

  /* первой вызывается main() */
  prog = find_func("main"); /* поиск точки входа программы */

  if(!prog) { /* функция main() неправильна или отсутствует */
    printf("main() не найдена.\n");
    exit(1);
  }

  prog--; /* возврат к открывающейся скобке ( */
  strcpy(token, "main");
  call(); /* начало интерпритации main() */

  return 0;
}

/* Интерпритация одного оператора или блока. Когда
   interp_block() возвращает управление после первого
   вызова, в main() встретилась последняя
   закрывающаяся фигурная скобка или оператор return.
*/
void interp_block(void)
{
  int value;
  char block = 0;

  do {
    token_type = get_token();

    /* При интерпритации одного операторавозврат
       после первой точки с запятой.
    */

    /* определение типа лексемы */
    if(token_type == IDENTIFIER) {
      /* Это не зарегестрированное слово,
         обрабатывается выражение. */
      putback();  /* возврат лексемыво входной поток
        для дальнейшей обработки функцией eval_exp() */
      eval_exp(&value);  /* обработка выражения */
      if(*token!=';') sntx_err(SEMI_EXPECTED);
    }
    else if(token_type==BLOCK) {
      /* если это граничитель блока */
      if(*token == '{') /* блок */
        block = 1; /* интерпритация блока, а не оператора */
      else return; /* это }, возврат */
    }
    else /* зарезервированное слово */
      switch(tok) {
        case CHAR:
        case INT:     /* объявление локальной переменной */
          putback();
          decl_local();
          break;
        case RETURN:  /* возврат из вызова функции */
          func_ret();
          return;
        case IF:      /* обработка оператора if */
          exec_if();
          break;
        case ELSE:    /* обработка оператора else */
          find_eob(); /* поиск конца блока else
                         и продолжение выполнения */
          break;
        case WHILE:   /* обработка цикла while */
          exec_while();
          break;
        case DO:      /* обработка цикла do-while */
          exec_do();
          break;
        case FOR:     /* обработка цикла for */
          exec_for();
          break;
        case END:
          exit(0);
      }
  } while (tok != FINISHED && block);
}

/* Загрузка программы. */
int load_program(char *p, char *fname)
{
  FILE *fp;
  int i=0;

  if((fp=fopen(fname, "rb"))==NULL) return 0;

  i = 0;
  do {
    *p = getc(fp);
    p++; i++;
  } while(!feof(fp) && i&lt;PROG_SIZE);

  if(*(p-2) == 0x1a) *(p-2) = '\0'; /* программа кончается
                                       нулевым символом */
  else *(p-1) = '\0';
  fclose(fp);
  return 1;
}

/* Найти адреса всех функций в программе
   и запомнить глобальные переменные. */
void prescan(void)
{
  char *p, *tp;
  char temp[32];
  int datatype; 
  int brace = 0;  /* Если brace = 0, то текущая
                     позиция указателя программы находится
                     в не какой-либо функции. */

  p = prog;
  func_index = 0;
  do {
    while(brace) {  /* обход кода функции */
      get_token();
      if(*token == '{') brace++;
      if(*token == '}') brace--;
    }

    tp = prog; /* запоминание текущей позиции */
    get_token();
    /* тип глобальной переменной или возвращаемого значения функции */
    if(tok==CHAR || tok==INT) { 
      datatype = tok; /* запоминание типа данных */
      get_token();
      if(token_type == IDENTIFIER) {
        strcpy(temp, token);
        get_token();
        if(*token != '(') { /* это должна быть глобальная переменная */
          prog = tp; /* возврат в начало объявления */
          decl_global();
        }
        else if(*token == '(') {  /* это должна быть функция */
          func_table[func_index].loc = prog;
          func_table[func_index].ret_type = datatype;
          strcpy(func_table[func_index].func_name, temp);
          func_index++;
          while(*prog != ')') prog++;
          prog++;
          /* сейчас prog указывает на открывающуюся
             фигурную скобку функции */
        }
        else putback();
      }
    }
    else if(*token == '{') brace++;
  } while(tok != FINISHED);
  prog = p;
}

/* Возврат адреса точки входа данной функции.
   Возврат NULL, если не надена.
*/
char *find_func(char *name)
{
  register int i;

  for(i=0; i &lt; func_index; i++)
    if(!strcmp(name, func_table[i].func_name))
      return func_table[i].loc;

  return NULL;
 }

/* Объявление глобальной переменной. */
void decl_global(void)
{
  int vartype;

  get_token();  /* определение типа */

  vartype = tok; /* запоминание типа переменной */

  do { /* обработка списка */
    global_vars[gvar_index].v_type = vartype;
    global_vars[gvar_index].value = 0;  /* инициализация нулем */
    get_token();  /* определение имени */
    strcpy(global_vars[gvar_index].var_name, token);
    get_token();
    gvar_index++;
  } while(*token == ',');
  if(*token != ';') sntx_err(SEMI_EXPECTED);
}

/* Объявление локальной переменной. */
void decl_local(void)
{
  struct var_type i;

  get_token();  /* определение типа */

  i.v_type = tok;
  i.value = 0;  /* инициализация нулем */

  do { /* обработка списка */
    get_token(); /* определение типа пременной */
    strcpy(i.var_name, token);
    local_push(i);
    get_token();
  } while(*token == ',');
  if(*token != ';') sntx_err(SEMI_EXPECTED);
}

/* Вызов функции. */
void call(void)
{
  char *loc, *temp;
  int lvartemp;

  loc = find_func(token); /* найти точку входа функции */
  if(loc == NULL)
    sntx_err(FUNC_UNDEF); /* функция не определена */
  else {
    lvartemp = lvartos;  /* запоминание индекса стека
                            локальных переменных */
    get_args();  /* получение аргумента функции */
    temp = prog; /* запоминание адреса возврата */
    func_push(lvartemp);  /* запоминание индекса стека
                             локальных переменных */
    prog = loc;  /* переустановка prog в начало функции */
    get_params(); /* загрузка параметров функции
                     значениями аргументов */
    interp_block(); /* интерпретация функции */
    prog = temp; /* восстановление prog */
    lvartos = func_pop(); /* восстановление стека
                             локальных переменных */
  }
}

/* Заталкивание аргументов функций в стек
   локальных переменных. */
void get_args(void)
{
  int value, count, temp[NUM_PARAMS];
  struct var_type i;

  count = 0;
  get_token();
  if(*token != '(') sntx_err(PAREN_EXPECTED);

  /* обработка списка значений */
  do {
    eval_exp(&value);
    temp[count] = value;  /* временное запоминание */
    get_token();
    count++;
  }while(*token == ',');
  count--;
  /* затолкнуть в local_var_stack в обратном порядке */
  for(; count&gt;=0; count--) {
    i.value = temp[count];
    i.v_type = ARG;
    local_push(i);
  }
}

/* Получение параметров функции. */
void get_params(void)
{
  struct var_type *p;
  int i;

  i = lvartos-1;
  do { /* обработка списка параметров */
    get_token();
    p = &local_var_stack[i];
    if(*token != ')' ) {
      if(tok != INT && tok != CHAR)
        sntx_err(TYPE_EXPECTED);

      p-&gt;v_type = token_type;
      get_token();

      /* связывание имени пераметров с аргументом,
         уже находящимся в стеке локальных переменных */
      strcpy(p-&gt;var_name, token);
      get_token();
      i--;
    }
    else break;
  } while(*token == ',');
  if(*token != ')') sntx_err(PAREN_EXPECTED);
}

/* Возврат из функции. */
void func_ret(void)
{
  int value;

  value = 0;
  /* получение возвращаемого значения, если оно есть */
  eval_exp(&value);

  ret_value = value;
}

/* Затолкнуть локальную переменную. */
void local_push(struct var_type i)
{
  if(lvartos &gt; NUM_LOCAL_VARS)
    sntx_err(TOO_MANY_LVARS);

  local_var_stack[lvartos] = i;
  lvartos++;
}

/* Выталкивание индекса в стеке локальных переменных. */
int func_pop(void)
{
  functos--;
  if(functos &lt; 0) sntx_err(RET_NOCALL);
  return call_stack[functos];
}

/* Запись индекса в стек локальных переменных. */
void func_push(int i)
{
  if(functos&gt;NUM_FUNC)
   sntx_err(NEST_FUNC);
  call_stack[functos] = i;
  functos++;
}

/* Присваивание переменной значения. */
void assign_var(char *var_name, int value)
{
  register int i;

  /* проверка наличия локальной переменной */
  for(i=lvartos-1; i &gt;= call_stack[functos-1]; i--)  {
    if(!strcmp(local_var_stack[i].var_name, var_name)) {
      local_var_stack[i].value = value;
      return;
    }
  }
  if(i &lt; call_stack[functos-1])
  /* если переменная нелокальная,
     ищем ее в таблице глобальных переменных */
    for(i=0; i &lt; NUM_GLOBAL_VARS; i++)
      if(!strcmp(global_vars[i].var_name, var_name)) {
        global_vars[i].value = value;
        return;
      }
  sntx_err(NOT_VAR); /* переменная не найдена */
}

/* Получение значения переменной. */
int find_var(char *s)
{
  register int i;

  /* проверка наличия переменной */
  for(i=lvartos-1; i &gt;= call_stack[functos-1]; i--)
    if(!strcmp(local_var_stack[i].var_name, token))
      return local_var_stack[i].value;

  /* в противном случае проверим,
     может быть это глобальная переменная */
  for(i=0; i &lt; NUM_GLOBAL_VARS; i++)
    if(!strcmp(global_vars[i].var_name, s))
      return global_vars[i].value;

  sntx_err(NOT_VAR); /* переменная не найдена */
  return -1; 
}

/* Если индентификатор является переменной, то
   возвращается 1, иначе 0.
*/
int is_var(char *s)
{
  register int i;

  /* это локальная переменная ? */
  for(i=lvartos-1; i &gt;= call_stack[functos-1]; i--)
    if(!strcmp(local_var_stack[i].var_name, token))
      return 1;

  /* если нет - поиск среди глобальных переменных */
  for(i=0; i &lt; NUM_GLOBAL_VARS; i++)
    if(!strcmp(global_vars[i].var_name, s))
      return 1;

  return 0;
}

/* Выполнение оператора if. */
void exec_if(void)
{
  int cond;

  eval_exp(&cond); /* вычисление if-выражения */

  if(cond) { /* истина - интерпретация if-предложения */
    interp_block();
  }
  else { /* в противном случае пропуск if-предложения
            и выполнение else-предложения, если оно есть */
    find_eob(); /* поиск конца блока */
    get_token();

    if(tok != ELSE) {
      putback();  /* восстановление лексемы,
                     если else-предложение отсутсвует */
      return;
    }
    interp_block();
  }
}

/* Выполнение цикла while. */
void exec_while(void)
{
  int cond;
  char *temp;

  putback();
  temp = prog;  /* запоминание адреса начала цикла while */
  get_token();
  eval_exp(&cond);  /* вычисление управляющего выражения */
  if(cond) interp_block();  /* если оно истинно, то выполнить
                               интерпритацию */
  else {  /* в противном случае цикл пропускается */
    find_eob();
    return;
  }
  prog = temp;  /* возврат к началу цикла */
}

/* Выполнение цикла do. */
void exec_do(void)
{
  int cond;
  char *temp;

  putback();
  temp = prog;  /* запоминание адреса начала цикла */

  get_token(); /* найти начало цикла */
  interp_block(); /* интерпритация цикла */
  get_token();
  if(tok != WHILE) sntx_err(WHILE_EXPECTED);
  eval_exp(&cond); /* проверка условия цикла */
  if(cond) prog = temp; /* если условие истинно,
  то цикл выполняется, в противном случае происходит
  выход из цикла */
}

/* Поиск конца блока. */
void find_eob(void)
{
  int brace;

  get_token();
  brace = 1;
  do {
    get_token();
    if(*token == '{') brace++;
    else if(*token == '}') brace--;
  } while(brace);
}

/* Выполнение цикла for. */
void exec_for(void)
{
  int cond;
  char *temp, *temp2;
  int brace ;

  get_token();
  eval_exp(&cond);  /* инициализирующее выражение */
  if(*token != ';') sntx_err(SEMI_EXPECTED);
  prog++; /* пропуск ; */
  temp = prog;
  for(;;) {
    eval_exp(&cond);  /* проверка условия */
    if(*token != ';') sntx_err(SEMI_EXPECTED);
    prog++; /* пропуск ; */
    temp2 = prog;

    /* поиск начала тела цикла */
    brace = 1;
    while(brace) {
      get_token();
      if(*token == '(') brace++;
      if(*token == ')') brace--;
    }

    if(cond) interp_block();  /* если условие выполнено,
                                 то выполнить интерпритацию */
    else {  /* в противном случае обойти цикл */
      find_eob();
      return;
    }
    prog = temp2;
    eval_exp(&cond); /* вполнение инкремента */
    prog = temp;  /* возврат в начало цикла */
  }
}
</PRE>
<H2>Обработка локальных переменных</H2>
<P class="tj">Когда интерпретатор встречает зарезервированные слова <KBD>int</KBD> или <KBD>char</KBD>, он вызывает функцию <KBD>decl_local()</KBD>, которая размещает локальные переменные. Как отмечалось ранее, при выполнении программы интерпретатор не может встретить объявление глобальной переменной, потому что выполняется только код программы, записанный внутри функций. Следовательно, если встретилось объявление переменной, то это локальная переменная (или параметр — этот случай будет рассмотрен в следующем разделе). В структурированных языках локальные переменные хранятся в стеке. Если программа компилируется, то обычно используется системный стек. Однако при интерпретации стек с локальными переменными должен быть создан самим интерпретатором. В интерпретаторе Little С стек для локальных переменных хранится в массиве <KBD>local_var_stack</KBD>. Каждый раз, когда встречается локальная переменная, ее имя, тип и значение (первоначально равное нулю) заносятся в стек при помощи функции <KBD>local_push()</KBD>. Глобальная переменная <KBD>lvartos</KBD> является указателем стека. (Соответствующей функции извлечения из стека нет. Вместо этого стек локальных переменных переустанавливается каждый раз при возврате управления из функции <KBD>local_push()</KBD>. Зачем это сделано, будет видно из дальнейшего изложения.) Функции <KBD>decl_local()</KBD> и <KBD>lоcal_push()</KBD> приведены ниже:
<PRE>
/* Объявление локальной переменной. */
void decl_local(void)
{
  struct var_type i;

  get_token();  /* определение типа */

  i.v_type = tok;
  i.value = 0;  /* инициализация нулем */

  do { /* обработка списка */
    get_token(); /* определение типа пременной */
    strcpy(i.var_name, token);
    local_push(i);
    get_token();
  } while(*token == ',');
  if(*token != ';') sntx_err(SEMI_EXPECTED);
}

/* Затолкнуть локальную переменную. */
void local_push(struct var_type i)
{
  if(lvartos &gt; NUM_LOCAL_VARS)
    sntx_err(TOO_MANY_LVARS);

  local_var_stack[lvartos] = i;
  lvartos++;
}
</PRE>
<P class="tj">Функция <KBD>decl_local()</KBD> сначала считывает тип объявленной переменной (или переменных) и инициализирует переменные нулями. Затем в цикле считывается список идентификаторов, разделенных запятыми. При каждой итерации цикла информация об очередной переменной заносится в стек локальных переменных. В конце функции <KBD>decl_local()</KBD> проверяется, является ли последняя лексема точкой с запятой.
<H2>Вызов функций, определенных пользователем</H2>
<P class="tj">Выполнение функций, определенных пользователем, — это, наверное, самая трудная часть в реализации интерпретатора С. Интерпретатор должен начать чтение исходного текста программы с нового места, а затем вернуться в вызывающую процедуру после выхода из функции. Кроме того, он должен выполнить следующие три задачи: передать аргументы, разместить в памяти параметры и вернуть значение функции.
<P class="tj">Все вызовы функций (кроме <KBD>main()</KBD>) осуществляются в синтаксическом анализаторе выражений из функции <KBD>atom()</KBD> с помощью вызова функции <KBD>call()</KBD>. Именно функция <KBD>call()</KBD> выполняет все необходимые при вызове функций действия. Текст функции <KBD>call()</KBD> вместе с ее вспомогательными функциями приведен ниже. Рассмотрим эту функцию подробнее:
<PRE>
/* Вызов функции. */
void call(void)
{
  char *loc, *temp;
  int lvartemp;

  loc = find_func(token); /* найти точку входа функции */
  if(loc == NULL)
    sntx_err(FUNC_UNDEF); /* функция не определена */
  else {
    lvartemp = lvartos;  /* запоминание индекса стека
                            локальных переменных */
    get_args();  /* получение аргумента функции */
    temp = prog; /* запоминание адреса возврата */
    func_push(lvartemp);  /* запоминание индекса стека
                             локальных переменных */
    prog = loc;  /* переустановка prog в начало функции */
    get_params(); /* загрузка параметров функции
                     значениями аргументов */
    interp_block(); /* интерпретация функции */
    prog = temp; /* восстановление prog */
    lvartos = func_pop(); /* восстановление стека
                             локальных переменных */
  }
}

/* Заталкивание аргументов функций в стек
   локальных переменных. */
void get_args(void)
{
  int value, count, temp[NUM_PARAMS];
  struct var_type i;

  count = 0;
  get_token();
  if(*token != '(') sntx_err(PAREN_EXPECTED);

  /* обработка списка значений */
  do {
    eval_exp(&value);
    temp[count] = value;  /* временное запоминание */
    get_token();
    count++;
  }while(*token == ',');
  count--;
  /* затолкнуть в local_var_stack в обратном порядке */
  for(; count&gt;=0; count--) {
    i.value = temp[count];
    i.v_type = ARG;
    local_push(i);
  }
}

/* Получение параметров функции. */
void get_params(void)
{
  struct var_type *p;
  int i;

  i = lvartos-1;
  do { /* обработка списка параметров */
    get_token();
    p = &local_var_stack[i];
    if(*token != ')' ) {
      if(tok != INT && tok != CHAR)
        sntx_err(TYPE_EXPECTED);

      p-&gt;v_type = token_type;
      get_token();

      /* связывание имени пераметров с аргументом,
         уже находящимся в стеке локальных переменных */
      strcpy(p-&gt;var_name, token);
      get_token();
      i--;
    }
    else break;
  } while(*token == ',');
  if(*token != ')') sntx_err(PAREN_EXPECTED);
}
</PRE>
<P class="tj">В первую очередь с помощью вызова функции <KBD>find_func()</KBD> функция <KBD>call()</KBD> находит адрес точки входа вызываемой функции в исходном тексте программы. Затем эта функция сохраняет текущее значение <KBD>lvartos</KBD> индекса стека локальных переменных в переменной <KBD>lvartemp</KBD>. Потом она вызывает функцию <KBD>get_args()</KBD>, которая обрабатывает все аргументы функции. Функция <KBD>get_args()</KBD> считывает список выражений, разделенных запятыми, и заносит их в стек локальных переменных в обратном порядке. (Обратный порядок занесения переменных применяется потому, что так их легче сопоставлять с соответствующими параметрами.) Значения переменных, записанные в стек, не имеют имен (стек — это всего лишь массив). Имена параметров даются им функцией <KBD>get_params()</KBD>, которая будет рассмотрена далее.
<P class="tj">После обработки аргументов функции текущее значение указателя <KBD>prog</KBD> сохраняется в <KBD>temp</KBD>. Эта переменная указывает на точку возврата функции. После этого значение <KBD>lvartemp</KBD> заносится в стек вызова функций. Доступ к этому стеку осуществляется с помощью функций <KBD>func_push()</KBD> и <KBD>func_pop()</KBD>. В данный стек при каждом вызове функции записывается значение <KBD>lvartos</KBD>. Значение <KBD>lvartos</KBD> представляет собой начальную точку в стеке локальных переменных для переменных (и параметров) вызванной функции. Значение на вершине стека вызова функций используется для предотвращения доступа функции к переменным, которые в ней не объявлены.
<P class="tj">Следующие две строки функции <KBD>call()</KBD> устанавливают указатель программы на начало функции и затем, вызывая функцию <KBD>get_params()</KBD>, устанавливают соответствие между формальными параметрами и значениями аргументов функции, которые уже находятся в стеке локальных переменных. Фактическое выполнение функции осуществляется вызовом <KBD>interp_block()</KBD>. После возврата управления из <KBD>interp_block()</KBD> указатель программы <KBD>prog</KBD> переустанавливается; он будет указывать на точку возврата, а индекс стека локальных переменных получит значение, которое он имел до вызова функции. На этом последнем шаге из стека фактически удаляются все локальные переменные функции.
<P class="tj">Если вызванная функция содержит оператор <KBD>return</KBD>, то <KBD>interp_block()</KBD> перед возвратом в <KBD>call()</KBD> вызывает <KBD>func_ret()</KBD>, которая вычисляет возвращаемое значение; код этой функции приведен ниже:
<PRE>
/* Возврат из функции. */
void func_ret(void)
{
  int value;

  value = 0;
  /* получение возвращаемого значения, если оно есть */
  eval_exp(&value);

  ret_value = value;
}
</PRE>
<P class="tj">Глобальная целочисленная переменная <KBD>ret_value</KBD> содержит возвращаемое функцией значение. На первый взгляд может показаться странным то, что локальной переменной <KBD>value</KBD> сначала присваивается возвращаемое значение функции, а затем это значение присваивается переменной <KBD>ret_value</KBD>. Причина здесь в том, что функции могут быть рекурсивными и функция <KBD>eval_exp()</KBD> для вычисления возвращаемого значения может вызвать ту же функцию.
<H2>Присваивание значений переменным</H2>
<P class="tj">Возвратимся ненадолго к синтаксическому анализатору выражений. Когда встречается оператор присваивания, то сначала вычисляется значение выражения в правой части, а затем это значение присваивается переменной в левой части путем вызова <KBD>assign_var()</KBD>. Однако язык С структурирован и поддерживает глобальные и локальные переменные. Как же тогда в следующей программе
<PRE>
int count;

int main()
{
  int count, i;
  
  count = 10;
  
  i = f();
  
  return 0;
}

int f()
{
  int count;
  count = 99;
  return count;
}
</PRE>
<P class="t">функция <KBD>assign_var()</KBD> знает, какой именно переменной <KBD>count</KBD> нужно присвоить значение? Ответ на это простой: во-первых, локальные переменные имеют приоритет над одноименными глобальными, а, во-вторых, локальные переменные недоступны за пределами своих функций. Проанализируем, как применяются эти правила для разрешения коллизий в приведенных выше примерах операторов присваивания. Для этого рассмотрим функцию <KBD>assign_var()</KBD>:
<PRE>
/* Присваивание переменной значения. */
void assign_var(char *var_name, int value)
{
  register int i;

  /* проверка наличия локальной переменной */
  for(i=lvartos-1; i &gt;= call_stack[functos-1]; i--)  {
    if(!strcmp(local_var_stack[i].var_name, var_name)) {
      local_var_stack[i].value = value;
      return;
    }
  }
  if(i &lt; call_stack[functos-1])
  /* если переменная нелокальная,
     ищем ее в таблице глобальных переменных */
    for(i=0; i &lt; NUM_GLOBAL_VARS; i++)
      if(!strcmp(global_vars[i].var_name, var_name)) {
        global_vars[i].value = value;
        return;
      }
  sntx_err(NOT_VAR); /* переменная не найдена */
}
</PRE>
<P class="tj">Как указывалось в предыдущем разделе, при каждом вызове функции индекс стека локальных переменных (<KBD>lvartos</KBD>) записывается в стек вызова функции. Это значит, что любая локальная переменная (или параметр), определенные в функции, будут записаны в стек выше точки, на которую указывает <KBD>lvartos</KBD>. Следовательно, функция <KBD>assign_var()</KBD> просматривает <KBD>local_var_stack</KBD>, начиная с текущего значения на верхушке стека, причем просмотр прекращается, когда индекс достигает того значения, которое было занесено при последнем вызове функции. Благодаря этому просматриваются только те переменные, которые являются локальными для данной функции. (Это также помогает вызывать рекурсивные функции, потому что текущее значение <KBD>lvartos</KBD> сохраняется при каждом вызове функции.) Таким образом, если в <KBD>main()</KBD> присутствует строка "<KBD>count = 100;</KBD>", то <KBD>assign_var()</KBD> находит локальную переменную <KBD>count</KBD> внутри <KBD>main()</KBD>. В <KBD>f()</KBD> функция <KBD>assign_var()</KBD> находит переменную <KBD>count</KBD>, определенную в <KBD>f()</KBD>, а не в <KBD>main()</KBD>.
<P class="tj">Если имя переменной не совпадает ни с одним из имен локальных переменных, то просматривается список глобальных переменных.
<H2>Выполнение оператора if</H2>
<P class="tj">Итак, базовая структура интерпретатора Little С создана. Теперь к ней можно добавить некоторые управляющие операторы. Каждый раз, когда функция <KBD>interp_block()</KBD> встречает оператор с зарезервированным словом, она вызывает соответствующую функцию, обрабатывающую этот оператор. Один из самых легких операторов — <KBD>if</KBD>. Он обрабатывается функцией <KBD>exec_if()</KBD>:
<PRE>
/* Выполнение оператора if. */
void exec_if(void)
{
  int cond;

  eval_exp(&cond); /* вычисление if-выражения */

  if(cond) { /* истина - интерпретация if-предложения */
    interp_block();
  }
  else { /* в противном случае пропуск if-предложения
            и выполнение else-предложения, если оно есть */
    find_eob(); /* поиск конца блока */
    get_token();

    if(tok != ELSE) {
      putback();  /* восстановление лексемы,
                     если else-предложение отсутсвует */
      return;
    }
    interp_block();
  }
}
</PRE>
<P class="tj">Рассмотрим эту функцию подробнее. В первую очередь она вызывает <KBD>eval_exp()</KBD> для вычисления значения условного выражения. Если условие (<KBD>cond</KBD>) выполнено (т.е. выражение имеет ненулевое значение), то функция вызывает рекурсивно <KBD>interp_block()</KBD>, выполняя тем самым блок <KBD>if</KBD>. Если <KBD>cond</KBD> ложно, вызывается функция <KBD>find_eob()</KBD>, которая передвигает указатель программы на оператор, следующий после блока <KBD>if</KBD>. Если там присутствует <KBD>else</KBD>-предложение, то оно обрабатывается функцией <KBD>exec_if()</KBD> и выполняется блок <KBD>else</KBD>. В противном случае выполняется следующий оператор программы.
<P class="tj">Если блок <KBD>else</KBD> присутствует и выполняется блок <KBD>if</KBD>, то после его выполнения нужно каким-то образом обойти блок <KBD>else</KBD>. Эта задача выполняется в функции <KBD>interp_block()</KBD> путем вызова функции <KBD>find_eob()</KBD>, которая обходит блок после <KBD>else</KBD>. Запомните, что в синтаксически правильной программе <KBD>else</KBD> обрабатывается функцией <KBD>interp_block()</KBD> только в одном случае — после выполнения блока <KBD>if</KBD>. Если выполняется блок <KBD>else</KBD>, то оператор <KBD>else</KBD> обрабатывается функцией <KBD>exec_if()</KBD>.
<H2>Обработка цикла while</H2>
<P class="tj">Интерпретировать цикл <KBD>while</KBD>, как и <KBD>if</KBD>, довольно легко. Ниже приведен текст функции <KBD>exec_while()</KBD>, которая интерпретирует <KBD>while</KBD>:
<PRE>
/* Выполнение цикла while. */
void exec_while(void)
{
  int cond;
  char *temp;

  putback();
  temp = prog;  /* запоминание адреса начала цикла while */
  get_token();
  eval_exp(&cond);  /* вычисление управляющего выражения */
  if(cond) interp_block();  /* если оно истинно, то выполнить
                               интерпритацию */
  else {  /* в противном случае цикл пропускается */
    find_eob();
    return;
  }
  prog = temp;  /* возврат к началу цикла */
}
</PRE>
<P class="tj">Функция <KBD>exec_while()</KBD> работает следующим образом. Сначала лексема <KBD>while</KBD> возвращается во входной поток, а ее адрес сохраняется в переменной <KBD>temp</KBD>. Этот адрес будет использован интерпретатором, чтобы возвратиться к началу цикла (т.е. начать следующую итерацию с начала цикла <KBD>while</KBD>). Далее лексема <KBD>while</KBD> считывается заново для того, чтобы удалить ее из входного потока. После этого вызывается функция <KBD>eval_exp()</KBD>, которая вычисляет значение условного выражения цикла <KBD>while</KBD>. Если условие выполнено (т.е. условное выражение принимает значение ИСТИНА), то рекурсивно вызывается функция <KBD>interp_block()</KBD>, которая интерпретирует блок <KBD>while</KBD>. После возврата управления из <KBD>interp_block()</KBD> программный указатель <KBD>prog</KBD> устанавливается на начало цикла <KBD>while</KBD> и управление передается функции <KBD>interp_block()</KBD>, в которой весь процесс повторяется. Если условное выражение оператора <KBD>while</KBD> принимает значение ЛОЖЬ, то происходит поиск конца блока <KBD>while</KBD>, а затем выход из функции <KBD>exec_while()</KBD>.
<H2>Обработка цикла do-while</H2>
<P class="tj">Обработка цикла <KBD>do-while</KBD> во многом похожа на обработку цикла <KBD>while</KBD>. Когда функция <KBD>interp_block()</KBD> встречает оператор <KBD>do</KBD>, она вызывает функцию <KBD>exec_do()</KBD>, исходный текст которой приведен ниже:
<PRE>
/* Выполнение цикла do. */
void exec_do(void)
{
  int cond;
  char *temp;

  putback();
  temp = prog;  /* запоминание адреса начала цикла */

  get_token(); /* найти начало цикла */
  interp_block(); /* интерпритация цикла */
  get_token();
  if(tok != WHILE) sntx_err(WHILE_EXPECTED);
  eval_exp(&cond); /* проверка условия цикла */
  if(cond) prog = temp; /* если условие истинно,
  то цикл выполняется, в противном случае происходит
  выход из цикла */
}
</PRE>
<P class="tj">Главное отличие цикла <KBD>do-while</KBD> от цикла <KBD>while</KBD> состоит в том, что блок <KBD>do-while</KBD> выполняется всегда как минимум один раз, потому что его условное выражение находится после тела цикла. Поэтому <KBD>exec_do</KBD> сначала запоминает адрес начала цикла в переменной <KBD>temp</KBD>, а затем рекурсивно вызывает <KBD>interp_block()</KBD>, которая интерпретирует блок, ассоциированный с циклом. После возврата управления из <KBD>interp_block()</KBD> идет поиск соответствующего слова <KBD>while</KBD> и вычисляется значение условного выражения. Если условие выполнено, то <KBD>prog</KBD> устанавливается так, что его значение указывает на начало цикла, в противном случае выполнение продолжается со следующего оператора.
<H2>Цикл for</H2>
<P class="tj">Интерпретация цикла <KBD>for</KBD> — задача значительно более трудная, чем интерпретация других операторов. Частично это объясняется тем, что структура цикла <KBD>for</KBD> в языке С была задумана в предположении компиляции программы. Главная трудность заключается в том, что условное выражение <KBD>for</KBD> должно проверяться в начале цикла, а часть приращения должна быть выполнена в его конце. Таким образом, эти две части цикла <KBD>for</KBD> в тексте исходной программы находятся рядом, а их интерпретация разделена выполнением блока цикла. Однако, после некоторой дополнительной работы, цикл <KBD>for</KBD> все же может быть интерпретирован.
<P class="tj">Когда <KBD>interp_block()</KBD> встречает оператор <KBD>for</KBD>, вызывается функция <KBD>exec_for()</KBD>, текст которой приведен ниже:
<PRE>
/* Выполнение цикла for. */
void exec_for(void)
{
  int cond;
  char *temp, *temp2;
  int brace ;

  get_token();
  eval_exp(&cond);  /* инициализирующее выражение */
  if(*token != ';') sntx_err(SEMI_EXPECTED);
  prog++; /* пропуск ; */
  temp = prog;
  for(;;) {
    eval_exp(&cond);  /* проверка условия */
    if(*token != ';') sntx_err(SEMI_EXPECTED);
    prog++; /* пропуск ; */
    temp2 = prog;

    /* поиск начала тела цикла */
    brace = 1;
    while(brace) {
      get_token();
      if(*token == '(') brace++;
      if(*token == ')') brace--;
    }

    if(cond) interp_block();  /* если условие выполнено,
                                 то выполнить интерпритацию */
    else {  /* в противном случае обойти цикл */
      find_eob();
      return;
    }
    prog = temp2;
    eval_exp(&cond); /* вполнение инкремента */
    prog = temp;  /* возврат в начало цикла */
  }
}
</PRE>
<P class="tj">Сначала функция обрабатывает инициализирующее выражение цикла <KBD>for</KBD>. Часть инициализации <KBD>for</KBD> выполняется только один раз; эта часть не подвергается циклической обработке. Затем указатель программы устанавливается так, чтобы он указывал на символ, следующий сразу после той точки с запятой, которой заканчивается часть инициализации. Наконец, после этого значение указателя присваивается переменной <KBD>temp</KBD>. А затем организовывается цикл, в котором проверяется условная часть цикла <KBD>for</KBD> и переменной <KBD>temp2</KBD> присваивается адрес начала части приращения. Далее производится поиск начала тела цикла и его (тела) интерпретация, если условное выражение принимает значение ИСТИНА. (В противном случае производится поиск конца тела цикла и выполнение продолжается с оператора, следующего после цикла <KBD>for</KBD>.) После рекурсивного вызова <KBD>interp_block()</KBD> выполняется часть приращения, после чего весь процесс повторяется.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>На самом деле, конечно, данный алгоритм работает правильно только при условии, что учитываются только значащие фигурные скобки, а фигурные скобки внутри строк, например, не учитываются. (Фигурные скобки внутри строк "съедаются" программой считывания лексем.)
</BLOCKQUOTE>
<HR><A href="../main.htm#29">Содержание</A> | <A href="2905.htm">&lt;&lt;&lt;</A> | <A href="2907.htm">&gt;&gt;&gt;</A>
</BODY></HTML>