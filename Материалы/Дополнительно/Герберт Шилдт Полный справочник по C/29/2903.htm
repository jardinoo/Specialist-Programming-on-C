<HTML><HEAD>
<TITLE>Интерпретация структурированного языка</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#29">Содержание</A> | <A href="2902.htm">&lt;&lt;&lt;</A> | <A href="2904.htm">&gt;&gt;&gt;</A><HR>
<H1>Интерпретация структурированного языка</H1>
<P class="tj">Язык С структурирован. Это значит, что в нем определены отдельные подпрограммы с локальными переменными. В языке С также поддерживается рекурсия. Интересен тот факт, что для структурированного языка иногда легче написать компилятор, чем интерпретатор. Например, когда компилятор создает код вызова функции, он попросту заталкивает аргументы функции в системный стек и применяет к функции команду процессора CALL. При возврате функция записывает возвращаемое значение в регистр процессора, очищает стек и выполняет команду процессора RET. В то же время, если вызов функции выполняет интерпретатор, он должен на какое-то время "приостановиться", запомнить текущее состояние, найти функцию, выполнить ее, сохранить возвращаемое значение, возвратиться в исходную точку программы и восстановить состояние, существовавшее до вызова функции. Пример выполнения этих действий будет приведен далее при рассмотрении интерпретатора. В сущности, интерпретатор должен эмулировать (выполнить другими средствами) команды процессора CALL и RET. Поддержку рекурсии также значительно легче обеспечить в компиляторе, чем в интерпретаторе.
<P class="tj">В моей книге <I>The Art of C</I> (Berkeley, CA: Osborne/McGraw-Hill, 1991), вышедшей несколько лет назад, рассматривалась разработка интерпретатора языка small BASIC. В книге утверждается, что интерпретировать старую версию языка BASIC значительно легче, чем язык С, потому что BASIC изначально был предназначен для интерпретации. Он хорошо приспособлен к интерпретации благодаря своей неструктурированности. В нем все переменные являются глобальными и нет отдельных подпрограмм. Я по-прежнему придерживаюсь этого мнения, однако, если для интерпретатора создать средства поддержки функций, локальных переменных и рекурсии, то интерпретировать язык С станет легче, чем BASIC. Так получилось потому, что в языках типа BASIC на теоретическом уровне довольно много исключений из правил. Например, в нем знак равенства в операторе присваивания означает присваивание, а в операторе сравнения — равенство. Язык С почти полностью лишен подобных несуразностей.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Разработанная автором реализация интерпретатора языка small BASIC coдержит немало полезного для читателей, интересующихся интерпретаторами. Последняя версия интерпретатора small BASIC приведена в <I>The C/C++ Annotated Archives</I> (Berkley, CA: Osborne/McGraw-HilL 1999).
</TABLE> 
<HR><A href="../main.htm#29">Содержание</A> | <A href="2902.htm">&lt;&lt;&lt;</A> | <A href="2904.htm">&gt;&gt;&gt;</A>
</BODY></HTML>