<HTML><HEAD>
<TITLE>Чтение и запись символов</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#08">Содержание</A> | <A href="08.htm">&lt;&lt;&lt;</A> | <A href="0802.htm">&gt;&gt;&gt;</A><HR>
<H1>Чтение и запись символов</H1>
<P class="tj">Самыми простыми из консольных функций ввода/вывода являются <KBD>getchar()</KBD>, которая читает символ с клавиатуры, и <KBD>putchar()</KBD>, которая отображает символ на экране. Первая из этих функций ожидает, пока не будет нажата клавиша, а затем возвращает значение этой клавиши. Кроме того, при нажатии клавиши на клавиатуре на экране дисплея автоматически отображается соответствующий символ. Вторая же функция, <KBD>putchar()</KBD>, отображает символ на экране в текущей позиции курсора. Вот прототипы функций <KBD>getchar()</KBD> и <KBD>putchar()</KBD>:
<PRE>
int getchar(void);
int putchar(int <I>c</I>);
</PRE>
<P class="tj">Как видно из прототипа, считается, что функция <KBD>getchar()</KBD> возвращает целый результат. Однако возвращаемое значение можно присвоить переменной типа <KBD>char</KBD>, что обычно и делается, так как символ содержится в младшем байте. (Старший байт при этом обычно обнулен.) В случае ошибки <KBD>getchar()</KBD> возвращает <KBD>EOF</KBD>. (Макрос <KBD>EOF</KBD> определяется в <KBD>&lt;stdio.h&gt;</KBD> и часто равен -1.)
<P class="tj">Что же касается <KBD>putchar()</KBD>, то несмотря на то, что эта функция объявлена как принимающая целый параметр, она обычно вызывается с символьным аргументом. На самом деле из ее аргумента на экран выводится только младший байт. Функция <KBD>putchar()</KBD> возвращает записанный символ или, в случае ошибки, <KBD>EOF</KBD>.
<P class="tj">В следующей программе продемонстрировано применение <KBD>getchar()</KBD> и <KBD>putchar()</KBD>. В этой программе с клавиатуры вводятся символы, а затем они отображаются на другом регистре. То есть символы, вводимые на верхнем регистре, выводятся на нижнем, а вводимые на нижнем — выводятся на верхнем. Чтобы остановить программу, введите точку.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(void)
{
  char ch;

  printf("Введите какой-нибудь текст
          (для завершения работы введите точку).\n");
  do {
    ch = getchar();

    if(islower(ch)) ch = toupper(ch);
    else ch = tolower(ch);

    putchar(ch);
  } while (ch != '.');

  return 0;
}
</PRE>
<P class="tj">(Эта программа не работает, правда, с кириллическими символами.)
<H2>Трудности использования getchar()</H2>
<P class="tj">Использование <KBD>getchar()</KBD> может быть связано с определенными трудностями. Во многих библиотеках компиляторов эта функция реализуется таким образом, что она заполняет буфер ввода до тех пор, пока не будет нажата клавиша &lt;ENTER&gt;. Это называется <I>построчно буферизованным вводом</I>. Чтобы функция <KBD>getchar()</KBD> возвратила какой-либо символ, необходимо нажать клавишу &lt;ENTER&gt;. Кроме того, эта функция при каждом ее вызове вводит только по одному символу. Поэтому сохранение в буфере целой строки может привести к тому, что в очереди на ввод останутся ждать один или несколько символов, а в интерактивной среде это раздражает достаточно сильно. Хотя <KBD>getchar()</KBD> и можно использовать в качестве интерактивной функции, но это делается редко. Так что если предшествующая программа ведет себя не так, как ожидалось, то вы теперь знаете, в чем тут дело.
<H2>Альтернативы getchar()</H2>
<P class="tj">Так как <KBD>getchar()</KBD>, имеющаяся в библиотеке компилятора, может оказаться неподходящей в интерактивной среде, то для чтения символов с клавиатуры может потребоваться другая функция. В стандарте языка С не определяется никаких функций, которые гарантировали бы интерактивный ввод, но их определения имеются буквально в библиотеках всех компиляторов С. И пусть в стандарте С эти функции не определены, но известны они всем! А известны они благодаря функции <KBD>getchar()</KBD>, которая для большинства программистов явно не подходит.
<P class="tj">У двух из самых распространенных альтернативных функций <KBD>getch()</KBD> и <KBD>getche()</KBD> имеются следующие прототипы:
<PRE>
int getch(void);
int getche(void);
</PRE>
<P class="tj">В библиотеках большинства компиляторов прототипы таких функций находятся в заголовочном файле <KBD>&lt;conio.h&gt;</KBD>. В библиотеках некоторых компиляторов имена этих функций начинаются со знака подчеркивания (_). Например, в Visual C++ компании Microsoft они называются <KBD>_getch()</KBD> и <KBD>_getche()</KBD>.
<P class="tj">Функция <KBD>getch()</KBD> ожидает нажатия клавиши, после которого она немедленно возвращает значение. Причем, символ, введенный с клавиатуры, на экране не отображается. Имеется еще и функция <KBD>getche()</KBD>, которая хоть и такая же, как <KBD>getch()</KBD>, но символ на экране отображает. И если в интерактивной программе необходимо прочитать символ с клавиатуры, то часто вместо <KBD>getchar()</KBD> применяется <KBD>getche()</KBD> или <KBD>getch()</KBD>. Вот, например, предыдущая программа, в которой <KBD>getchar()</KBD> заменена функцией <KBD>getch()</KBD>:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;

int main(void)
{
  char ch;

  printf("Введите какой-нибудь текст
          (для завершения работы введите точку).\n");
  do {
    ch = getch();

    if(islower(ch)) ch = toupper(ch);
    else ch = tolower(ch);

    putchar(ch);
  } while (ch != '.');

  return 0;
}
</PRE>
<P class="tj">Когда выполняется эта версия программы, при каждом нажатии клавиши соответствующий символ сразу передается программе и выводится на другом регистре. А ввод в строках не буферизируется. И хотя в кодах в этой книге функции <KBD>getch()</KBD> и <KBD>getche()</KBD> больше не встречаются, но они вполне могут пригодиться в тех программах, которые напишете вы.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Тогда: когда писались эти слова, при использовании компилятора Visual C++ компании Microsoft функции <KBD>_getch()</KBD> и <KBD>getch()</KBD> были несовместимы с функциями ввода стандартного С, например, с функциями <KBD>scanf()</KBD> или <KBD>gets()</KBD>. Поэтому вам придется вместо стандартных функций использовать такие их специальные версии, как <KBD>cscanf()</KBD> или <KBD>cgets()</KBD>. Чтобы получить более подробную информацию, следует изучить документацию по Visual C++.
</TABLE>
<HR><A href="../main.htm#08">Содержание</A> | <A href="08.htm">&lt;&lt;&lt;</A> | <A href="0802.htm">&gt;&gt;&gt;</A>
</BODY></HTML>