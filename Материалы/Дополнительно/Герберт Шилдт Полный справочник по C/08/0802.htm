<HTML><HEAD>
<TITLE>Чтение и запись строк</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#08">Содержание</A> | <A href="0801.htm">&lt;&lt;&lt;</A> | <A href="0803.htm">&gt;&gt;&gt;</A><HR>
<H1>Чтение и запись строк</H1>
<P class="tj">Среди функций ввода/вывода на консоль есть и более сложные, но и более мощные: это функции <KBD>gets()</KBD> и <KBD>puts()</KBD>, которые позволяют считывать и отображать строки символов.
<P class="tj">Функция <KBD>gets()</KBD> читает строку символов, введенную с клавиатуры, и записывает ее в память по адресу, на который указывает ее аргумент. Символы можно вводить с клавиатуры до тех пор, пока не будет введен символ возврата каретки. Он не станет частью строки, а вместо него в ее конец будет помещен символ конца строки ('0'), после чего произойдет возврат из функции <KBD>gets()</KBD>. На самом деле вернуть символ возврата каретки с помощью этой функции нельзя (а с помощью <KBD>getchar()</KBD> — как раз можно). Перед тем как нажимать &lt;ENTER&gt;, можно исправлять неправильно введенные символы, пользуясь для этого клавишей возврата каретки на одну позицию (клавишей backspace). Вот прототип для <KBD>gets()</KBD>:
<PRE>char *gets(char *<I>cmp</I>);</PRE>
<P class="tj">Здесь <I>cmp</I> — это указатель на массив символов, в который записываются символы, вводимые пользователем, <KBD>gets()</KBD> также возвращает <I>cmp</I>. Следующая программа читает строку в массив <KBD>str</KBD> и выводит ее длину:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[80];

  gets(str);
  printf("Длина в символах равна %d", strlen(str));

  return 0;
}
</PRE>
<P class="tj">Необходимо очень осторожно использовать <KBD>gets()</KBD>, потому что эта функция не проверяет границы массива, в который записываются введенные символы. Таким образом, может случиться, что пользователь введет больше символов, чем помещается в этом массиве. Хотя функция <KBD>gets()</KBD> прекрасно подходит для программ-примеров и простых утилит, предназначенных только для вас, но в профессиональных программах ею лучше не пользоваться. Ее альтернативой, позволяющей предотвратить переполнение массива, будет функция <KBD>fgets()</KBD>, которая описана в следующей главе.
<P class="tj">Функция <KBD>puts()</KBD> отображает на экране свой строковый аргумент, после чего курсор переходит на новую строку. Вот прототип этой функции:
<PRE>int puts(const char *<I>cmp</I>);</PRE>
<P class="t"><KBD>puts()</KBD> признает те же самые <I>управляющие последовательности</I><SUP><A href="#11" name="1">[1]</A></SUP>, что и <KBD>printf()</KBD>, например, \t в качестве символа табуляции. Вызов функции <KBD>puts()</KBD> требует намного меньше ресурсов, чем вызов <KBD>printf()</KBD>. Это объясняется тем, что <KBD>puts()</KBD> может только выводить строку символов, но не может выводить числа или делать преобразования формата. В результате эта функция занимает меньше места и выполняется быстрее, чем <KBD>printf()</KBD>. Поэтому тогда, когда не нужны преобразования формата, часто используется функция <KBD>puts()</KBD>.
<P class="tj">Функция <KBD>puts()</KBD> в случае успешного завершения возвращает неотрицательное значение, а в случае ошибки — <KBD>EOF</KBD>. Однако при записи на консоль обычно предполагают, что ошибки не будет, поэтому значение, возвращаемое <KBD>puts()</KBD>, проверяется редко. Следующий оператор выводит фразу <KBD>Привет</KBD>:
<PRE>puts("Привет");</PRE>
<P class="tj">В таблице 8.1 перечислены основные функции консольного ввода/вывода.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 8.1. Основные функции ввода/вывода</B></CAPTION>
<TR><TH><I>Функция</I><TH><I>Ее действия	</I>
<TR><TD><KBD>getchar()</KBD><TD class="t">Читает символ с клавиатуры; обычно ожидает возврат каретки
<TR><TD><KBD>getche()</KBD><TD class="t">Читает символ, при этом он отображается на экране; не ожидает возврата каретки; в стандарте С не определена, но распространена достаточно широко
<TR><TD><KBD>getch()</KBD><TD class="t">Читает символ, но не отображает его на экране; не ожидает возврата каретки; в стандарте С не определена, но распространена достаточно широко
<TR><TD><KBD>putchar()</KBD><TD class="t">Отображает символ на экране
<TR><TD><KBD>gets()</KBD><TD class="t">Читает строку с клавиатуры
<TR><TD><KBD>puts()</KBD><TD class="t">Отображает строку на экране
</TABLE>
<P class="tj">В следующей программе — простом компьютеризованном словаре — показано применение нескольких основных функций консольного ввода/вывода. Эта программа предлагает пользователю ввести слово, а затем проверяет, совпадает ли оно с каким-либо из тех слов, что находятся в ее базе данных. Если оно там есть, то программа выводит значение слова. Обратите особое внимание на использование косвенной адресации в этой программе. Чтобы легче было понять программу, прежде всего вспомните, что массив <KBD>dic</KBD> — это массив указателей на строки. Обратите внимание, что список должен завершаться двумя нулями.
<PRE>
/* Простой словарь. */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

/* список слов и их значений */
char  *dic[][40] = {
  "атлас", "Том географических и/или топографических карт.",
  "автомобиль", "Моторизоравонное средство передвижения.",
  "телефон", "Средство связи.",
  "самолет", "Летающая машина.",
  "", ""  /* нули, завершающие список */
};

int main(void)
{
  char word[80], ch;
  char **p;

  do {
    puts("\nВведите слово: ");
    scanf("%s", word);

    p = (char **)dic;

    /* поиск слова в словаре и вывод его значения */
    do {
      if(!strcmp(*p, word)) {
        puts("Значение:");
        puts(*(p+1));
        break;
      }
      if(!strcmp(*p, word)) break;
      p = p + 2;  /* продвижение по списку */
    } while(*p);
    if(!*p) puts("Слово в словаре отсутствует.");
    printf("Будете еще вводить? (y/n): ");
    scanf(" %c%*c", &ch);
  } while(toupper(ch) != 'N');

  return 0;
}
</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называются также <I>ESC-последовательностями</I>; в C/C++ — это комбинация символов, обычно используемая для задания неотображаемых символов и символов, имеющих специальное значение. Представление управляющих последовательностей начинается с обратной косой черты.
</BLOCKQUOTE>
<HR><A href="../main.htm#08">Содержание</A> | <A href="0801.htm">&lt;&lt;&lt;</A> | <A href="0803.htm">&gt;&gt;&gt;</A>
</BODY></HTML>