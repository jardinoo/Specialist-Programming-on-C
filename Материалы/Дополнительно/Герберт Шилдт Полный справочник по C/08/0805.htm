<HTML><HEAD>
<TITLE>scanf()</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#08">Содержание</A> | <A href="0804.htm">&lt;&lt;&lt;</A> | <A href="../09/09.htm">&gt;&gt;&gt;</A><HR>
<H1>scanf()</H1>
<P class="tj">Функция <KBD>scanf()</KBD> — это программа ввода общего назначения, выполняющая ввод с консоли. Она может читать данные всех встроенных типов и автоматически преобразовывать числа в соответствующий внутренний формат, <KBD>scanf()</KBD> во многом выглядит как обратная к <KBD>printf()</KBD>. Вот прототип функции <KBD>scanf()</KBD>:
<PRE>int scanf(const char *<I>управляющая_строка</I>, ...);</PRE>
<P class="tj">Эта функция возвращает количество тех элементов данных, которым было успешно присвоено значение. В случае ошибки <KBD>scanf()</KBD> возвращает <KBD>EOF</KBD>, <I>управляющая_строка</I> определяет преобразование считываемых значений при записи их переменные, на которые указывают элементы списка аргументов.
<P class="tj">Управляющая строка состоит из символов трех видов:
<UL type=square>
<LI>спецификаторов преобразования,
<LI>разделителей,
<LI>символов, не являющихся разделителями.
</UL>
<P class="tj">Теперь поговорим о каждом из этих видов.
<H2>Спецификаторы преобразования</H2>
<P class="tj">Каждый спецификатор формата ввода начинается со знака <KBD>%</KBD>, причем спецификаторы формата ввода сообщают функции <KBD>scanf()</KBD> тип считываемых данных. Перечень этих кодов (т.е. литер-спецификаторов) приведен в табл. 8.3. Спецификаторам преобразования в порядке слева направо ставятся в соответствие элементы списка аргументов. Рассмотрим некоторые примеры.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 8.3. Спецификаторы преобразования для функции <KBD>scanf()</KBD></B></CAPTION>
<TR><TH><I>Код</I><TH><I>Значение</I>
<TR><TD><KBD>%a</KBD><TD class="t">Читает значение с плавающей точкой (только С99)
<TR><TD><KBD>%c</KBD><TD class="t">Читает одиночный символ
<TR><TD><KBD>%d</KBD><TD class="t">Читает десятичное целое число
<TR><TD><KBD>%i</KBD><TD class="t">Читает целое число как в десятичном, так и восьмеричном или шестнадцатеричном формате
<TR><TD><KBD>%e</KBD><TD class="t">Читает число с плавающей точкой
<TR><TD><KBD>%f</KBD><TD class="t">Читает число с плавающей точкой
<TR><TD><KBD>%g</KBD><TD class="t">Читает число с плавающей точкой
<TR><TD><KBD>%о</KBD><TD class="t">Читает восьмеричное число
<TR><TD><KBD>%s</KBD><TD class="t">Читает строку
<TR><TD><KBD>%x</KBD><TD class="t">Читает шестнадцатеричное число
<TR><TD><KBD>%p</KBD><TD class="t">Читает указатель
<TR><TD><KBD>%n</KBD><TD class="t">Принимает целое значение, равное количеству уже считанных символов
<TR><TD><KBD>%u</KBD><TD class="t">Читает десятичное целое число без знака
<TR><TD><KBD>%[]</KBD><TD class="t">Читает набор сканируемых символов
<TR><TD><KBD>%%</KBD><TD class="t">Читает знак процента
</TABLE>
<H2>Ввод чисел</H2>
<P class="tj">Для чтения целого числа используйте спецификатор преобразования <KBD>%d</KBD> или <KBD>%i</KBD>. A для чтения числа с плавающей точкой, представленного в стандартном или экспоненциальном виде, используйте спецификатор преобразования <KBD>%e</KBD>, <KBD>%f</KBD> или <KBD>%g</KBD>. (Кроме того, для чтения числа с плавающей точкой стандарт С99 разрешает использовать также спецификатор преобразования <KBD>%a</KBD>.)
<P class="tj">Функцию <KBD>scanf()</KBD> можно использовать для чтения целых значений в восьмеричной или шестнадцатеричной форме, применяя для этого соответственно команды форматирования <KBD>%o</KBD> и <KBD>%x</KBD>, последняя из которых может быть как на верхнем, так и на нижнем регистре. Когда вводятся шестнадцатеричные числа, то буквы от А до F, представляющие шестнадцатеричные цифры, должны быть на том же самом регистре, что и литера-спецификатор. Следующая программа читает восьмеричное и шестнадцатеричное число:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int i, j;

  scanf("%o%x", &i, &j);
  printf("%o %x", i, j);

  return 0;
}
</PRE>
<P class="tj">Функция <KBD>scanf()</KBD> прекращает чтение числа тогда, когда встречается первый нечисловой символ.
<H2>Ввод целых значений без знака</H2>
<P class="tj">Для ввода целого значения без знака используйте спецификатор формата <KBD>%u</KBD>. Например, операторы
<PRE>
unsigned num;
scanf("%u", &num);
</PRE>
<P class="t">выполняют считывание целого числа без знака и присваивают его переменной <KBD>num</KBD>.
<H2>Чтение одиночных символов с помощью scanf()</H2>
<P class="tj">Как уже говорилось в этой главе, одиночные символы можно прочитать с помощью функции <KBD>getchar()</KBD> или какой-либо функции, родственной с ней. Для той же цели можно использовать также вызов функции <KBD>scanf()</KBD> со спецификатором формата <KBD>%c</KBD>. Но, как и большинство реализаций <KBD>getchar()</KBD>, функция <KBD>scanf()</KBD> при использовании спецификатора преобразования <KBD>%c</KBD> обычно будет выполнять построчно буферизованный ввод. В интерактивной среде такая ситуация вызывает определенные трудности.
<P class="tj">При чтении одиночного символа символы разделителей читаются так же, как и любой другой символ, хотя при чтении данных других типов разделители интерпретируются как разделители полей. Например, при вводе с входного потока "x y" фрагмент кода
<PRE>scanf("%c%c%c", &a, &b, &c);</PRE>
<P class="t">помещает символ <KBD>x</KBD> в <KBD>a</KBD>, пробел — в <KBD>b</KBD>, а символ <KBD>y</KBD> — в <KBD>c</KBD>.
<H2>Чтение строк</H2>
<P class="tj">Для чтения из входного потока строки можно использовать функцию <KBD>scanf()</KBD> со спецификатором преобразования <KBD>%s</KBD>. Использование спецификатора преобразования <KBD>%s</KBD> заставляет <KBD>scanf()</KBD> читать символы до тех пор, пока не встретится какой-либо разделитель. Читаемые символы помещаются в символьный массив, на который указывает соответствующий аргумент, а после введенных символов еще добавляется символ конца строки ('0'). Что касается <KBD>scanf()</KBD>, то таким разделителем может быть пробел, разделитель строк, табуляция, вертикальная табуляция или подача страницы. В отличие от <KBD>gets()</KBD>, которая читает строку, пока не будет нажата клавиша &lt;ENTER&gt;, <KBD>scanf()</KBD> читает строку до тех пор, пока не встретится первый разделитель. Это означает, что <KBD>scanf()</KBD> нельзя использовать для чтения строки "это испытание", потому что после пробела процесс чтения прекратится. Чтобы увидеть, как действует спецификатор <KBD>%s</KBD>, попробуйте при выполнении этой программы ввести строку "привет всем":
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  char str[80];

  printf("Введите строку: ");
  scanf("%s", str);
  printf("Вот Ваша строка: %s", str);

  return 0;
}
</PRE>
<P class="tj">Программа выведет только часть строки, то есть слово <KBD>привет</KBD>.
<H2>Ввод адреса</H2>
<P class="tj">Для ввода какого-либо адреса памяти используйте спецификатор преобразования <KBD>%p</KBD>. Этот спецификатор преобразования заставляет функцию <KBD>scanf()</KBD> читать адрес в том формате, который определен архитектурой центрального процессора. Например, следующая программа вначале вводит адрес, а затем отображает то, что находится в памяти по этому адресу:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  char *p;

  printf("Введите адрес: ");
  scanf("%p", &p);
  printf("По адресу %p находится %c\n", p, *p);

  return 0;
}
</PRE>
<H2>Спецификатор %n</H2>
<P class="tj">Спецификатор <KBD>%n</KBD> указывает, что <KBD>scanf()</KBD> должна поместить количество символов, считанных (до того момента, когда встретился <KBD>%n</KBD>) из входного потока в целую переменную, указанную соответствующим аргументом.
<H2>Использование набора сканируемых символов</H2>
<P class="tj">Функция <KBD>scanf()</KBD> поддерживает спецификатор формата общего назначения, называемый набором сканируемых символов (scanset). <I>Набор сканируемых символов</I> представляет собой множество символов. Когда <KBD>scanf()</KBD> обрабатывает такое множество, то вводит только те символы, которые входят в набор сканируемых символов. Читаемые символы будут помещаться в массив символов, который указан аргументом, соответствующим набору сканируемых символов. Этот набор определяется следующим образом: все те символы, которые предстоит сканировать, помещают в квадратные скобки. Непосредственно перед открывающей квадратной скобкой должен находиться знак <KBD>%</KBD>. Например, следующий набор сканируемых символов дает указание <KBD>scanf()</KBD> сканировать только символы X, Y и Z:
<PRE>%[XYZ]</PRE>
<P class="tj">При использовании набора сканируемых символов функция <KBD>scanf()</KBD> продолжает читать символы, помещая их в соответствующий массив символов, пока не встретится символ, не входящий в этот набор. При возвращении из <KBD>scanf()</KBD> в массиве символов будет находиться строка, состоящая из считанных символов, причем эта строка будет заканчиваться символом конца строки. Чтобы увидеть, как это все работает, запустите следующую программу:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int i;
  char str[80], str2[80];

  scanf("%d%[abcdefg]%s", &i, str, str2);
  printf("%d %s %s", i, str, str2);

  return 0;
}
</PRE>
<P class="tj">Введите <KBD>123abcdtye</KBD>, а затем нажмите клавишу &lt;ENTER&gt;. После этого программа выведет <KBD>123 abed tye</KBD>. Так как в данном случае 't' не входит в набор сканируемых символов, то <KBD>scanf()</KBD> прекратила чтение символов в переменную <KBD>str</KBD> сразу после того, как встретился символ 't'. Оставшиеся символы были помещены в переменную <KBD>str2</KBD>.
<P class="tj">Кроме того, можно указать набор сканируемых символов, работающий с точностью до наоборот; тогда первым символом в таком наборе должен быть <KBD>^</KBD>. Этот символ дает указание <KBD>scanf()</KBD> принимать любой символ, который не входит в набор сканируемых символов.
<P class="tj">В большинстве реализаций для указания диапазона можно использовать дефис. Например, указанный ниже набор сканируемых символов дает функции <KBD>scanf()</KBD> указание принимать символы от А до Z:
<PRE>%[A-Z]</PRE>
<P class="tj">Следует обратить внимание на такой важный момент: набор сканируемых символов чувствителен к регистру букв. Если нужно сканировать буквы и на верхнем, и на нижнем регистре, то их надо указывать отдельно для каждого регистра.
<H2>Пропуск лишних разделителей</H2>
<P class="tj">Разделитель в управляющей строке дает <KBD>scanf()</KBD> указание пропустить в потоке ввода один или несколько начальных разделителей. Разделителями являются пробелы, табуляции, вертикальные табуляции, подачи страниц и разделители строк. В сущности, один разделитель в управляющей строке заставляет <KBD>scanf()</KBD> читать, но не сохранять любое количество (в том числе и нулевое) разделителей, которые находятся перед первым символом, не являющимся разделителем.
<H2>Символы в управляющей строке, не являющиеся разделителями</H2>
<P class="tj">Если в управляющей строке находится символ, не являющийся разделителем, то функция <KBD>scanf()</KBD> прочитает символ из входного потока, проверит, совпадает ли прочитанный символ с указанным в управляющей строке, и в случае совпадения пропустит прочитанный символ. Например, "<KBD>%d,%d</KBD>" заставляет <KBD>scanf()</KBD> прочитать целое значение, прочитать запятую и пропустить ее (если это была запятая!), а затем прочитать следующее целое значение. Если же указанный символ во входном потоке не будет найден, то <KBD>scanf()</KBD> завершится. Когда нужно прочитать и отбросить знак процента, то в управляющей строке следует указать <KBD>%%</KBD>.
<H2>Функции scanf() необходимо передавать адреса</H2>
<P class="tj">Для всех переменных, которые должны получить значения с помощью <KBD>scanf()</KBD>, должны быть переданы адреса. Это означает, что все аргументы должны быть указателями. Вспомните, что именно так в С создается вызов по ссылке и именно тогда функция может изменить содержимое аргумента. Например, для считывания целого значения в переменную <KBD>count</KBD> можно использовать такой вызов функции <KBD>scanf()</KBD>:
<PRE>scanf("%d", &count);</PRE>
<P class="tj">Строки будут читаться в символьные массивы, а имя массива без индекса является адресом первого его элемента. Таким образом, чтобы прочитать строку в символьный массив, можно использовать оператор
<PRE>scanf("%s", str);</PRE>
<P class="tj">В этом случае <KBD>str</KBD> является указателем, и потому перед ним не нужно ставить оператор <KBD>&</KBD>.
<H2>Модификаторы форматат</H2>
<P class="tj">Как и <KBD>printf()</KBD>, функция <KBD>scanf()</KBD> дает возможность модифицировать некоторое число своих спецификаторов формата. В спецификаторах формата моно указать модификатор максимальной длины поля. Это целое число, расположенное между <KBD>%</KBD> и спецификатором формата; оно ограничивает число символов, считываемых из этого поля. Например, чтобы считывать в переменную <KBD>str</KBD> не более 20 символов, пишите
<PRE>scanf("%20s", str);</PRE>
<P class="tj">Если поток ввода содержит больше 20 символов, то при следующем вызове функций ввода считывание начнется после того места, где оно закончилось при предыдущем вызове. Например, если вы в ответ на вызов <KBD>scanf()</KBD> из этого примера введете
<PRE>ABCDEFGHIJKLMNOPRSTUVWXYZ</PRE>
<P class="t">то в <KBD>str</KBD> из-за спецификатора максимальной ширины поля будет помещено только 20 символов, то есть символы вплоть до Т. Это значит, что оставшиеся символы UVWXYZ пока еще не прочитаны. При следующем вызове <KBD>scanf()</KBD>, например при выполнении оператора
<PRE>scanf("%s", str);</PRE>
<P class="t">в <KBD>str</KBD> будут помешены буквы UVWXYZ. Ввод из поля может завершиться и до того, как будет достигнута максимальная длина поля — если встретится разделитель. В таком случае <KBD>scanf()</KBD> переходит к следующему полю.
<P class="tj">Чтобы прочитать длинное целое, перед спецификатором формата поместите <KBD>l</KBD> (эль). А для чтения короткого целого значения перед спецификатором формата следует поместить <KBD>n</KBD>. Эти модификаторы можно использовать со следующими кодами форматов: <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD>, <KBD>x</KBD> и <KBD>n</KBD>.
<P class="tj">По умолчанию спецификаторы <KBD>f</KBD>, <KBD>e</KBD> и <KBD>g</KBD> дают <KBD>scanf()</KBD> указание присваивать данные переменной типа <KBD>float</KBD>. Если перед одним из этих спецификаторов будет помещен <KBD>l</KBD> (эль), то <KBD>scanf()</KBD> будет присваивать данные переменной типа <KBD>double</KBD>. Использование <KBD>L</KBD> дает <KBD>scanf()</KBD> указание, чтобы переменная, принимающая данные, имела тип <KBD>long double</KBD>.
<P class="tj">Если в компиляторе предусмотрена обработка <I>двухбайтовых символов</I><SUP><A href="#11" name="1">[1]</A></SUP>, добавленных в язык С Поправкой 1 от 1995 года, то модификатор <KBD>l</KBD> можно также использовать с такими кодами формата, как <KBD>c</KBD> и <KBD>s</KBD>. <KBD>l</KBD> непосредственно перед <KBD>c</KBD> является признаком указателя на объект типа <KBD>wchar_t</KBD>. А <KBD>l</KBD> непосредственно перед <KBD>s</KBD> — признак указателя на массив элементов типа <KBD>wchar_t</KBD>. Кроме того, <KBD>l</KBD> также применяется для модификации набора сканируемых символов, чтобы этот набор можно было использовать для двухбайтовых символов.
<P class="tj">В Стандарте С99, кроме перечисленных, предусмотрены также модификаторы <KBD>ll</KBD> и <KBD>hh</KBD>, последний из которых можно применять к спецификаторам <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD>, <KBD>x</KBD> или <KBD>n</KBD>. Он является признаком того, что соответствующий аргумент является указателем на значение, типа <KBD>signed</KBD> или <KBD>unsigned char</KBD>. Кроме того, к спецификаторам <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD>, <KBD>x</KBD> и <KBD>n</KBD> можно применять и <KBD>ll</KBD>, этот спецификатор является признаком того, что соответствующий аргумент является указателем на значение типа <KBD>signed</KBD> (или <KBD>unsigned</KBD>) <KBD>long long int</KBD>.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">В С99 для функции <KBD>scanf()</KBD> имеются еще и другие модификаторы типа; о них рассказывается в <A href="../II.htm">части II</A>.
</TABLE>
<H2>Подавление ввода</H2>
<P class="tj"><KBD>scanf()</KBD> может прочитать поле, но не присваивать прочитанное значение никакой переменной; для этого надо перед литерой-спецификатором формата поля поставить звездочку, <KBD>*</KBD>. Например, когда выполняется оператор
<PRE>scanf("%d%*c%d", &x, &y);</PRE>
<P class="t">можно ввести пару координат <KBD>10,10</KBD>. Запятая будет прочитана правильно, но ничему не будет присвоена. Подавление присвоения особенно полезно тогда, когда нужно обработать только часть того, что вводится.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называются также <I>символами в расширенном 16-битном алфавите</I> или <I>символами уникода</I>. (Unicode (уникод) — 16-битовый стандарт кодирования символов, позволяюший представлять алфавиты всех существующих в мире языков.)
</BLOCKQUOTE>
<HR><A href="../main.htm#08">Содержание</A> | <A href="0804.htm">&lt;&lt;&lt;</A> | <A href="../09/09.htm">&gt;&gt;&gt;</A>
</BODY></HTML>