<HTML><HEAD>
<TITLE>printf()</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<STYLE type="text/css">
.size {font-size:20pt;}
</STYLE>
<A href="../main.htm#08">Содержание</A> | <A href="0803.htm">&lt;&lt;&lt;</A> | <A href="0805.htm">&gt;&gt;&gt;</A><HR>
<H1>printf()</H1>
<P class="tj">Вот прототип функции <KBD>printf()</KBD>:
<PRE>int printf(const char *<I>управляющая_строка</I>, ...);</PRE>
<P class="tj">Функция <KBD>printf()</KBD> возвращает число выведенных символов или отрицательное значение в случае ошибки.
<P class="tj"><I>Управляющая_строка</I><SUP><A href="#11" name="1">[1]</A></SUP> состоит из элементов двух видов. Первый из них — это символы, которые предстоит вывести на экран; второй — это <I>спецификаторы преобразования</I><SUP><A href="#22" name="2">[2]</A></SUP>, которые определяют способ вывода стоящих за ними аргументов. Каждый такой спецификатор начинается со знака процента, за которым следует код формата. Аргументов должно быть ровно столько, сколько и спецификаторов, причем спецификаторы преобразования и аргументы должны попарно соответствовать друг другу в направлении слева направо. Например, в результате такого вызова <KBD>printf()</KBD>
<PRE>printf("Мне нравится язык %c %s", 'C', "и к тому же очень сильно!");</PRE>
<P class="tj">Будет выведено
<PRE>Мне нравится язык C и к тому же очень сильно!</PRE>
<P class="tj">В этом примере первому спецификатору преобразования (<KBD>%c</KBD>), соответствует символ 'C', а второму (<KBD>%s</KBD>), — строка "и к тому же очень сильно!".
<P class="tj">В функции <KBD>printf()</KBD>, как видно из табл. 8.2, имеется широкий набор спецификаторов преобразования.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 8.2. Спецификаторы преобразования для функции <KBD>printf()</KBD></B></CAPTION>
<TR><TH><I>Код</I><TH><I>Формат</I>
<TR><TD><KBD>%a</KBD><TD class="t">Шестнадцатеричное в виде <I>0xh.hhhhp+d</I> (только С99)
<TR><TD><KBD>%A</KBD><TD class="t">Шестнадцатеричное в виде <I>0Xh.hhhhP+d</I> (только С99)
<TR><TD><KBD>%c</KBD><TD class="t">Символ
<TR><TD><KBD>%d</KBD><TD class="t">Десятичное целое со знаком
<TR><TD><KBD>%i</KBD><TD class="t">Десятичное целое со знаком
<TR><TD><KBD>%e</KBD><TD class="t">Экспоненциальное представление ('е' на нижнем регистре)
<TR><TD><KBD>%E</KBD><TD class="t">Экспоненциальное представление ('Е' на верхнем регистре)
<TR><TD><KBD>%f</KBD><TD class="t">Десятичное с плавающей точкой
<TR><TD><KBD>%g</KBD><TD class="t">В зависимости от того, какой вывод будет короче, используется <KBD>%е</KBD> или <KBD>%f</KBD>
<TR><TD><KBD>%G</KBD><TD class="t">В зависимости от того, какой вывод будет короче, используется <KBD>%Е</KBD> или <KBD>%F</KBD>
<TR><TD><KBD>%o</KBD><TD class="t">Восьмеричное без знака
<TR><TD><KBD>%s</KBD><TD class="t">Строка символов
<TR><TD><KBD>%u</KBD><TD class="t">Десятичное целое без знака
<TR><TD><KBD>%x</KBD><TD class="t">Шестнадцатеричное без знака (буквы на нижнем регистре)
<TR><TD><KBD>%X</KBD><TD class="t">Шестнадцатеричное без знака (буквы на верхнем регистре)
<TR><TD><KBD>%p</KBD><TD class="t">Выводит указатель
<TR><TD><KBD>%n</KBD><TD class="t">Аргумент, соответствующий этому спецификатору, должен быть указателем на целочисленную переменную. Спецификатор позволяет сохранить в этой переменной количество записанных символов (записанных до того места, в котором находится код <KBD>%n</KBD>)
<TR><TD><KBD>%%</KBD><TD class="t">Выводит знак <KBD>%</KBD>
</TABLE>
<H2>Вывод символов</H2>
<P class="tj">Для вывода отдельного символа используйте <KBD>%с</KBD>. В результате соответствующий аргумент будет выведен на экран без изменения.
<P class="tj">Для вывода строки используйте <KBD>%s</KBD>.
<H2>Вывод чисел</H2>
<P class="tj">Числа в десятичном формате со знаком отображаются с помощью спецификатора преобразования <KBD>%d</KBD> или <KBD>%i</KBD>. Эти спецификаторы преобразования эквивалентны; оба поддерживаются в силу сложившихся привычек программистов, например, из-за желания поддерживать те же спецификаторы, которые применяются в функции <KBD>scanf()</KBD>.
<P class="tj">Для вывода целого значения без знака используйте <KBD>%u</KBD>.
<P class="tj">Спецификатор преобразования <KBD>%f</KBD> дает возможность выводить числа в формате с плавающей точкой. Соответствующий аргумент должен иметь тип <KBD>double</KBD>.
<P class="tj">Спецификаторы преобразования %e и %E в функции <KBD>printf()</KBD> позволяют отображать аргумент типа <KBD>double</KBD> в экспоненциальном формате. В общем виде числа в таком формате выглядят следующим образом:
<PRE>x.dddddE+/-yy</PRE>
<P class="tj">Чтобы отобразить букву E в верхнем регистре, используйте спецификатор преобразования <KBD>%E</KBD>; в противном случае используйте спецификатор преобразования <KBD>%e</KBD>.
<P class="tj">Спецификатор преобразования <KBD>%g</KBD> или <KBD>%G</KBD> указывает, что функции <KBD>printf()</KBD> необходимо выбрать один из спецификаторов: <KBD>%f</KBD> или <KBD>%e</KBD>. В результате <KBD>printf()</KBD> выберет тот спецификатор преобразования, который позволяет сделать самый короткий вывод. Если нужно, чтобы при выборе экспоненциального формата буква E отображалась на верхнем регистре, используйте спецификатор преобразования <KBD>%G</KBD>; в противном случае используйте спецификатор преобразования <KBD>%g</KBD>.
<P class="tj">Применение спецификатора преобразования <KBD>%g</KBD> показано в следующей программе:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  double f;

  for(f=1.0; f&lt;1.0e+10; f=f*10)
    printf("%g ", f);

  return 0;
}
</PRE>
<P class="tj">В результате выполнения получится следующее:
<PRE>1  10  100  1000  10000  100000  1e+06  1e+07  1e+08  1e+09</PRE>
<P class="tj">Целые числа без знака можно выводить в восьмеричном или шестнадцатеричном формате, используя спецификатор преобразования <KBD>%o</KBD> или <KBD>%x</KBD>. Так как в шестнадцатеричной системе для представления чисел от 10 до 15 используются буквы от А до F, то эти буквы можно выводить на верхнем или на нижнем регистре. Как показано ниже, в первом случае используется спецификатор преобразования <KBD>%X</KBD>, а во втором — спецификатор преобразования <KBD>%x</KBD>:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  unsigned num;

  for(num=0; num &lt; 16; num++) {
    printf("%o ", num);
    printf("%x ", num);
    printf("%X\n", num);
  }

  return 0;
}
</PRE>
<P class="tj">Вот что вывела эта программа:
<PRE>
0 0 0
1 1 1
2 2 2
3 3 3
4 4 4
5 5 5
6 6 6
7 7 7
10 8 8
11 9 9
12 a A
13 b B
14 c C
15 d D
16 e E
17 f F
</PRE>
<H2>Отображение адреса</H2>
<P class="tj">Для отображения адреса используйте спецификатор преобразования <KBD>%p</KBD>. Этот спецификатор преобразования дает <KBD>printf()</KBD> указание отобразить машинный адрес в формате, совместимом с адресацией, которая используется компьютером. Следующая программа отображает адрес переменной <KBD>sample</KBD>:
<PRE>
#include &lt;stdio.h&gt;

int sample;

int main(void)
{
  printf("%p", &sample);

  return 0;
}
</PRE>
<H2>Спецификатор преобразования %n</H2>
<P class="tj">Спецификатор <KBD>%n</KBD> довольно значительно отличается от остальных спецификаторов преобразования. Когда функция <KBD>printf()</KBD> встречает его, ничто не выводится. Вместо этого выполняется совсем другое действие: в целую переменную, указанную соответствующим аргументом функции, записывается количество выведенных символов. Другими словами, значение, которое соответствует спецификатору преобразования <KBD>%n</KBD>, должно быть указателем на переменную. После завершения вызова <KBD>printf()</KBD> в этой переменной будет храниться количество символов, выведенных до того момента, когда встретился спецификатор преобразования <KBD>%n</KBD>. Чтобы уяснить смысл этого несколько необычного спецификатора преобразования, разберитесь, как работает следующая программа:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int count;

  printf("this%n is a test\n", &count);
  printf("%d", count);

  return 0;
}
</PRE>
<P class="tj">Программа отображает строку <KBD>Это проверка</KBD>, после которой появляется число <KBD>3</KBD>. Спецификатор преобразования <KBD>%n</KBD> в основном используется в программе для выполнения динамического форматирования.
<H2>Модификаторы формата</H2>
<P class="tj">Во многих спецификаторах преобразования можно указать модификаторы<SUP><A href="#33" name="3">[3]</A></SUP>, которые слегка меняют их значение. Например, можно указывать минимальную ширину поля, количество десятичных разрядов и выравнивание по левому краю. Модификатор формата помещают между знаком процента и кодом формата. Об этих модификаторах сейчас и пойдет речь.
<H2>Модификаторы минимальной ширины поля</H2>
<P class="tj">Целое число, расположенное между знаком <KBD>%</KBD> и кодом формата, играет роль <I>модификатора минимальной ширины поля</I>. Если указан модификатор минимальной ширины поля, то чтобы ширина поля вывода была не меньше указанной минимальной длины, при необходимости вывод будет дополнен пробелами. Если же выводятся строки или числа, которые длиннее указанного минимума, то они все равно будут отображаться полностью. По умолчанию для дополнения используются пробелы. А если для этого надо использовать нули, то перед модификатором ширины поля следует поместить 0. Например, <KBD>%05d</KBD> означает, что любое число, количество цифр которого меньше пяти, будет дополнено таким количеством нулей, чтобы число состояло из пяти цифр. В следующей программе показано, как применяется модификатор минимальной ширины поля:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  double item;

  item = 10.12304;

  printf("%f\n", item);
  printf("%10f\n", item);
  printf("%012f\n", item);

  return 0;
}
</PRE>
<P class="tj">Вот что выводится при выполнении этой программы:
<PRE>
10.123040
 10.123040
00010.123040
</PRE>
<P class="tj">Модификатор минимальной ширины поля чаще всего используется при создании таблиц, в которых столбцы должны быть выровнены по вертикали. Например, следующая программа выводит таблицу квадратов и кубов чисел от 1 до 19:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int i;

  /* вывод таблицы квадратов и кубов */
  for(i=1; i&lt;20; i++)
    printf("%8d %8d %8d\n", i, i*i, i*i*i);

  return 0;
}
</PRE>
А вот пример полученного с ее помошью вывода:
<PRE>
 1       1       1
 2       4       8
 3       9      27
 4      16      64
 5      25     125
 6      36     216
 7      49     343
 8      64     512
 9      81     729
10     100    1000
11     121    1331
12     144    1728
13     169    2197
14     196    2744
15     225    3375
16     256    4096
17     289    4913
18     324    5832
19     361    6859
</PRE>
<H2>Модификаторы точности</H2>
<P class="tj"><I>Модификатор точности</I> следует за модификатором минимальной ширины поля (если таковой имеется). Он состоит из точки и расположенного за ней целого числа. Значение этого модификатора зависит от типа данных, к которым его применяют.
<P class="tj">Когда модификатор точности применяется к данным с плавающей точкой, для преобразования которых используются спецификаторы преобразования <KBD>%f</KBD>, <KBD>%e</KBD> или <KBD>%E</KBD>, то он определяет количество выводимых десятичных разрядов. Например, <KBD>%10.4f</KBD> означает, что ширина поля вывода будет не менее 10 символов, причем для десятичных разрядов будет отведено четыре позиции.
<P class="tj">Если модификатор точности применяется к <KBD>%g</KBD> или <KBD>%G</KBD>, то он определяет количество значащих цифр.
<P class="tj">Примененный к строкам, модификатор точности определяет максимальную длину поля. Например, <KBD>%5.7s</KBD> означает, что длина выводимой строки будет составлять минимум пять и максимум семь символов. Если строка окажется длиннее, чем максимальная длина поля, то конечные символы выводиться не будут.
<P class="tj">Если модификатор точности применяется к целым типам, то он определяет минимальное количество цифр, которые будут выведены для каждого из чисел. Чтобы получилось требуемое количество цифр, добавляется некоторое количество ведущих нулей.
<P class="tj">В следующей программе показано, как можно использовать модификатор точности:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  printf("%.4f\n", 123.1234567);
  printf("%3.8d\n", 1000);
  printf("%10.15s\n", "Это простая проверка.");

  return 0;
}
</PRE>
<P class="tj">Вот что выводится при выполнении этой программы:
<PRE>
123.1235
00001000
Это простая про</PRE>
<H2>Выравнивание вывода</H2>
<P class="tj">По умолчанию весь вывод выравнивается по правому краю. То есть если ширина поля больше ширины выводимых данных, то эти данные располагаются по правому краю поля. Вывод по левому краю можно назначить принудительно, поместив знак минус прямо за <KBD>%</KBD>. Например, <KBD>%-l0.2f</KBD> означает, что число с плавающей точкой и с двумя десятичными разрядами будет выровнено по левому краю 10-символьного поля.
<P class="tj">В следующей программе показано, как применяется выравнивание по левому краю:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  printf(".........................\n");
  printf("по правому краю: %8d\n", 100);
  printf(" по левому краю: %-8d\n", 100);

  return 0;
}
</PRE>
<P class="tj">И вот что получилось:
<PRE>
.........................
по правому краю:      100
 по левому краю: 100
</PRE>
<H2>Обработка данных других типов</H2>
<P class="tj">Некоторые модификаторы в вызове функции <KBD>printf()</KBD> позволяют отображать целые числа типа <KBD>short</KBD> и <KBD>long</KBD>. Такие модификаторы можно использовать для следующих спецификаторов типа: <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD> и <KBD>x</KBD>. Модификатор <KBD>l</KBD> (эль) в вызове функции <KBD>printf()</KBD> указывает, что за ним следуют данные типа <KBD>long</KBD>. Например, <KBD>%ld</KBD> означает, что надо выводить данные типа <KBD>long int</KBD>. После модификатора <KBD>h</KBD> функция <KBD>printf()</KBD> выведет целое значение в виде <KBD>short</KBD>. Например, <KBD>%hu</KBD> означает, что выводимые данные имеют тип <KBD>short unsigned int</KBD>.
<P class="tj">Модификаторы <KBD>l</KBD> и <KBD>h</KBD> можно также применить к спецификатору <KBD>n</KBD>. Это делается с той целью, чтобы показать — соответствующий аргумент является указателем соответственно на длинное (<KBD>long</KBD>) или короткое (<KBD>short</KBD>) целое.
<P class="tj">Если компилятор поддерживает обработку символов в расширенном 16-битном алфавите, добавленную Поправкой 1 от 1995 года (1995 Amendment 1), то для указания символа в расширенном 16-битном алфавите вы можете применять модификатор 1 для спецификатора преобразования <KBD>c</KBD>. Кроме того, для указания строки из символов в расширенном 16-битном алфавите можно применять модификатор 1 для спецификатора преобразования <KBD>s</KBD>.
<P class="tj">Модификатор <KBD>L</KBD> может находиться перед спецификаторами преобразования с плавающей точкой <KBD>e</KBD>, <KBD>f</KBD> и <KBD>g</KBD>, и указывать этим, что преобразуется значение <KBD>long double</KBD>.
<P class="tj">В Стандарте С99 вводится два новых модификатора формата: <KBD>hh</KBD> и <KBD>ll</KBD>. Модификатор <KBD>hh</KBD> можно применять для спецификаторов преобразования <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD>, <KBD>x</KBD> или <KBD>n</KBD>. Он показывает, что соответствующий аргумент является значением <KBD>signed</KBD> или <KBD>unsigned char</KBD> или, в случае <KBD>n</KBD>, указателем на переменную <KBD>signed char</KBD>. Модификатор <KBD>ll</KBD> также можно применять для спецификаторов преобразования <KBD>d</KBD>, <KBD>i</KBD>, <KBD>o</KBD>, <KBD>u</KBD>, <KBD>x</KBD> или <KBD>n</KBD>. Он показывает, что соответствующий аргумент является значением <KBD>signed</KBD> или <KBD>unsigned long long int</KBD> или, в случае <KBD>n</KBD>, указателем на <KBD>long long int</KBD>. В С99 также разрешается применять <KBD>l</KBD> для спецификаторов преобразования с плавающей точкой <KBD>a</KBD>, <KBD>е</KBD>, <KBD>f</KBD> и <KBD>g</KBD>; впрочем, это не дает никакого результата.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">В составе С99 имеются некоторые дополнительные модификаторы типа для функции <KBD>printf()</KBD>; о них рассказывается в <A href="../II.htm">части II</A>.
</TABLE>
<H2>Модификатор * и #</H2>
<P class="tj">Для некоторых из своих спецификаторов преобразования функция <KBD>printf()</KBD> поддерживает два дополнительных модификатора: <KBD>*</KBD> и <KBD>#</KBD>.
<P class="tj">Непосредственное расположение <KBD>#</KBD> перед спецификаторами преобразования <KBD>g</KBD>, <KBD>G</KBD>, <KBD>f</KBD>, <KBD>Е</KBD> или <KBD>e</KBD> означает, что при выводе обязательно появится десятичная точка — даже если десятичных цифр нет. Если вы поставите <KBD>#</KBD> непосредственно перед <KBD>x</KBD> или <KBD>X</KBD>, то шестнадцатеричное число будет выведено с префиксом <KBD>0x</KBD>. Если <KBD>#</KBD> будет непосредственно предшествовать спецификатору преобразования <KBD>o</KBD>, число будет выведено с ведущим нулем. К любым другим спецификаторам преобразования модификатор <KBD>#</KBD> применять нельзя. (В С99 модификатор <KBD>#</KBD> можно применять по отношению к преобразованию <KBD>%а</KBD>; это значит, что обязательно будет выведена десятичная точка.)
<P class="tj">Модификаторы минимальной ширины поля и точности можно передавать функции <KBD>printf()</KBD> не как константы, а как аргументы. Для этого в качестве заполнителя используйте звездочку (<KBD>*</KBD>). При сканировании строки формата функция <KBD>printf()</KBD> будет каждой звездочке <KBD>*</KBD> из этой строки ставить в соответствие очередной аргумент, причем в том порядке, в каком расположены аргументы. Например, при выполнении оператора, показанного на рис. 8.1, минимальная ширина поля будет равна 10 символам, точность — 4, а отображаться будет число <KBD>123.3</KBD>.
<P class="tj">В следующей программе показано применение обоих модификаторов <KBD>#</KBD> и <KBD>*</KBD>:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  printf("%x %#x\n", 10, 10);
  printf("%*.*f", 10, 4, 1234.34);

  return 0;
}
</PRE>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 8.1. Обратите внимание на то, каким образом звездочке (*) ставится в соответствие определенное значение</I>
<TR><TD>
<PRE class="size">
printf("%*.*f", 10.4, 123.3);
         | |     |     |
         '-+-----'     |
           |           |
           '-----------'
</PRE>
</TABLE> 
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Часто называется просто <I>форматной строкой</I>, <I>форматным стрингом</I> или <I>форматом</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>Называются также <I>спецификациями формата</I>.
<P class="tj"><SUP><A href="#3" name="33">[3]</A></SUP>Называются также <I>спецификаторами</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#08">Содержание</A> | <A href="0803.htm">&lt;&lt;&lt;</A> | <A href="0805.htm">&gt;&gt;&gt;</A>
</BODY></HTML>