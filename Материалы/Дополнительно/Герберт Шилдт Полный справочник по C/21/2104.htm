<HTML><HEAD>
<TITLE>Пузырьковая сортировка</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#21">Содержание</A> | <A href="2103.htm">&lt;&lt;&lt;</A> | <A href="2105.htm">&gt;&gt;&gt;</A><HR>
<H1>Пузырьковая сортировка</H1>
<P class="tj">Самый известный (и пользующийся дурной славой) алгоритм — <I>пузырьковая сортировка (bubble sort, сортировка методом пузырька,</I> или просто <I>сортировка пузырьком)</I><SUP><A href="#11" name="1">[1]</A></SUP>. Его популярность объясняется интересным названием и простотой самого алгоритма. Тем не менее, в общем случае это один из самых худших алгоритмов сортировки.
<P class="tj">Пузырьковая сортировка относится к классу обменных сортировок, т.е. к классу сортировок методом обмена. Ее алгоритм содержит повторяющиеся сравнения (т.е. многократные сравнения одних и тех же элементов) и, при необходимости, обмен соседних элементов. Элементы ведут себя подобно пузырькам воздуха в воде — каждый из них поднимается на свой уровень. Простая форма алгоритма сортировки показана ниже:
<PRE>
/* Пузырьковая сортировка. */
void bubble(char *items, int count)
{
  register int a, b;
  register char t;

  for(a=1; a &lt; count; ++a)
    for(b=count-1; b &gt;= a; --b) {
      if(items[b-1] &gt; items[b]) {
        /* exchange elements */
        t = items[b-1];
        items[b-1] = items[b];
        items[b] = t;
      }
    }
}
</PRE>
<P class="tj">Здесь <KBD>items</KBD> — указатель на массив символов, подлежащий сортировке, a <KBD>count</KBD> — количество элементов в массиве. Работа пузырьковой сортировки выполняется в двух циклах. Если количество элементов массива равно <KBD>count</KBD>, внешний цикл приводит к просмотру массива <KBD>count&#160;-&#160;1</KBD> раз. Это обеспечивает размещение элементов в правильном порядке к концу выполнения функции даже в самом худшем случае. Все сравнения и обмены выполняются во внутреннем цикле. (Слегка улучшенная версия алгоритма пузырьковой сортировки завершает работу, если при просмотре массива не было сделано ни одного обмена, но это достигается за счет добавления еще одного сравнения при каждом проходе внутреннего цикла.)
<P class="tj">С помощью этой версии алгоритма пузырьковой сортировки можно сортировать массивы символов по возрастанию. Например, следующая короткая программа сортирует строку, вводимую пользователем:
<PRE>
/* Программа, вызывающая функцию сортировки bubble */

#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void bubble(char *items, int count);

int main(void)
{
  char s[255];

  printf("Введите строку:");
  gets(s);
  bubble(s, strlen(s));
  printf("Отсортированная строка: %s.\n", s);

  return 0;
}
</PRE>
<P class="tj">Чтобы наглядно показать, как работает пузырьковая сортировка, допустим, что исходный массив содержит элементы <B>dcab</B>. Ниже показано состояние массива после каждого прохода:
<PRE>
Начало       <B>d c a b</B>
Проход 1     <B>a d c b</B>
Проход 2     <B>a b d c</B>
Проход 3     <B>a b c d</B>
</PRE>
<P class="tj">При анализе любого алгоритма сортировки полезно знать, сколько операций сравнения и обмена будет выполнено в лучшем, среднем и худшем случаях. Поскольку характеристики выполняемого кода зависят от таких факторов, как оптимизация, производимая компилятором, различия между процессорами и особенности реализации, мы не будем пытаться получить точные значения этих параметров. Вместо этого сконцентрируем свое внимание на общей эффективности каждого алгоритма.
<P class="tj">В пузырьковой сортировке количество сравнений всегда одно и то же, поскольку два цикла <KBD>for</KBD> повторяются указанное количество раз независимо от того, был список изначально упорядочен или нет. Это значит, что алгоритм пузырьковой сортировки всегда выполняет
<P class="t">(<I>n</I><SUP>2</SUP>-<I>n</I>)/2
<P class="t">сравнений, где <I>n</I> — количество сортируемых элементов. Данная формула выведена на том основании, что внешний цикл выполняется <I>n</I>&#160;-&#160;1 раз, а внутренний выполняется в среднем <I>n</I>/2 раз. Произведение этих величин и дает предыдущее выражение.
<P class="tj">Обратите внимание на член <I>n</I><SUP>2</SUP> в формуле. Говорят, что пузырьковая сортировка является алгоритмом порядка <I>n</I><SUP>2</SUP>, поскольку время ее выполнения пропорционально квадрату количества сортируемых элементов. Необходимо признать, что алгоритм порядка <I>n</I><SUP>2</SUP> не эффективен при большом количестве элементов, поскольку время выполнения растет экспоненциально в зависимости от количества сортируемых элементов. На рис. 21.1 показан график роста времени сортировки с увеличением размера массива.
<P class="tj">В алгоритме пузырьковой сортировки количество обменов в лучшем случае равно нулю, если массив уже отсортирован. Однако в среднем и худшем случаях количество обменов также является величиной порядка <I>n</I><SUP>2</SUP>.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 21.1. Время сортировки порядка n<SUP>2</SUP> в зависимости от размера массива. (На самом деле здесь нарисована кривая у=n<SUP>2</SUP>/1000, а не кривая у=n<SUP>2</SUP>, крутизна которой в 1000 раз выше. Фактически это все равно, что нарисовать кривую у=n<SUP>2</SUP>, выбрав по оси ординат более мелкий масштаб (в 1000 раз). Начертить кривую у=n<SUP>2</SUP> без растяжения вдоль оси абсцисс, на которой откладываются значения n, практически невозможно. Дело в том, что при выбранном интервале изменения n (от 0 до 1000) кривая у=n<SUP>2</SUP> практически сливается с осью ординат.)</I></CAPTION>
<TR><TD align="center"><IMG src="../work/pic21_1.png" alt="y=n^2/1000">
</TABLE>
<P class="tj">Алгоритм пузырьковой сортировки можно немного улучшить, если попытаться повысить скорость его работы. Например, пузырьковая сортировка имеет такую особенность: неупорядоченные элементы на "большом" конце массива (например, "<B>а</B>" в примере <B>dсаb</B>) занимают правильные положения за один проход, но неупорядоченные элементы в начале массива (например, "<B>d</B>") поднимаются на свои места очень медленно. Этот факт подсказывает способ улучшения алгоритма. Вместо того чтобы постоянно просматривать массив в одном направлении, в последовательных проходах можно чередовать направления. Этим мы добьемся того, что элементы, сильно удаленные от своих положений, быстро станут на свои места. Данная версия пузырьковой сортировки носит название <I>шейкер-сортировки</I> (shaker sort)<SUP><A href="#22" name="2">[2]</A></SUP>, поскольку действия, производимые ею с массивом, напоминают взбалтывание или встряхивание. Ниже показана реализация шейкер-сортировки.
<PRE>
/* Шейкер-сортировка. */
void shaker(char *items, int count)
{
  register int a;
  int exchange;
  char t;

  do {
    exchange = 0;
    for(a=count-1; a &gt; 0; --a) {
      if(items[a-1] &gt; items[a]) {
        t = items[a-1];
        items[a-1] = items[a];
        items[a] = t;
        exchange = 1;
      }
    }

    for(a=1; a &lt; count; ++a) {
      if(items[a-1] &gt; items[a]) {
        t = items[a-1];
        items[a-1] = items[a];
        items[a] = t;
        exchange = 1;
      }
    }
  } while(exchange); /* сортировать до тех пор, пока не будет обменов */
}
</PRE>
<P class="tj">Хотя шейкер-сортировка и является улучшенным вариантом по сравнению с пузырьковой сортировкой, она по-прежнему имеет время выполнения порядка <I>n</I><SUP>2</SUP>. Это объясняется тем, что количество сравнений не изменилось, а количество обменов уменьшилось лишь на относительно небольшую константу. Шейкер-сортировка лучше пузырьковой, но есть еще гораздо лучшие алгоритмы сортировки.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>На самом деле есть даже два алгоритма пузырьковой сортировки: <I>сортировка пузырьковым вьючением</I> и <I>сортировка пузырьковой выборкой</I>. Впрочем, эффективность обоих одинакова.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>А также <I>сортировки перемешиванием (cocktail shaker sort), сортировки взбалтыванием, сортировки встряхиванием</I>. Как бы то ни было, это вид пузырьковой сортировки, в которой альтернативные проходы выполняются в противоположном направлении.
</BLOCKQUOTE>
<HR><A href="../main.htm#21">Содержание</A> | <A href="2103.htm">&lt;&lt;&lt;</A> | <A href="2105.htm">&gt;&gt;&gt;</A>
</BODY></HTML>