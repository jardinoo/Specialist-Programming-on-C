<HTML><HEAD>
<TITLE>Поиск</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#21">Содержание</A> | <A href="2110.htm">&lt;&lt;&lt;</A> | <A href="../22/22.htm">&gt;&gt;&gt;</A><HR>
<H1>Поиск</H1>
<P class="tj">Базы данных существуют для того, чтобы время от времени пользователи могли найти нужную запись, введя ее ключ. Существует один метод поиска информации в неупорядоченном массиве, и другой для поиска в упорядоченном массиве. В набор стандартной библиотеки компиляторов языка С входит стандартная функция <KBD>bsearch()</KBD>. Тем не менее, как и в случае сортировки, процедуры общего назначения иногда совсем не эффективны при использовании в критических ситуациях из-за накладных расходов, связанных с их обобщением. Кроме того, функцию <KBD>bsearch()</KBD> невозможно применить к неупорядоченным данным.
<H2>Методы поиска</H2>
<P class="tj">Для нахождения информации в неупорядоченном массиве требуется последовательный поиск, начинающийся с первого элемента и заканчивающийся при обнаружении подходящих данных либо при достижении конца массива. Этот метод применим для неупорядоченной информации, но также можно использовать его и на отсортированных данных. Однако если данные уже отсортированы, можно применить двоичный поиск, который находит данные быстрее.
<H2>Последовательный поиск</H2>
<P class="tj">Последовательный поиск очень легко запрограммировать. Приведенная ниже функция осуществляет поиск в массиве символов известной длины, пока не будет найден элемент с заданным ключом:
<PRE>
/* Последовательный поиск */
int sequential_search(char *items, int count, char key)
{
  register int t;

  for(t=0; t &lt; count; ++t)
    if(key == items[t]) return t;
  return -1; /* ключ не найден */
}
</PRE>
<P class="tj">Здесь <KBD>items</KBD> — указатель на массив, содержащий информацию. Функция возвращает индекс подходящего элемента, если таковой существует, либо -1 в противном случае.
<P class="tj">Понятно, что последовательный поиск в среднем просматривает <I>n/2</I> элементов. В лучшем случае он проверяет только один элемент, а в худшем — <I>n</I>. Если информация хранится на диске, поиск может занимать продолжительное время. Но если данные не упорядочены, последовательный поиск — единственно возможный метод.
<H2>Двоичный поиск</H2>
<P class="tj">Если данные, в которых производится поиск, отсортированы, для нахождения элемента можно применять метод, намного превосходящий предыдущий — <I>двоичный поиск</I><SUP><A href="#11" name="1">[1]</A></SUP>. В нем применяется метод половинного деления. Сначала проверим средний элемент. Если он больше, чем искомый ключ, проверим средний элемент первой половины, в противном случае — средний элемент второй половины. Будем повторять эту процедуру до тех пор, пока искомый элемент не будет найден либо пока не останется очередного элемента.
<P class="tj">Например, чтобы найти число 4 в массиве
<P class="t">1 2 3 4 5 6 7 8 9
<P class="t">при двоичном поиске сначала проверяется средний элемент — число 5. Поскольку оно больше, чем 4, поиск продолжается в первой половине:
<P class="t">1 2 3 4 5
<P class="t">Средний элемент теперь равен 3. Это меньше, чем 4, поэтому первая половина отбрасывается. Поиск продолжается в части
<P class="t">4 5
<P class="t">На этот раз искомый элемент найден.
<P class="t">В двоичном поиске количество сравнений в худшем случае равно
<P class="t">log<SUB>2</SUB><I>n</I>
<P class="t">В среднем случае количество немного ниже, а в лучшем — количество сравнений равно 1.
<P class="tj">Ниже приведена функция двоичного поиска для массивов символов. Этот поиск можно адаптировать для произвольных структур данных, изменив фрагмент сравнения.
<PRE>
/* Двоичный поиск */
int binary_search(char *items, int count, char key)
{
  int low, high, mid;

  low = 0; high = count-1;
  while(low &lt;= high) {
    mid = (low+high)/2;
    if(key &lt; items[mid]) high = mid-1;
    else if(key &gt; items[mid]) low = mid+1;
    else return mid; /* ключ найден */
  }
  return -1;
}
</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Есть и другие названия: <I>дихотомический поиск</I>, <I>логарифмический поиск</I>, <I>поиск делением пополам</I>. Этот метод поиска данных состоит в том, что все множество данных делится пополам и определяется, в какой из половин находится искомое данное, после чего половина, в которой находится данное, в свою очередь делится пополам и т.д. Процесс продолжается до тех пор, пока очередное полученное множество не станет равным единственному данному, которое будет искомым, либо будет установлен факт отсутствия искомого данного в этом множестве.
</BLOCKQUOTE>
<HR><A href="../main.htm#21">Содержание</A> | <A href="2110.htm">&lt;&lt;&lt;</A> | <A href="../22/22.htm">&gt;&gt;&gt;</A>
</BODY></HTML>