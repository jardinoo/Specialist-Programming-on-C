<HTML><HEAD>
<TITLE>Сортировка других структур данных</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#21">Содержание</A> | <A href="2108.htm">&lt;&lt;&lt;</A> | <A href="2110.htm">&gt;&gt;&gt;</A><HR>
<H1>Сортировка других структур данных</H1>
<P class="tj">До сих пор мы сортировали только массивы символов. Очевидно, что приведенные выше функции можно переделать для сортировки массивов любого из встроенных типов данных, просто поменяв типы параметров и переменных. Тем не менее, обычно возникает необходимость сортировать составные типы данных, например строки, или агрегированные данные, например структуры. Большинство задач сортировки имеют дело с ключом и информацией, связанной с этим ключом. Чтобы адаптировать алгоритмы для обработки подобных данных, необходимо модифицировать код сравнения, код обмена или оба фрагмента. Сам алгоритм при этом не меняется.
<P class="tj">Поскольку быстрая сортировка в настоящее время является одним из лучших методов сортировки общего назначения, она используется в последующих примерах. Тем не менее, тот же принцип относится и ко всем остальным методам, описанным ранее.
<H2>Сортировка строк</H2>
<P class="tj">Сортировка строк является распространенной задачей программирования. Строки легче всего сортировать, когда они хранятся в таблице строк. Таблица строк — это просто массив строк. А массив строк — это двумерный массив символов, в котором количество строк в таблице определяется размером левого измерения, а максимальная длина строки — размером правого измерения. (О массивах строк рассказывалось в <A href="../04/04.htm">главе 4</A>.) Нижеследующая строковая версия быстрой сортировки принимает массив строк, в котором размер каждой строки ограничен десятью символами. (Можете изменить эту длину, если хотите.) Данная версия сортирует строки в лексикографическом порядке.
<PRE>
/* Быстрая сортировка строк. */
void quick_string(char items[][10], int count)
{
  qs_string(items, 0, count-1);
}

void qs_string(char items[][10], int left, int right)
{
  register int i, j;
  char *x;
  char temp[10];

  i = left; j = right;
  x = items[(left+right)/2];

  do {
    while((strcmp(items[i],x) &lt; 0) && (i &lt; right)) i++;
    while((strcmp(items[j],x) &gt; 0) && (j &gt; left)) j--;
    if(i &lt;= j) {
      strcpy(temp, items[i]);
      strcpy(items[i], items[j]);
      strcpy(items[j], temp);
      i++; j--;
   }
  } while(i &lt;= j);

  if(left &lt; j) qs_string(items, left, j);
  if(i &lt; right) qs_string(items, i, right);
}
</PRE>
<P class="tj">Обратите внимание, что во фрагменте сравнения теперь используется функция <KBD>strcmp()</KBD>. Эта функция возвращает отрицательное число, если первая строка лексикографически меньше второй, возвращает ноль, если строки равны, и положительное число, если первая строка лексикографически больше второй. Также следует отметить, что для обмена двух строк требуется три вызова функции <KBD>strcpy()</KBD>.
<P class="tj">Имейте в виду, что функция <KBD>strcmp()</KBD> замедляет сортировку по двум причинам. Во-первых, в программе появляется вызов функции, что всегда отнимает время. Во-вторых, сама функция <KBD>strcmp()</KBD> выполняет несколько сравнений, чтобы определить, какая из двух строк больше. В первом случае, если скорость очень важна, можно поместить код сравнения строк непосредственно в функцию сортировки, продублировав код функции <KBD>strcmp()</KBD>. Во втором случае нет никакого способа избежать сравнения строк, поскольку по определению это именно то, что требуется в данной задаче. Те же рассуждения относятся и к функции <KBD>strcpy()</KBD>. Обмен двух строк с помощью <KBD>strcpy()</KBD> включает в себя вызов функции и посимвольный обмен содержимого строк — каждая из этих операций занимает время. Накладные расходы на вызов функции можно устранить, вставив код копирования прямо в алгоритм сортировки. Однако тот факт, что обмен двух строк означает обмен отдельных символов (один за другим), изменить невозможно.
<P class="tj">Ниже приведена простая функция <KBD>main()</KBD>, демонстрирующая работу функции быстрой сортировки строк <KBD>quick_string()</KBD>:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void quick_string(char items[][10], int count);
void qs_string(char items[][10], int left, int right);

char str[][10] = { "один",
                   "два",
                   "три",
                   "четыре"
                 };

int main(void)
{
  int i;

  quick_string(str, 4);

  for(i=0; i&lt;4; i++) printf("%s ", str[i]);

  return 0;
}
</PRE>
<H2>Сортировка структур</H2>
<P class="tj">В большинстве прикладных программ, в которых используется сортировка, предусмотрена сортировка совокупностей данных. Например, списки почтовой рассыпки, складские базы данных и журналы сотрудников содержат наборы разнотипных данных. Как вам известно, в программах на языке С совокупности данных обычно хранятся в структурах. Хотя структура обычно содержит несколько членов, структуры, как правило, сортируются только по одному полю-члену, который используется в качестве ключа сортировки. За исключением выбора ключа, приемы сортировки структур ничем не отличаются от приемов сортировки других типов данных.
<P class="tj">Чтобы проиллюстрировать пример сортировки структур, давайте создадим структуру под называнием <KBD>address</KBD>, в которой можно хранить почтовый адрес. Подобная структура может применяться в программе почтовой рассылки. Описание структуры <KBD>address</KBD> показано ниже:
<PRE>
struct address {
  char name[40];   /* имя */
  char street[40]; /* улица */
  char city[20];   /* город */
  char state[3];   /* штат */
  char zip[11];    /* индекс */
};
</PRE>
<P class="tj">Поскольку представляется разумным организовать список адресов в виде массива структур, в данном примере предположим, что процедура сортировки будет сортировать массив структур типа <KBD>address</KBD>. Такая процедура показана ниже. Она сортирует адреса по почтовому индексу.
<PRE>
/* Быстрая сортировка структур типа фвкуыы. */
void quick_struct(struct address items[], int count)
{
  qs_struct(items,0,count-1);
}

void qs_struct(struct address items[], int left, int right)
{

  register int i, j;
  char *x;
  struct address temp;

  i = left; j = right;
  x = items[(left+right)/2].zip;

  do {
    while((strcmp(items[i].zip,x) &lt; 0) && (i &lt; right)) i++;
    while((strcmp(items[j].zip,x) &gt; 0) && (j &gt; left)) j--;
    if(i &lt;= j) {
      temp = items[i];
      items[i] = items[j];
      items[j] = temp;
      i++; j--;
    }
  } while(i &lt;= j);

  if(left &lt; j) qs_struct(items, left, j);
  if(i &lt; right) qs_struct(items, i, right);
}
</PRE>
<HR><A href="../main.htm#21">Содержание</A> | <A href="2108.htm">&lt;&lt;&lt;</A> | <A href="2110.htm">&gt;&gt;&gt;</A>
</BODY></HTML>