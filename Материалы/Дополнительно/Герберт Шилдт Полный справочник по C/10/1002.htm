<HTML><HEAD>
<TITLE>Директива #define</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#10">Содержание</A> | <A href="1001.htm">&lt;&lt;&lt;</A> | <A href="1003.htm">&gt;&gt;&gt;</A><HR>
<H1>Директива #define</H1>
<P class="tj">Директива <KBD>#define</KBD> определяет идентификатор и последовательность символов, которая будет подставляться вместо идентификатора каждый раз, когда он встретится в исходном файле. Идентификатор называется <I>именем макроса</I>, а сам процесс замены — <I>макрозаменой</I><SUP><A href="#11" name="1">[1]</A></SUP>. В общем виде директива выглядит таким образом:
<PRE>#define <I>имя_макроса последовательность_символов</I></PRE>
<P class="tj">Обратите внимание, что в этом выражении нет точки с запятой. Между идентификатором и последовательностью символов <I>последовательность_символов</I> может быть любое количество пробелов, но признаком конца последовательности символов может быть только разделитель строк.
<P class="tj">Предположим, например, что вместо значения 1 нужно использовать слово <KBD>LEFT</KBD> (левый), а вместо значения 0 — слово <KBD>RIGHT</KBD> (правый). Тогда можно сделать следующие объявления с помощью директивы <KBD>#define</KBD>:
<PRE>
#define LEFT 1
#define RIGHT 0
</PRE>
<P class="tj">В результате компилятор будет подставлять 1 или 0 каждый раз, когда в вашем файле исходного кода встречается идентификатор соответственно LEFT или RIGHT. Например, следующий код выводит на экран 0 1 2:
<PRE>printf("%d %d %d", RIGHT, LEFT, LEFT+1);</PRE>
<P class="tj">После определения имя макроса можно использовать в определениях других имен макросов. Вот, например, код, определяющий значения ONE (один), TWO (два) и three (три):
<PRE>
#define ONE    1 
#define TWO    ONE+ONE
#define THREE  ONE+TWO
</PRE>
<P class="tj">Макроподстановка — это просто замена какого-либо идентификатора связанной с ним последовательностью символов. Поэтому если требуется определить стандартное сообщение об ошибке, то можно написать примерно следующее:
<PRE>
#define E_MS "стандартная ошибка при вводе\n"
/* ... */
printf(E_MS);
</PRE>
<P class="tj">Теперь каждый раз, когда встретится идентификатор <KBD>E_MS</KBD>, компилятор будет его заменять строкой "стандартная ошибка при вводе\n". Для компилятора выражение <KBD>printf()</KBD> на самом деле будет выглядеть таким образом:
<PRE>
printf("стандартная ошибка при вводе\n");
</PRE>
<P class="tj">Если идентификатор находится внутри строки, заключенной в кавычки, то замены не будет. Например, при выполнении кода
<PRE>
#define XYZ это проверка

printf("XYZ");
</PRE>
<P class="t">вместо сообщения <KBD>это проверка</KBD> будет выводиться последовательность символов <KBD>XYZ</KBD>.
<P class="tj">Если <I>последовательность_символов</I> не помещается в одной строке, то эту последовательность можно продолжить на следующей строке, поместив в конце предыдущей, как показано ниже, обратную косую черту:
<PRE>
#define LONG_STRING "это очень длинная \
строка, используемая в качестве примера"
</PRE>
<P class="tj">Программисты, пишущие программы на языке С, в именах определяемых идентификаторов часто используют буквы верхнего регистра. Если разработчики программ следуют этому правилу, то тот, кто будет читать их программу, с первого взгляда поймет, что будет происходить макрозамена. Кроме того, все директивы <KBD>#define</KBD> обычно лучше всего помещать в самом начале файла или в отдельном заголовочном файле, а не разбрасывать по всей программе.
<P class="tj">Имена макросов часто используются для определения имен так называемых "магических чисел" (встречающихся в программе). Например, имеется программа, в которой определяется массив и несколько процедур, получающих доступ к этому массиву. Вместо того чтобы размер массива "зашивать в код" в виде константы, этот размер можно определить с помощью оператора <KBD>#define</KBD>, а затем использовать это имя макроса везде, где требуется размер массива. Таким образом, если требуется изменить этот размер, то потребуется изменить только соответствующий оператор <KBD>#define</KBD>, a затем перекомпилировать программу. Рассмотрим, например, фрагмент программы
<PRE>
#define MAX_SIZE 100
/* ... */
float balance[MAX_SIZE];
/* ... */
for(i=0; i&lt;MAX_SIZE; i++) printf("%f", balance[i]);
/* ... */
for(i=0; i&lt;MAX_SIZE; i++) x =+ balance[i];
</PRE>
<P class="tj">Размер массива <KBD>balance</KBD> определяется именем макроса <KBD>MAX_SIZE</KBD>, и поэтому если этот размер потребуется в будущем изменить, то надо будет изменить только определение <KBD>MAX_SIZE</KBD>. В результате при перекомпиляции программы все обращения к этому имени макроса, находящиеся после измененного определения, будут автоматически изменены.
<H2>Определение макросов с формальными параметрами</H2>
<P class="tj">У директивы <KBD>#define</KBD> имеется еще одно большое достоинство: имя макроса может определяться с формальными параметрами. Тогда каждый раз, когда в программе встречается имя макроса, то используемые в его определении формальные параметры заменяются теми аргументами, которые встретились в программе. Такого рода макросы называются <I>макросами с формальными параметрами</I><SUP><A href="#22" name="2">[2]</A></SUP>. Например,
<PRE>
#include &lt;stdio.h&gt;

#define ABS(a)  (a) &lt; 0 ? -(a) : (a)

int main(void)
{
  printf("модули чисел -1 и 1 равны соответственно %d и %d",
         ABS(-1), ABS(1));

  return 0;
}
</PRE>
<P class="tj">Во время компиляции этой программы вместо формального параметра <KBD>а</KBD> из определения макроса будут подставляться значения -1 и 1. Скобки, в которых находится <KBD>а</KBD>, позволяют в любом случае сделать правильную замену. Например, если скобки, стоящие вокруг <KBD>а</KBD>, удалить, то выражение
<PRE>ABS(10-20)</PRE>
<P class="t">после макрозамены будет преобразовано в
<PRE>10-20 &lt; 0 ? -10-20 : 10-20</PRE>
<P class="t">и может привести к неправильному результату.
<P class="tj">Использование вместо настоящих функций макросов с формальными параметрами дает одно существенное преимущество: увеличивается скорость выполнения кода, потому что в таких случаях не надо тратить ресурсы на вызов функций. Однако если у макроса с формальными параметрами очень большие размеры, то тогда из-за дублирования кода увеличение скорости достигается за счет увеличения размеров программы.
<P class="tj">И вот еще что: хотя макросы с формальными параметрами являются полезным средством, но в С99 (и в C++) есть еще более эффективный способ создания машинной программы — с использованием ключевого слово <KBD>inline</KBD>.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">В С99 можно определить макрос с переменным количеством формальных параметров; об этом рассказывается в <A href="../II.htm">части II</A> этой книги.
</TABLE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>А также <I>макрорасширением</I>, <I>макрогенерацией</I> и <I>макроподстановкой</I>. Определение макроса часто называют <I>макроопределением</I>, а обращение к макросу — <I>макровызовом</I> или <I>макрокомандой</I>. Впрочем, иногда макроопределение также называется макрокомандой.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>А также <I>макроопределениями с параметрами</I> и <I>макросами, напоминающими функции</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#10">Содержание</A> | <A href="1001.htm">&lt;&lt;&lt;</A> | <A href="1003.htm">&gt;&gt;&gt;</A>
</BODY></HTML>