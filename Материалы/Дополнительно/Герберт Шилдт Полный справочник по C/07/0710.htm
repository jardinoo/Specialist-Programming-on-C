<HTML><HEAD>
<TITLE>Использование sizof для обеспечения переносимости</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="0709.htm">&lt;&lt;&lt;</A> | <A href="0711.htm">&gt;&gt;&gt;</A><HR>
<H1>Использование sizof для обеспечения переносимости</H1>
<P class="tj">Вы имели возможность убедиться, что структуры и объединения можно использовать для создания переменных разных размеров, а также в том, что настоящий размер этих переменных в разных машинах может быть разным. Оператор <KBD>sizeof</KBD> подсчитывает размер любой переменной или любого типа и может быть полезен, если в программах требуется свести к минимуму машинно-зависимый код. Этот оператор особенно полезен там, где приходится иметь дело со структурами или объединениями.
<P class="tj">Перед тем как переходить к дальнейшему изложению, предположим, что определенные типы данных имеют следующие размеры:
<PRE>
<B>Тип        Размер в байтах</B>
char       1
int        4
double     8
</PRE>
<P class="tj">Поэтому при выполнении следующего кода на экран будут выведены числа <KBD>1</KBD>, <KBD>4</KBD> и <KBD>8</KBD>:
<PRE>
char ch;
int i;
double f;

printf("%d", sizeof(ch));
printf("%d", sizeof(i));
printf("%d", sizeof(f));
</PRE>
<P class="tj">Размер структуры равен сумме размеров ее членов или, возможно, даже <I>больше</I> этой суммы. Рассмотрим пример:
<PRE>
struct s {
  char ch;
  int i;
  double f;
} s_var;
</PRE>
<P class="tj">Здесь <KBD>sizeof(s_var)</KBD> равняется как минимум 13 (=8+4+1). Однако размер <KBD>s_var</KBD> может быть и больше, потому что компилятору иногда необходимо специально увеличить размер структуры, выровнять некоторые ее члены на границу слова или параграфа. (Параграф занимает 16 байтов.) Так как размер структуры может быть больше, чем сумма размеров ее членов, то всегда, когда нужно знать размер структуры, следует использовать <KBD>sizeof</KBD>. Например, если требуется динамически выделять память для объекта типа <KBD>s</KBD>, необходимо использовать последовательность операторов, аналогичную той, что показана здесь (а не вставлять вручную значения длины его членов):
<PRE>
struct s *p;
p = malloc(sizeof(struct s));
</PRE>
<P class="tj">Так как <KBD>sizeof</KBD> — это оператор времени компиляции, то вся информация, необходимая для вычисления размера любой переменной, становится известной как раз во время компиляции. Это особенно важно для объединений, потому что размер каждого из них всегда равен размеру наибольшего члена. Например, проанализируйте следующее объединение:
<PRE>
union u {
  char ch;
  int i;
  double f;
} u_var;
</PRE>
<P class="tj">Для него <KBD>sizeof(u_var)</KBD> равняется 8. Впрочем, во время выполнения не имеет значения, какой размер на самом деле имеет <KBD>u_var</KBD>. Важен размер его наибольшего члена, так как любое объединение должно быть такого же размера, как и его самый большой элемент.
<HR><A href="../main.htm#07">Содержание</A> | <A href="0709.htm">&lt;&lt;&lt;</A> | <A href="0711.htm">&gt;&gt;&gt;</A>
</BODY></HTML>