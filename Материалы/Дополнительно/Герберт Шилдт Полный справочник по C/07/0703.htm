<HTML><HEAD>
<TITLE>Передача структур функциям</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="0702.htm">&lt;&lt;&lt;</A> | <A href="0704.htm">&gt;&gt;&gt;</A><HR>
<H1>Передача структур функциям</H1>
<P class="tj">В этом разделе рассказывается о передаче структур и их членов функциям.
<H2>Передача членов структур функциям</H2>
<P class="tj">При передаче функции члена структуры передается его значение, притом не играет роли то, что значение берется из члена структуры. Проанализируйте, например, следующую структуру:
<PRE>
struct fred
{
  char x;
  int y;
  float z;
  char s[10];
} mike;
</PRE>
<P class="tj">Например, обратите внимание, каким образом каждый член этой структуры передается функции:
<PRE>
func(mike.x);    /* передается символьное значение x */
func2(mike.y);   /* передается целое значение y */
func3(mike.z);   /* передается значение с плавающей точкой z */
func4(mike.s);   /* передается адрес строки s */
func(mike.s[2]); /* передается символьное значение s[2] */
</PRE>
<P class="tj">В каждом из этих случаев функции передается значение определенного элемента, и здесь не имеет значения то, что этот элемент является частью какой-либо большей совокупности.
<P class="tj">Если же нужно передать <I>адрес</I> отдельного члена структуры, то перед именем структуры должен находиться оператор <KBD>&</KBD>. Например, чтобы передать адреса членов структуры <KBD>mike</KBD>, можно написать следующее:
<PRE>
func(&mike.x);    /* передается адрес символа x */
func2(&mike.y);   /* передается адрес целого y */
func3(&mike.z);   /* передается адрес члена z с плавающей точкой */
func4(mike.s);    /* передается адрес строки s */
func(&mike.s[2]); /* передается адрес символа в s[2] */
</PRE>
<P class="tj">Обратите внимание, что оператор <KBD>&</KBD> стоит непосредственно перед именем структуры, а не перед именем отдельного члена. И еще заметьте, что <KBD>s</KBD> уже обозначает адрес, поэтому <KBD>&</KBD> не требуется.
<H2>Передача целых структур функциям</H2>
<P class="tj">Когда в качестве аргумента функции используется структура, то для передачи целой структуры используется обычный способ вызова по значению. Это, конечно, означает, что любые изменения в содержимом параметра внутри функции не отразятся на той структуре, которая передана в качестве аргумента.
<P class="tj">При использовании структуры в качестве аргумента надо помнить, что тип аргумента должен соответствовать типу параметра. Например, в следующей программе и аргумент <KBD>arg</KBD>, и параметр <KBD>parm</KBD> объявляются с одним и тем же типом структуры.
<PRE>
#include &lt;stdio.h&gt;

/* Определение типа структуры. */
struct struct_type {
  int a, b;
  char ch;
} ;

void f1(struct struct_type parm);

int main(void)
{
  struct struct_type arg;

  arg.a = 1000;

  f1(arg);

  return 0;
}

void f1(struct struct_type parm)
{
  printf("%d", parm.a);
}
</PRE>
<P class="tj">Как видно из этой программы, при объявлении параметров, являющихся структурами, объявление типа структуры должно быть глобальным, чтобы структурный тип можно было использовать во всей программе. Например, если бы <KBD>struct_type</KBD> был бы объявлен внутри <KBD>main()</KBD>, то этот тип не был бы виден в <KBD>f1()</KBD>.
<P class="tj">Как уже говорилось, при передаче структуры тип аргумента должен совпадать с типом параметра. Для аргумента и параметра недостаточно просто быть физически похожими; должны совпадать даже имена их типов. Например, следующая версия предыдущей программы неправильная и компилироваться не будет. Дело в том, что имя типа для аргумента, используемого при вызове функции <KBD>f1()</KBD>, отличается от имени типа ее параметра.
<PRE>
/* Эта программа неправильная и при компиляции будут
   обнаружены ошибки. */
#include &lt;stdio.h&gt;

/* Определение типа структур. */
struct struct_type {
  int a, b;
  char ch;
} ;

/* Определение структуры, похожей на struct_type,
   но сдругими именами. */
struct struct_type2 {
  int a, b;
  char ch;
} ;

void f1(struct struct_type2 parm);

int main(void)
{
  struct struct_type arg;

  arg.a = 1000;

  f1(arg); /* несовпадение типов */

  return 0;
}

void f1(struct struct_type2 parm)
{
  printf("%d", parm.a);
}
</PRE>
<HR><A href="../main.htm#07">Содержание</A> | <A href="0702.htm">&lt;&lt;&lt;</A> | <A href="0704.htm">&gt;&gt;&gt;</A>
</BODY></HTML>