<HTML><HEAD>
<TITLE>Битовые поля</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="0706.htm">&lt;&lt;&lt;</A> | <A href="0708.htm">&gt;&gt;&gt;</A><HR>
<H1>Битовые поля</H1>
<P class="tj">В отличие от некоторых других компьютерных языков, в языке С имеется встроенная поддержка <I>битовых полей</I><SUP><A href="#11" name="1">[1]</A></SUP>, которая дает возможность получать доступ к единичному биту. Битовые поля могут быть полезны по разным причинам, а именно:
<UL type=square>
<LI class="t">Если память ограничена, то в одном байте можно хранить несколько булевых переменных (принимающих значения ИСТИНА и ЛОЖЬ);
<LI class="t">Некоторые устройства передают информацию о состоянии, закодированную в байте в одном или нескольких битах;
<LI class="t">Для некоторых процедур шифрования требуется доступ к отдельным битам внутри байта.
</UL>
<P class="tj">Хотя для решения этих задач можно успешно применять побитовые операции, битовые поля могут придать вашему коду больше упорядоченности (и, возможно, с их помощью удастся достичь большей эффективности).
<P class="tj">Битовое поле может быть членом структуры или объединения. Оно определяет длину поля в битах. Общий вид определения битового поля такой:
<PRE><I>тип имя : длина</I>;</PRE>
<P class="tj">Здесь <I>тип</I> означает тип битового поля, а <I>длина</I> — количество бит, которые занимает это поле. Тип битового поля может быть <KBD>int</KBD>, <KBD>signed</KBD> или <KBD>unsigned</KBD>. (Кроме того, в соответствии со стандартом С99, у битового поля еще может быть тип <KBD>_Вооl</KBD>.)
<P class="tj">Битовые поля часто используются при анализе данных, поступающих в программу с аппаратуры. Например, в результате опроса состояния адаптера последовательной связи может возвращаться байт состояния, организованный следующим образом:</P>
<TABLE align=center border=0 width=100%>
<TR><TH>Бит<TH>Что означает, если установлен
<TR><TD>0<TD class="t">Изменение в линии сигнала разрешения на передачу (change in clear-to-send line)
<TR><TD>1<TD class="t">Изменение состояния готовности устройства сопряжения (change in data-set-ready)
<TR><TD>2<TD class="t">Обнаружена концевая запись (trailing edge detected)
<TR><TD>3<TD class="t">Изменение в приемной линии (change in receive line)
<TR><TD>4<TD class="t">Разрешение на передачу. Сигналом CTS (clear-to-send) модем разрешает подключенному терминалу передавать данные
<TR><TD>5<TD class="t">Модем готов (data-set-ready)
<TR><TD>6<TD class="t">Телефонный вызов (telephone ringing)
<TR><TD>7<TD class="t">Сигнал принят (received signal)
</TABLE>
<P class="tj">Информацию в байте состояния можно представить с помощью следующего битового поля:
<PRE>
struct status_type {
  unsigned delta_cts: 1;
  unsigned delta_dsr: 1;
  unsigned tr_edge:   1;
  unsigned delta_rec: 1;
  unsigned cts:       1;
  unsigned dsr:       1;
  unsigned ring:      1;
  unsigned rec_line:  1;
} status;
</PRE>
<P class="tj">Для того чтобы программа могла определить, когда можно отправлять или принимать данные, можно использовать такие операторы:
<PRE>
status = get_port_status();
if(status.cts) printf("Разрешение на передачу");
if(status.dsr) printf("Данные готовы");
</PRE>
<P class="tj">Для присвоения битовому полю значения используйте тот же способ, что и для элемента, находящегося в структуре любого другого типа. Вот, например, фрагмент кода, выполняющий сброс поля <KBD>ring</KBD>:
<PRE>status.ring = 0;</PRE>
<P class="tj">Как видно из этого примера, каждое битовое поле доступно с помощью оператора точка. Однако если структура передана с помощью указателя, то следует использовать оператор стрелка <KBD>-&gt;</KBD>.
<P class="tj">Нет необходимости давать имя каждому битовому полю. Таким образом можно легко получать доступ к нужному биту, обходя неиспользуемые. Например, если вас интересуют только биты <KBD>cts</KBD> и <KBD>dsr</KBD>, то структуру <KBD>status_type</KBD> можно объявить таким образом:
<PRE>
struct status_type {
  unsigned :    4;
  unsigned cts: 1;
  unsigned dsr: 1;
} status;
</PRE>
<P class="tj">Кроме того, обратите внимание, что если биты, расположенные после <KBD>dsr</KBD>, не используются, то определять их не надо.
<P class="tj">В структурах можно сочетать обычные члены с битовыми полями. Например, в структуре
<PRE>
struct emp {
  struct addr address;
  float pay;
  unsigned lay_off:    1; /* временно уволенный или работающий */
  unsigned hourly:     1; /* почасовая оплата или оклад */
  unsigned deductions: 3; /* налоговые (IRS) удержания */
};
</PRE>
<P class="t">определены данные о работнике, для которых выделяется только один байт, содержащий информацию трех видов: статус работника, на окладе ли он, а также количество удержаний из его зарплаты. Без битового поля эта информация занимала бы 3 байта.
<P class="tj">Использование битовых полей имеет определенные ограничения. Нельзя получить адрес битового поля. Нет массивов битовых данных. При переносе кода на другую машину неизвестно, будут ли поля обрабатываться справа налево или слева направо; это значит, что выполнение любого кода, в котором используются битовые поля, в определенной степени может зависеть от машины, на которой он выполняется. Другие ограничения будут зависеть от конкретных реализаций.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называются также <I>полями битов</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#07">Содержание</A> | <A href="0706.htm">&lt;&lt;&lt;</A> | <A href="0708.htm">&gt;&gt;&gt;</A>
</BODY></HTML>