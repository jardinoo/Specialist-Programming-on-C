<HTML><HEAD>
<TITLE>Структуры</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="07.htm">&lt;&lt;&lt;</A> | <A href="0702.htm">&gt;&gt;&gt;</A><HR>
<H1>Структуры</H1>
<P class="tj">Структура — это совокупность переменных, объединенных под одним именем. С помощью структур удобно размещать в смежных полях связанные между собой элементы информации. <I>Объявление структуры</I> создает шаблон, который можно использовать для создания ее объектов (то есть экземпляров этой структуры). Переменные, из которых состоит структура, называются <I>членами</I>. (Члены структуры еще называются <I>элементами</I> или <I>полями</I>.)
<P class="tj">Как правило, члены структуры связаны друг с другом по смыслу. Например, элемент списка рассылки, состоящий из имени и адреса логично представить в виде структуры. В следующем фрагменте кода показано, как объявить структуру, в которой определены поля имени и адреса. Ключевое слово <KBD>struct</KBD> сообщает компилятору, что объявляется (еще говорят, "декларируется") структура.
<PRE>
struct addr
{
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
};
</PRE>
<P class="tj">Обратите внимание, что объявление завершается точкой с запятой, потому что объявление структуры является оператором. Кроме того, <I>тег</I> структуры <KBD>addr</KBD> идентифицирует эту конкретную структуру данных и является спецификатором ее типа.
<P class="tj">В данном случае <I>на самом деле никакая переменная не создается</I>. Всего лишь определяется вид данных. Когда вы объявляете структуру, то определяете агрегатный <I>тип</I>, а не переменную. И пока вы не объявите переменную этого типа, то существовать она не будет. Чтобы объявить переменную (то есть физический объект) типа <KBD>addr</KBD>, напишите следующее:
<PRE>struct addr addr_info;</PRE>
<P class="tj">В этом операторе объявлена переменная типа <KBD>addr</KBD>, которая называется <KBD>addr_info</KBD>. Таким образом, <KBD>addr</KBD> описывает вид структуры (ее тип), a <KBD>addr_info</KBD> является экземпляром (объектом) этой структуры.
<P class="tj">Когда объявляется переменная-структура, компилятор автоматически выделяет количество памяти, достаточное, чтобы разместить все ее члены. На рис. 7.1 показано, как <KBD>addr_info</KBD> размещена в памяти; в данном случае предполагается, что целые переменные типа <KBD>long</KBD> занимают по 4 байта.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 7.1. Расположение в памяти структуры <KBD>addr_info</KBD></I>
<TR><TD>
<PRE>
+------------------------------------------+
|Name (имя) 30 байт                        |
+------------------------------------------+

+-------------------------------------------------+
|Street (улица) 40 байт                           |
+-------------------------------------------------+

+-----------------------------------+
|City (город) 20 байт               |
+-----------------------------------+

+---------------------+
|State (штат) 3 байта |
+---------------------+

+----------------------------+
|Zip (код) 4 байта           |
+----------------------------+
</PRE>
</TABLE>
<P class="tj">Одновременно с объявлением структуры можно объявить одну или несколько переменных. Например,
<PRE>
struct addr {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info, binfo, cinfo;
</PRE>
<P class="t">определяет тип структуры, называемый <KBD>addr</KBD>, и объявляет переменные этого типа <KBD>addr_info</KBD>, <KBD>binfo</KBD> и <KBD>cinfo</KBD>. Важно понимать, что каждая переменная-структура содержит собственные копии членов структуры. Например, поле <KBD>zip</KBD> в <KBD>binfo</KBD> отличается от поля <KBD>zip</KBD> в <KBD>cinfo</KBD>. Изменения в <KBD>zip</KBD> из <KBD>binfo</KBD> не повлияют на содержимое поля <KBD>zip</KBD>, находящегося в <KBD>cinfo</KBD>.
<P class="tj">Если нужна только одна переменная-структура, то <I>тег</I> структуры является лишним. В этом случае наш пример объявления можно переписать следующим образом:
<PRE>
struct {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info;
</PRE>
<P class="tj">В этом случае объявляется одна переменная с именем <KBD>addr_info</KBD>, причем ее поля указаны в структуре, которая предшествует этому имени.
<P class="tj">Общий вид объявления структуры такой:
<PRE>
struct <I>тег</I> {
  <I>тип имя-члена;
  тип имя-члена;
  тип имя-члена;
  .
  .
  .</I>
} <I>переменные-структуры;</I>
</PRE>
<P class="t">причем <I>тег</I> или <I>переменные-структуры</I> могут быть пропущены, но только не оба одновременно.
<H2>Доступ к членам структуры</H2>
<P class="tj">Доступ к отдельным членам структуры осуществляется с помощью оператора <KBD>.</KBD> (который обычно называют <I>оператором точка</I> или <I>оператором доступа к члену структуры</I>). Например, в следующем выражении полю <KBD>zip</KBD> в уже объявленной переменной-структуре <KBD>addr_info</KBD> присваивается значение ZIP-кода, равное 12345:
<PRE>addr_info.zip = 12345;</PRE>
<P class="tj">Этот отдельный член определяется именем объекта (в данном случае <KBD>addr_info</KBD>), за которым следует точка, а затем именем самого этого члена (в данном случае <KBD>zip</KBD>). В общем виде использование оператора точка для доступа к члену структуры выглядит таким образом:
<PRE><I>имя-объекта.имя-члена</I></PRE>
<P class="tj">Поэтому, чтобы вывести ZIP-код на экран, напишите следующее:
<PRE>printf("%d", addr_info.zip);</PRE>
<P class="tj">Будет выведен ZIP-код, который находится в члене <KBD>zip</KBD> переменной-структуры <KBD>addr_infо</KBD>.
<P class="tj">Точно так же в вызове <KBD>gets()</KBD> можно использовать массив символов <KBD>addr_infо.name</KBD>:
<PRE>gets(addr_info.name);</PRE>
<P class="tj">Таким образом, в начало <KBD>name</KBD> передается указатель на символьную строку.
<P class="tj">Так как <KBD>name</KBD> является массивом символов, то чтобы получить доступ к отдельным символам в массиве <KBD>addr_info.name</KBD>, можно использовать индексы вместе с <KBD>name</KBD>. Например, с помощью следующего кода можно посимвольно вывести на экран содержимое <KBD>addr_info.name</KBD>:
<PRE>
for(t=0; addr_info.name[t]; ++t)
  putchar(addr_info.name[t]);
</PRE>
<P class="tj">Обратите внимание, что индексируется именно name (а не <KBD>addr_info</KBD>). Помните, что <KBD>addr_info</KBD> — это имя всего объекта-структуры, a <KBD>name</KBD> — имя элемента этой структуры. Таким образом, если требуется индексировать элемент структуры, то индекс необходимо указывать после имени этого элемента.
<H2>Присваивание структур</H2>
<P class="tj">Информация, которая находится в одной структуре, может быть присвоена другой структуре того же типа при помощи единственного оператора присваивания. Нет необходимости присваивать значения каждого члена в отдельности. Как выполняется присваивание структур, показывает следующая программа:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  struct {
    int a;
    int b;
  } x, y; 

  x.a = 10;

  y = x;  /* присваение одной структуры другой */

  printf("%d", y.a);

  return 0;
}
</PRE>
<P class="tj">После присвоения в <KBD>y.a</KBD> будет храниться значение 10.
<HR><A href="../main.htm#07">Содержание</A> | <A href="07.htm">&lt;&lt;&lt;</A> | <A href="0702.htm">&gt;&gt;&gt;</A>
</BODY></HTML>