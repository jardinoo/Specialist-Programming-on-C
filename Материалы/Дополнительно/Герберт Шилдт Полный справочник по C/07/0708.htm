<HTML><HEAD>
<TITLE>Перечисления</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="0707.htm">&lt;&lt;&lt;</A> | <A href="0709.htm">&gt;&gt;&gt;</A><HR>
<H1>Перечисления</H1>
<P class="tj"><I>Перечисление</I> — это набор именованных целых констант. Перечисления довольно часто встречаются в повседневной жизни. Вот, например, перечисление, в котором приведены названия монет, используемых в Соединенных Штатах:
<P class="t">penny (пенни, монета в один цент), nickel (никель, монета в пять центов), dime (монета в 10 центов), quarter (25 центов, четверть доллара), half-dollar (полдоллара), dollar (доллар)
<P class="tj">Перечисления определяются во многом так же, как и структуры; началом объявления перечислимого типа<SUP><A href="#11" name="1">[1]</A></SUP> служит ключевое слово <KBD>enum</KBD>. Перечисление в общем виде выглядит так:
<PRE>enum <I>тег</I> {<I>список перечисления</I>} <I>список переменных</I>;</PRE>
<P class="tj">Здесь <I>тег</I> и <I>список переменных</I> не являются обязательными. (Но хотя бы что-то одно из них должно присутствовать.) Следующий фрагмент кода определяет перечисление с именем <KBD>coin</KBD> (монета):
<PRE>
enum coin { penny, nickel, dime, quarter,
            half_dollar, dollar};
</PRE>
<P class="tj">Тег перечисления можно использовать для объявления переменных данного перечислимого типа. Вот код, в котором <KBD>money</KBD> (деньги) объявляется в качестве переменной типа <KBD>coin</KBD>:
<PRE>enum coin money;</PRE>
<P class="tj">С учетом этих объявлений совершенно верными являются следующие операторы:
<PRE>
money = dime;
if(money==quarter) printf("Денег всего четверть доллара.\n");
</PRE>
<P class="tj">Главное, что нужно знать для понимания перечислений — каждый их элемент<SUP><A href="#22" name="2">[2]</A></SUP> представляет целое число. В таком виде элементы перечислений можно применять везде, где используются целые числа. Каждому элементу дается значение, на единицу большее, чем у его предшественника. Первый элемент перечисления имеет значение 0. Поэтому, при выполнении кода
<PRE>printf("%d %d", penny, dime);</PRE>
<P class="t">на экран будет выведено <KBD>0 2</KBD>.
<P class="tj">Однако для одного или более элементов можно указать значение, используемое как инициализатор. Для этого после перечислителя надо поставить знак равенства, а затем — целое значение. Перечислителям, которые идут после инициализатора, присваиваются значения, большие предшествующего. Например, следующий код присваивает <KBD>quarter</KBD> значение 100:
<PRE>
enum coin { penny, nickel, dime, quarter=100,
            half_dollar, dollar};
</PRE>
<P class="t">вот какие значения появились у этих элементов:
<PRE>
penny           0
nickel          1
dime            2
quarter         100
half_dollar     101
dollar          102
</PRE>
<P class="tj">Относительно перечислений есть одно распространенное, но ошибочное мнение. Оно состоит в том, что их элементы можно непосредственно вводить и выводить. Это не так. Например, следующий фрагмент кода не будет выполняться так, как того ожидают многие неопытные программисты:
<PRE>
/* этот код работать не будет */
money = dollar;
printf("%s", money);
</PRE>
<P class="tj">Здесь <KBD>dollar</KBD> — это имя для значения целого типа; это не строка. Таким образом, попытка вывести <KBD>money</KBD> в виде строки по существу обречена. По той же причине для достижения нужных результатов не годится и такой код:
<PRE>
/* этот код не правильный */
strcpy(money, "dime");
</PRE>
<P class="tj">То есть строка, содержащая имя элемента, автоматически в этот перечислитель не превратится.
<P class="tj">На самом же деле создавать код для ввода и вывода элементов перечислений — это довольно-таки скучное занятие (но его можно избежать лишь тогда, когда будет достаточно именно целых значений этих перечислителей). Например, чтобы выводить название монеты, вид которой находится в <KBD>money</KBD>, потребуется следующий код:
<PRE>
switch(money) {
  case penny: printf("пенни");
    break;
  case nickel: printf("никель");
    break;
  case dime: printf("монета в 10 центов");
    break;
  case quarter: printf("четверть доллара");
    break;
  case half_dollar: printf("полдоллара");
    break;
  case dollar: printf("доллар");
}
</PRE>
<P class="tj">Иногда можно объявить строчный массив и использовать значение перечисления как индекс при переводе этого значения в соответствующую строку. Например, следующий код также выводит нужную строку:
<PRE>
char name[][12]={
  "пенни",
  "никель",
  "монета в 10 центов",
  "четверть доллара",
  "полдоллара",
  "доллар"
};
printf("%s", name[money]);
</PRE>
<P class="tj">Конечно, он будет работать только тогда, когда не инициализирован ни один из элементов перечисления, так как строчный массив должен иметь индекс, который начинается с 0 и возрастает каждый раз на 1.
<P class="tj">Так как при операциях ввода/вывода необходимо специально заботиться о преобразовании перечислений в их строчный эквивалент, который можно легко прочитать, то перечисления полезнее всего именно в тех процедурах, где такие преобразования не нужны. Например, перечисления часто применяются, чтобы определить таблицы соответствия символов в компиляторах.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>	Иногда используется термин <I>перечисляемый тип</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>Элементы списка перечисления называются также <I>перечислителями</I> и <I>идентификаторами</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#07">Содержание</A> | <A href="0707.htm">&lt;&lt;&lt;</A> | <A href="0709.htm">&gt;&gt;&gt;</A>
</BODY></HTML>