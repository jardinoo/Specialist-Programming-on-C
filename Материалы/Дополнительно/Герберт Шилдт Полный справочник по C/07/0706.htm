<HTML><HEAD>
<TITLE>Объединения</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#07">Содержание</A> | <A href="0705.htm">&lt;&lt;&lt;</A> | <A href="0707.htm">&gt;&gt;&gt;</A><HR>
<H1>Объединения</H1>
<P class="tj"><I>Объединение</I> — это место в памяти, которое используется для хранения переменных, разных типов. Объединение дает возможность интерпретировать один и тот же набор битов не менее,  чем двумя разными  способами.  Объявление  объединения (начинается с ключевого слова <KBD>union</KBD>) похоже на объявление структуры и в общем виде выглядит так:
<PRE>
union <I>тег</I> {
  <I>тип имя-члена;
  тип имя-члена;
  тип имя-члена;
  .
  .
  .</I>
} <I>переменные-этого-объединения;</I>
</PRE>
<P class="tj">Например:
<PRE>
union u_type {
  int i;
  char ch;
};
</PRE>
<P class="tj">Это объявление не создает никаких переменных. Чтобы объявить переменную, ее имя можно поместить в конце объявления или написать отдельный оператор объявления. Чтобы с помощью только что написанного кода объявить переменную-объединение, которая называется <KBD>cnvt</KBD> и имеет тип <KBD>u_type</KBD>, можно написать следующий оператор:
<PRE>union u_type cnvt;</PRE>
<P class="tj">В <KBD>cnvt</KBD> одну и ту же область памяти занимают целая переменная <KBD>i</KBD> и символьная переменная <KBD>ch</KBD>. Конечно, <KBD>i</KBD> занимает 2 байта (при условии, что целые значения занимают по 2 байта), a <KBD>ch</KBD> — только 1. На рис. 7.2 показано, каким образом <KBD>i</KBD> и <KBD>ch</KBD> пользуются одним и тем же адресом. В любом месте программы хранящиеся в <KBD>cnvt</KBD> данные можно обрабатывать как целые или символьные.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 7.2. Как <KBD>i</KBD>, так и <KBD>ch</KBD>, хранятся в объединении <KBD>cnvt</KBD> (подразумевается, что целые значения занимают по 2 байта)</I>
<TR><TD>
<PRE>
|&lt;------ i ------&gt;|
|                 |
+--------+--------+
| Байт 0 | Байт 1 |
+--------+--------+
|        |
|&lt;- ch -&gt;|
</PRE>
</TABLE>
<P class="tj">Когда переменная объявляется с ключевым словом <KBD>union</KBD>, компилятор автоматически выделяет столько памяти, чтобы в ней поместился самый большой член нового объединения. Например, при условии, что целые значения занимают по 2 байта, для размещения <KBD>i</KBD> в <KBD>cnvt</KBD> необходимо, чтобы длина этого объединения составляла 2 байта, даже если для <KBD>ch</KBD> требуется только 1 байт.
<P class="tj">Для получения доступа к члену объединения используйте тот же синтаксис, что и для структур: операторы точки и стрелки. При работе непосредственно с объединением следует пользоваться точкой. А при получении доступа к объединению с помощью указателя нужен оператор стрелка. Например, чтобы присвоить целое значение 10 элементу <KBD>i</KBD> из <KBD>cnvt</KBD>, напишите
<PRE>cnvt.i = 10;</PRE>
<P class="tj">В следующем примере функции <KBD>func1</KBD> передается указатель на <KBD>cnvt</KBD>:
<PRE>
void func1(union u_type *un)
{
  un-&gt;i = 10; /* присвоение cnvt значение 10 с помощью указателя */
}
</PRE>
<P class="tj">Объединения часто используются тогда, когда нужно выполнить специфическое преобразование типов, потому что хранящиеся в объединениях данные можно обозначать совершенно разными способами. Например, используя объединения, можно манипулировать байтами, составляющими значение типа <KBD>double</KBD>, и делать так, чтобы менять его точность или выполнять какое-либо необычное округление.
<P class="tj">Чтобы получить представление о полезности объединений в случаях, когда нужны нестандартные преобразования типа, подумайте над проблемой записи целых значений типа <KBD>short</KBD> в файл, который находится на диске.
<P class="tj">В стандартной библиотеке языка С не определено никакой функции, специально предназначенной для выполнения этой записи.
<P class="tj">Хотя данные любого типа можно записывать в файл, пользуясь функцией <KBD>fwrite()</KBD>, но было бы нерационально применять этот способ для такой простой операции, как запись на диск целых значений типа <KBD>short</KBD>, так как получится чрезмерный перерасход ресурсов. А вот, используя объединение, можно легко создать функцию <KBD>putw()</KBD>, которая по одному байту будет записывать в файл двоичное представление целого значения типа <KBD>short</KBD>. (В этом примере предполагается, что такие значения имеют длину 2 байта каждое.) Чтобы увидеть, как это делается, вначале создадим объединение, состоящее из целой переменной типа <KBD>short</KBD> и из массива 2-байтовых символов:
<PRE>
union pw {
  short int i;
  char ch[2];
};
</PRE>
<P class="tj">Теперь с помощью <KBD>pw</KBD> можно написать вариант <KBD>putw()</KBD>, приведенный в следующей программе.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

union pw {
  short int i;
  char ch[2];
};

int putw(short int num, FILE *fp);

int main(void)
{
  FILE *fp;

  fp = fopen("test.tmp", "wb+");
  if(fp == NULL) {
    printf("Файл не открыт.\n");
    exit(1);
  }

  putw(1025, fp);  /* запись значения 1025 */
  fclose(fp);

  return 0;
}

int putw(short int num, FILE *fp)
{
  union pw word;

  word.i = num;

  putc(word.ch[0], fp); /* записать первую половину */
  return putc(word.ch[1], fp); /* записать вторую половину */
}
</PRE>
<P class="tj">Хотя функция <KBD>putw()</KBD> и вызывается с целым аргументом типа <KBD>short</KBD>, ей для выполнения побайтовой записи в файл на диске все равно приходится использовать стандартную функцию <KBD>putc()</KBD>.
<HR><A href="../main.htm#07">Содержание</A> | <A href="0705.htm">&lt;&lt;&lt;</A> | <A href="0707.htm">&gt;&gt;&gt;</A>
</BODY></HTML>