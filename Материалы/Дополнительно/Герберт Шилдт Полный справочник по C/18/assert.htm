<HTML><HEAD>
<TITLE>Функция assert</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#18">Содержание</A> | <A href="18.htm#00">Глава 18</A><HR>
<H1>Функция assert</H1>
<PRE>
#include &lt;assert.h&gt;
void assert(int <I>exp</I>);
</PRE>
<P class="tj">Макрос <KBD>assert()</KBD>, определенный в заголовке <KBD>&lt;assert.h&gt;</KBD>, записывает информацию об ошибке в поток <KBD>stderr</KBD>, а затем прекращает выполнение программы, если выражение <I>ехр</I> равно нулю. В противном случае макрос <KBD>assert()</KBD> никаких действий не выполняет. Хотя формат выводимого сообщения зависит от конкретной реализации системы программирования, большинство трансляторов используют сообщение, подобное следующему:
<PRE>Assertion failed: &lt;<I>выражение</I>&gt;, file &lt;<I>имя_файла</I>&gt;, line &lt;<I>номер_строки</I>&gt;</PRE>
<P class="tj">В версии С99 отображаемое сообщение также включает имя функции, содержащей макрос <KBD>assert()</KBD>.
<P class="tj">Макрос <KBD>assert()</KBD> обычно используется, чтобы убедиться в правильном выполнении программы, причем <I>выражение</I> составляется таким образом, что оно истинно только при отсутствии ошибок.
<P class="tj">Нет необходимости удалять из исходного текста программы операторы <KBD>assert()</KBD> после отладки программы, потому что если определить макрос <KBD>NDEBUG</KBD>, то макрос <KBD>assert()</KBD> будет игнорироваться.
<H2>Пример</H2>
<P class="tj">Этот фрагмент кода проверяет, является ли данное, прочитанное из последовательного порта, ASCII-символом (то есть, не используется ли седьмой бит):
<PRE>
/* ... */
ch = read_port();
assert(!(ch & 128)); /* проверяет 7-й бит */
</PRE>
<H2>Зависимые функции</H2>
<A href="abort.htm">abort()</A>
<HR><A href="../main.htm#18">Содержание</A> | <A href="18.htm#00">Глава 18</A>
</BODY></HTML>