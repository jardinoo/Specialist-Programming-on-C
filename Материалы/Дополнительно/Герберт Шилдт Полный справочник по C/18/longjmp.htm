<HTML><HEAD>
<TITLE>Функция longjmp</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#18">Содержание</A> | <A href="18.htm#00">Глава 18</A><HR>
<H1>Функция longjmp</H1>
<PRE>
#include &lt;setjmp.h&gt;
void longjmp(jmp_buf <I>envbuf</I>, int <I>status</I>);
</PRE>
<P class="tj">Функция <KBD>longjmp()</KBD> возобновляет выполнение программы с места последнего обращения к функции <KBD>setjmp()</KBD>. Таким образом, функции <KBD>longjmp()</KBD> и <KBD>setjmp()</KBD> предоставляют средство передачи управления между функциями. Обратите внимание на необходимость включения заголовка <KBD>&lt;setjmp.h&gt;</KBD>.
<P class="tj">Функция <KBD>longjmp()</KBD> восстанавливает состояние стека, сохраненное в буфере <I>envbuf</I> с помощью функции <KBD>setjmp()</KBD>. В результате выполнение программы возобновляется с оператора, следующего за вызовом функции <KBD>setjmp()</KBD>. Иначе говоря, компьютер "вводится в заблуждение": "он считает", будто управление программой не выходило за пределы функции, которая вызвала функцию <KBD>setjmpt()</KBD>. (Выражаясь образно, функция <KBD>longjmp()</KBD> подобна многомерной машине пространства-времени. Она позволяет путешествовать во времени, не соблюдая какой бы то ни было последовательности событий: с ее помощью можно вернуться в "покинутый мир", не обращая внимания на то, что предварительно должен был быть произведен выход из вызванных функций. С ее помощью можно "вернуться домой", минуя промежуточные пункты. Она "искривляет" время и пространство (памяти) так, что с ее помощью можно попасть в покинутую точку программы, не выполняя нормальный процесс возврата из функции.)
<P class="tj">Буфер <I>evnbuf</I> имеет тип <KBD>jmp_buf</KBD>, который определен в заголовке <KBD>&lt;setjmp.h&gt;</KBD>. Этот буфер должен быть заполнен в результате обращения к функции <KBD>setjmp()</KBD> еще до вызова функции <KBD>longjmp()</KBD>.
<P class="tj">Значение параметра <I>status</I> становится возвращаемым значением функции <KBD>setjmp()</KBD>, и оно используется для того, чтобы определить "происхождение длинного перехода". Единственным недопустимым значением является нуль. Функция <KBD>setjmp()</KBD> возвращает нуль в том случае, когда она вызывается непосредственно программой, а не косвенно, т.е. путем выполнения функции <KBD>longjmp()</KBD>.
<P class="tj">Функция <KBD>longjmp()</KBD> используется в основном для возврата из глубоко вложенного набора функций при возникновении ошибок.
<H2>Пример</H2>
<P class="tj">Эта программа печатает <PRE>1 2 3</PRE>
<PRE>
#include &lt;setjmp.h&gt;
#include &lt;stdio.h&gt;

jmp_buf ebuf;
void f2(void);

int main(void)
{
  int i;

  printf("1 ");
  i = setjmp(ebuf);
  if(i == 0) {
    f2();
    printf("Это не будет напечатано.");
  }
  printf("%d", i);

  return 0;
}

void f2(void)
{
  printf("2 ");
  longjmp(ebuf, 3);
}
</PRE>
<H2>Зависимые функции</H2>
<A href="setjmp.htm">setjmp()</A>
<HR><A href="../main.htm#18">Содержание</A> | <A href="18.htm#00">Глава 18</A>
</BODY></HTML>