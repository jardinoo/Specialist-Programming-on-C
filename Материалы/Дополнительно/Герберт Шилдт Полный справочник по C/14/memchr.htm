<HTML><HEAD>
<TITLE>Функция memchr</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#14">Содержание</A> | <A href="14.htm#00">Глава 14</A><HR>
<H1>Функция memchr</H1>
<PRE>
#include &lt;string.h&gt;
void *memchr(const void *<I>buffer</I>, int <I>ch</I>, size_t <I>count</I>);
</PRE>
<P class="tj">Функция <KBD>memchr()</KBD> просматривает массив, адресуемый параметром <I>buffer</I>, чтобы отыскать первое вхождение символа <I>ch</I> в первых <I>count</I> символах.
<P class="tj">Эта функция возвращает указатель на первый из символов <I>ch</I>, входящих в массив <I>buffer</I>, или нулевой указатель, если символ <I>ch</I> не найден.
<H2>Пример</H2>
<P class="tj">Данная программа выводит на экран сообщение из примера.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char *p;

  p = memchr("строка из примера", ' ', 17);
  printf(p);

  return 0;
} 
</PRE>
<H2>Еще один пример</H2>
<P class="tj">Некоторые примеры, приведенные в качестве иллюстрации применения строковых функций, иногда носят "несколько учебный" характер и не всегда могут быть рекомендованы для профессионального программирования. Например, указание константы 17 в операторе 
<PRE>p = memchr("строка из примера", ' ', 17);</PRE>
<P class='t'>предыдущего примера едва ли может служить хорошим примером для программиста. (Кстати сказать, против подобного употребления констант автор предупреждал читателей в предыдущих главах. Просто в данной программе автор не хотел "затенять" основную идею посторонними деталями.) Подумайте, что будет, если изменить строку? Опять подсчитывать количество символов? Чтобы избежать этого, во многих руководствах предлагается использовать для этой цели функцию <KBD>strlen</KBD>. Вот какой пример применения приводится, например, в документации по Borland C++ Builder 5:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char str[17];
  char *ptr;

  strcpy(str, "This is a string");
  ptr = (char *) memchr(str, 'r', strlen(str));

  if (ptr)
    printf("The character 'r' is at position: %d\n", ptr - str);
  else
    printf("The character was not found\n"); return 0;
}
</PRE>
<P class="tj">В данном примере, правда, константа указана в объявлении массива <KBD>str</KBD>. Однако этого можно было легко избежать, проинициализировав массив в объявлении. Правда, остается еще один недостаток: некоторое снижение эффективности кода из-за вызова функции <KBD>strlen</KBD>. Но и его можно устранить, если длина строки может быть вычислена при компиляции (как в наших примерах). Действительно, тогда ведь можно воспользоваться операцией <KBD>sizeof</KBD> и записать не константу 17, а константное выражение <KBD>sizeof (str) /sizeof (char)</KBD>. (Отсюда вывод: никогда не верьте тем, кто говорит, что последовательное применение технологии программирования приводит к ухудшенению характеристик программы. Если язык программирования хорошо сконструирован, то ничего подобного быть не может. Правда, если язык продуман плохо... то едва ли стоит на нем писать программы!).
<H2>Зависимые функции</H2>
<A href="memcpy.htm">memcpy()</A>  <A href="isspace.htm">isspace()</A>
<HR><A href="../main.htm#14">Содержание</A> | <A href="14.htm#00">Глава 14</A>
</BODY></HTML>