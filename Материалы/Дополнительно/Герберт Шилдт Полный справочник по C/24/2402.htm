<HTML><HEAD>
<TITLE>Разбиение выражения на лексемы</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#24">Содержание</A> | <A href="2401.htm">&lt;&lt;&lt;</A> | <A href="2403.htm">&gt;&gt;&gt;</A><HR>
<H1>Разбиение выражения на лексемы</H1>
<P class="tj">Для того чтобы вычислять выражения, необходимо уметь разбивать их на отдельные составляющие. Например, выражение А * В - (W + 10) состоит из таких элементов: А, *, В, -, (, W, +, 10 и ). Каждый из них представляет единую неделимую часть выражения. В общем случае необходима функция, которая возвращает один за другим все элементы выражения. Эта функция также должна уметь пропускать пробелы и символы табуляции и определять конец выражения.
<P class="tj">Каждый элемент выражения называется <I>лексемой</I> (token). Поэтому функция, возвращающая очередную лексему, часто называется <KBD>get_token()</KBD>. В этой функции используется глобальный указатель на строку с разбираемым выражением. В показанной здесь версии функции <KBD>get_token()</KBD> этот глобальный указатель называется <KBD>prog</KBD>. Переменная <KBD>prog</KBD> описана глобально, поскольку она должна сохранять свое значение между вызовами функции <KBD>get_token()</KBD> и быть доступной другим функциям. Помимо значения возвращаемой лексемы, необходимо знать ее тип. Для анализатора, разрабатываемого в данной главе, понадобятся только три типа: переменная, число и разделитель. Им соответствуют константы <KBD>VARIABLE</KBD>, <KBD>NUMBER</KBD> и <KBD>DELIMITER</KBD>, (<KBD>DELIMITER</KBD> используется как для операторов, так и для скобок.) Ниже приведен текст функции <KBD>get_token()</KBD> вместе с необходимыми глобальными описаниями, константами и вспомогательной функцией:
<PRE>
#define DELIMITER 1
#define VARIABLE  2
#define NUMBER    3

extern char *prog;  /* указатель на анализируемое выражение */
char token[80];
char tok_type;

/* Данная функция возвращает очередную лексему. */
void get_token(void)
{
  register char *temp;

  tok_type = 0;
  temp = token;
  *temp = '\0';

  if(!*prog) return; /* конец выражения */
  while(isspace(*prog)) ++prog;  /* пропустить пробелы, символы
                                    табуляции и пустой строки */

  if(strchr("+-*/%^=()", *prog)){
    tok_type = DELIMITER;
    /* продвинуться к следующему символу */
    *temp++ = *prog++;
  }
  else if(isalpha(*prog)) {
    while(!isdelim(*prog)) *temp++ = *prog++;
    tok_type = VARIABLE;
  }
  else if(isdigit(*prog)) {
    while(!isdelim(*prog)) *temp++ = *prog++;
    tok_type = NUMBER;
  }

  *temp = '\0';
}

/* Возвращает значение ИСТИНА, если с является раздилителем. */
int isdelim(char c)
{
  if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)
    return 1;
  return 0;
}
</PRE>
<P class="tj">Давайте рассмотрим приведенные выше функции более подробно. После нескольких инициализаций функция <KBD>get_token()</KBD> проверяет, не достигнут ли символ конца строки ( '0' ), завершающий выражение. Если в выражении еще есть неразобранная часть, функция <KBD>get_token()</KBD> сначала пропускает ведущие пробелы, если они имеются. После этого переменная <KBD>prog</KBD> указывает на число, переменную, оператор или — если выражение завершалось пробелами — на символ конца строки ( '0' ). Если очередной символ является оператором, он возвращается в виде строки, хранимой в глобальной переменной <KBD>token</KBD>, а переменной <KBD>tok_type</KBD>, содержащей тип полученной лексемы, присваивается значение <KBD>DELIMITER</KBD>. Если же следующий символ является буквой, он считается именем переменной и возвращается в строковой переменной <KBD>token</KBD>. При этом <KBD>tok_type</KBD> получает значение <KBD>VARIABLE</KBD>. В случае, когда очередной символ является цифрой, считывается все число, причем оно помещается в переменную <KBD>token</KBD>, а его типом будет <KBD>NUMBER</KBD>. Наконец, если следующий символ не является ни одним из перечисленных выше, считается, что достигнут конец выражения. В этом случае <KBD>token</KBD> содержит пустую строку, возврат которой означает конец выражения.
<P class="tj">Как уже было сказано ранее, чтобы не усложнять код этой функции, были опущены некоторые средства контроля за ошибками и сделаны некоторые допущения. Например, любой нераспознанный символ завершает выражение. Кроме того, в данной версии программы имена переменных могут иметь любую длину, но значащей является только первая буква. В соответствии с требованиями конкретной задачи вы можете усложнить средства контроля за ошибками и добавить другие подробности. Функцию <KBD>get_token()</KBD> можно доработать или модифицировать, чтобы она выбирала из входного выражения строки символов, числа других типов или лексемы другого типа.
<P class="tj">Чтобы лучше понять принцип действия функции <KBD>get_token()</KBD>, ниже приведены возвращаемые ей лексемы и типы лексем для следующего входного выражения:
<PRE>A + 100 - (B * C) /2</PRE>
<TABLE align=center border=1 width=100%>
<TR><TH><I>Лексема</I><TH><I>Тип лексемы</I>
<TR><TD>А<TD>VARIABLE
<TR><TD>+<TD>DELIMITER
<TR><TD>100<TD>NUMBER
<TR><TD>-<TD>DELIMITER
<TR><TD>(<TD>DELIMITER
<TR><TD>В<TD>VARIABLE
<TR><TD>*<TD>DELIMITER
<TR><TD>С<TD>VARIABLE
<TR><TD>)<TD>DELIMITER
<TR><TD>/<TD>DELIMITER
<TR><TD>2<TD>NUMBER
<TR><TD>нуль (конец строки)<TD>0(нуль)
</TABLE>
<P class="tj">Следует помнить, что переменная <KBD>token</KBD> всегда содержит строку, завершающуюся символом конца строки ('0'), даже если эта строка состоит только из одного символа.
<HR><A href="../main.htm#24">Содержание</A> | <A href="2401.htm">&lt;&lt;&lt;</A> | <A href="2403.htm">&gt;&gt;&gt;</A>
</BODY></HTML>