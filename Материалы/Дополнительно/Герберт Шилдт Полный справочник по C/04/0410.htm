<HTML><HEAD>
<TITLE>Приемы использования массивов и строк на примере игры в крестики-нолики</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#04">Содержание</A> | <A href="0409.htm">&lt;&lt;&lt;</A> | <A href="../05/05.htm">&gt;&gt;&gt;</A><HR>
<H1>Приемы использования массивов и строк на примере игры в крестики-нолики</H1>
<P class="tj">Представленный длинный пример иллюстрирует большое количество приемов использования строк. Рассматривается простая программа игры в крестики-нолики. Двухмерный массив используется в качестве матрицы, изображающей игральную доску.
<P class="tj">Компьютер играет в очень простую игру. Когда наступает очередь хода компьютера, функция <KBD>get_computer_move()</KBD> просматривает матрицу в поиске незанятых ячеек. Если функция находит незанятую ячейку, она помещает туда символ <KBD>O</KBD>. Если незанятой ячейки нет, то функция выводит сообщение об окончании игры и прекращает работу программы. Функция <KBD>get_player_move()</KBD> спрашивает играющего, где он хочет поместить символ <KBD>X</KBD>. Верхний левый угол имеет координаты (1, 1), а нижний правый — (3, 3).
<P class="tj">Массив <KBD>matrix</KBD>, содержащий матрицу игры, инициализирован символами пробела. Каждый ход, сделанный игроком или компьютером, заменяет символ пробела символом <KBD>X</KBD> или <KBD>O</KBD>. Это позволяет легко отобразить матрицу на экране.
<P class="tj">После каждого хода вызывается функция <KBD>check()</KBD>, которая возвращает пробел, если победителя еще нет, или <KBD>X</KBD>, если победил игрок, или <KBD>O</KBD>, когда победил компьютер. Эта функция просматривает строки, столбцы и диагонали в поиске трех одинаковых символов (<KBD>X</KBD> или <KBD>O</KBD>) подряд.
<P class="tj">Функция <KBD>disp_matrix()</KBD> отображает на экране текущее состояние игры. Обратите внимание на то, как существенно упрощает эту функцию инициализация матрицы пробелами.
<P class="tj">Функции получают доступ к массиву <KBD>matrix</KBD> различными способами. Их стоит внимательно изучить для лучшего понимания приемов работы с массивами.
<PRE>
/* Простая игра в крестики-нолики. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

char matrix[3][3];  /* матрица игры */

char check(void);
void init_matrix(void);
void get_player_move(void);
void get_computer_move(void);
void disp_matrix(void);

int main(void)
{
  char done;

  printf("Это игра в крестики-нолики.\n");
  printf("Вы будете играть против компьютера.\n");

  done =  ' ';
  init_matrix();

  do {
    disp_matrix();
    get_player_move();
    done = check(); /* проверка, есть ли победитель */
    if(done!= ' ') break; /* есть победитель */
    get_computer_move();
    done = check(); /* проверка, есть ли победитель */
  } while(done== ' ');

  if(done=='X') printf("Вы победили!\n");
  else printf("Победил компьютер!!!!\n");
  disp_matrix(); /* показ финальной позиции */

  return 0;
}

/* Инициализация матрицы игры. */
void init_matrix(void)
{
  int i, j;

  for(i=0; i&lt;3; i++)
    for(j=0; j&lt;3; j++) matrix[i][j] =  ' ';
}

/* Ход игрока. */
void get_player_move(void)
{
  int x, y;

  printf("Введите координаты X,Y Вашего хода: ");
  scanf("%d%*c%d", &x, &y);

  x--; y--;

  if(matrix[x][y]!= ' '){
    printf("Неверный ход, попытайтесь еще.\n");
    get_player_move();
  }
  else matrix[x][y] = 'X';
}

/* Ход компьютера. */
void get_computer_move(void)
{
  int i, j;
  for(i=0; i&lt;3; i++){
    for(j=0; j&lt;3; j++)
      if(matrix[i][j]==' ') break;
    if(matrix[i][j]==' ') break;
  /* Второй break нужен для выхода из цикла по i */
  }

  if(i*j==9)  {
    printf("Конец игры\n");
    exit(0);
  }
  else
    matrix[i][j] = 'O';
}

/* Вывод матрицы на экран. */
void disp_matrix(void)
{
  int t;

  for(t=0; t&lt;3; t++) {
    printf(" %c | %c | %c ",matrix[t][0],
            matrix[t][1], matrix [t][2]);
    if(t!=2) printf("\n---|---|---\n");
  }
  printf("\n");
}

/* Определение победителя. */
char check(void)
{
  int i;

  for(i=0; i&lt;3; i++)  /* проверка строк */
    if(matrix[i][0]==matrix[i][1] &&
       matrix[i][0]==matrix[i][2]) return matrix[i][0];

  for(i=0; i&lt;3; i++)  /* проверка столбцов */
    if(matrix[0][i]==matrix[1][i] &&
       matrix[0][i]==matrix[2][i]) return matrix[0][i];

  /* проверка диагоналей */
  if(matrix[0][0]==matrix[1][1] &&
     matrix[1][1]==matrix[2][2])
       return matrix[0][0];

  if(matrix[0][2]==matrix[1][1] &&
     matrix[1][1]==matrix[2][0])
       return matrix[0][2];

  return ' ';
}
</PRE>
<P class="tj"><B>Пояснение к программе</B>. В функции <KBD>get_player_move()</KBD> с помощью библиотечной функции <KBD>scanf()</KBD> считываются с клавиатуры два целых числа <KBD>x</KBD> и <KBD>y</KBD>. Функция <KBD>scanf()</KBD> при считывании чисел предполагает, что во входном потоке они разделены пробелами (или пробельными символами), другие разделительные символы не допускаются. Однако многие пользователи привыкли к тому, что числа можно разделять, например, запятыми. (Собственно говоря, именно так и предлагается в подсказке, выдаваемой программой.) В приведенном примере символ, следующий непосредственно после первого числа, просто игнорируется, именно для этого в функции <KBD>scanf()</KBD> используется спецификатор формата <KBD>%*c</KBD>. Звездочка означает, что символ считывается из потока, но в память не записывается.
<HR><A href="../main.htm#04">Содержание</A> | <A href="0409.htm">&lt;&lt;&lt;</A> | <A href="../05/05.htm">&gt;&gt;&gt;</A>
</BODY></HTML>