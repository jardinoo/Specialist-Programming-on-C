<HTML><HEAD>
<TITLE>Двухмерные массивы</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#04">Содержание</A> | <A href="0404.htm">&lt;&lt;&lt;</A> | <A href="0406.htm">&gt;&gt;&gt;</A><HR>
<H1>Двухмерные массивы</H1>
<P class="tj">Стандартом С определены многомерные массивы. Простейшая форма многомерного массива — двухмерный массив. Двухмерный массив — это массив одномерных массивов. Объявление двухмерного массива <KBD>d</KBD> с размерами 10 на 20 выглядит следующим образом:
<PRE>int d[10][20];</PRE>
<P class="tj">Во многих языках измерения массива отделяются друг от друга запятой. В языке С каждое измерение заключено в свои квадратные скобки.
<P class="tj">Аналогично обращению к элементу одномерного массива, обращение к элементу с индексами 1 и 2 двухмерного массива <KBD>d</KBD> выглядит так:
<PRE>d[1][2]</PRE>
<P class="tj">В следующем примере элементам двухмерного массива присваиваются числа от 1 до 12 и значения элементов выводятся на экран построчно:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int t, i, num[3][4];

  for(t=0; t&lt;3; ++t)
    for(i=0; i&lt;4; ++i)
      num[t][i] = (t*4)+i+1;

  /* вывод на экран */
  for(t=0; t&lt;3; ++t) {
    for(i=0; i&lt;4; ++i)
      printf("%3d ", num[t][i]);
    printf("\n");
  }

  return 0;
}
</PRE>
<P class="tj">В этом примере <KBD>num[0][0]</KBD> имеет значение 1, <KBD>num[0][1]</KBD> — значение 2, <KBD>num[0][2]</KBD> — значение 3 и так далее. Наглядно двухмерный массив <KBD>num</KBD> можно представить так:
<PRE>
num[t][i]
      | 0  1  2  3
    --+----------- 
    0 | 1  2  3  4
    2 | 5  6  7  8
    3 | 9  10 11 12
</PRE>
<P class="tj">Двухмерные массивы размещаются в матрице, состоящей из строк и столбцов. Первый индекс указывает номер строки, а второй — номер столбца. Это значит, что когда к элементам массива обращаются в том порядке, в котором они размещены в памяти, правый индекс изменяется быстрее, чем левый. На рис. 4.2 показано графическое представление двухмерного массива в памяти.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 4.2. Двухмерные массивы</I>
<TR><TD>
<PRE>
            Объявление массива <KBD>char ch[3][4]</KBD>

        Правый индекс определяет номер столбца
                   |          |          |
   о               V          V          V
   п      +----------+----------+----------+
Л  р    -&gt;|ch [0] [0]|ch [0] [1]|ch [0] [2]|
е  е      +----------+----------+----------+
в  д
ы  е      +----------+----------+----------+
й  л  с -&gt;|ch [1] [0]|ch [1] [1]|ch [1] [2]|
   я  т   +----------+----------+----------+
и  е  р
н  т  о   +----------+----------+----------+
д     к -&gt;|ch [2] [0]|ch [2] [1]|ch [2] [2]|
е  н  и   +----------+----------+----------+
к  о
с  м      +----------+----------+----------+
   е    -&gt;|ch [3] [0]|ch [3] [1]|ch [3] [2]|
   р      +----------+----------+----------+

</PRE>
</TABLE>
<P class="tj">Объем памяти в байтах, занимаемый двухмерным массивом, вычисляется по следующей формуле:
<PRE>
количество_байтов =
= размер_1-го_измерения &#215; размер_2-го_измерения &#215; sizeof(базовый_тип)
</PRE>
<P class="tj">Например, двухмерный массив 4-байтовых целых чисел размерностью 10&#215;5 занимает участок памяти объемом
<PRE>10&#215;5&#215;4</PRE>
<P class="t">то есть 200 байтов.
<P class="tj">Если двухмерный массив используется в качестве аргумента функции, то в нее передается только указатель на начальный элемент массива. В соответствующем параметре функции, получающем двухмерный массив, обязательно должен быть указан размер правого измерения<SUP><A href="#11" name="1">[1]</A></SUP>, который равен длине строки массива. Размер левого измерения указывать не обязательно. Размер правого измерения необходим компилятору для того, чтобы внутри функции правильно вычислить адрес элемента массива, так как для этого компилятор должен знать длину строки массива. Например, функция, получающая двухмерный массив целых размерностью 10&#215;10, должна быть объявлена так:
<PRE>
void func1(int x[][10])
{
  /* ... */
}
</PRE>
<P class="tj">Компилятор должен знать длину строки массива, чтобы внутри функции правильно вычислить адрес элемента массива. Если при компиляции функции это неизвестно, то невозможно определить, где начинается следующая строка, и вычислить, например, адрес элемента
<PRE>x[2][4]</PRE>
<P class="tj">В следующем примере двухмерные массивы используются для хранения оценок студентов. Предполагается, что преподаватель ведет три класса, в каждом из которых учится не более 30 студентов. Обратите внимание на то, как происходит обращение к массиву <KBD>grade</KBD> в каждой функции.
<PRE>
/* Простая база данных оценок студентов. */
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

#define CLASSES  3
#define GRADES  30

int grade[CLASSES][GRADES];

void enter_grades(void);
int get_grade(int num);
void disp_grades(int g[][GRADES]);

int main(void)
{
  char ch, str[80];

  for(;;) {
    do {
      printf("(В)вод оценок студентов\n");
      printf("В(ы)вод оценок студентов\n");
      printf("Вы(х)од\n");
      gets(str);
      ch = toupper(*str);
    } while(ch!='В' && ch!='ы' && ch!='х');

    switch(ch) {
      case 'В':
        enter_grades();
        break;
      case 'ы':
        disp_grades(grade);
        break;
      case 'х':
        exit(0);
    }
  }

  return 0;
} 

/* Занесение оценок студентов в массив. */
void enter_grades(void)
{
  int t, i;

  for(t=0; t&lt;CLASSES; t++) {
    printf("Класс № %d:\n", t+1);
    for(i=0; i&lt;GRADES; ++i)
      grade[t][i] = get_grade(i);
  }
}

/* Ввод оценок. */
int get_grade(int num)
{
  char s[80];

  printf("Введите оценку студента № %d:\n", num+1);
  gets(s);
  return(atoi(s));
}

/* Вывод оценок. */
void disp_grades(int g[][GRADES])
{
  int t, i;

  for(t=0; t&lt;CLASSES; ++t) {
    printf("Класс № %d:\n", t+1);
    for(i=0; i&lt;GRADES; ++i)
      printf("Студент № %d имеет оценку %d\n", i+1, g[t][i]);
  }
}
</PRE>
<H2>Массивы строк</H2>
<P class="tj">В программах на языке С часто используются массивы строк. Например, сервер базы данных сверяет команды пользователей с массивом допустимых команд. В качестве массива строк в языке С служит двухмерный символьный массив. Размер левого измерения определяет количество строк, а правого — максимальную длину каждой строки. Например, в следующем операторе объявлен массив из 30 строк с максимальной длиной 79 символов:
<PRE>char str_array[30][80];</PRE>
<P class="tj">Чтобы обратиться к отдельной строке массива, нужно указать только левый индекс. Например, вызов функции <KBD>gets()</KBD> с третьей строкой массива <KBD>str_array</KBD> в качестве аргумента можно записать так:
<PRE>gets(str_array[2]);</PRE>
<P class="tj">Этот оператор эквивалентен следующему:
<PRE>gets(&str_array[2][0]);</PRE>
<P class="tj">Из этих двух форм записи предпочтительной является первая.
<P class="tj">Для лучшего понимания свойств массива строк рассмотрим следующую короткую программу, в которой на основе применения массива строк создан простой текстовый редактор:
<PRE>
/* Очень простой текстовый редактор. */
#include &lt;stdio.h&gt;

#define MAX 100
#define LEN 80

char text[MAX][LEN];

int main(void)
{
  register int t, i, j;

  printf("Для выхода введите пустую строку.\n");

  for(t=0; t&lt;MAX; t++) {
    printf("%d: ", t);
    gets(text[t]);
    if(!*text[t]) break; /* выход по пустой строке */
  }

  for(i=0; i&lt;t; i++) {
    for(j=0; text[i][j]; j++) putchar(text[i][j]);
    putchar('\n');
  }

  return 0;
}
</PRE>
<P class="tj">Пользователь вводит в программу строки текста, заканчивая ввод пустой строкой. Затем программа выводит текст посимвольно.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Размер правого измерения указывать не нужно, если в вызывающей функции массив объявлен как <KBD>**х</KBD> и размещен динамически (см. <A href="../05/05.htm">главу 5</A>)
</BLOCKQUOTE>
<HR><A href="../main.htm#04">Содержание</A> | <A href="0404.htm">&lt;&lt;&lt;</A> | <A href="0406.htm">&gt;&gt;&gt;</A>
</BODY></HTML>