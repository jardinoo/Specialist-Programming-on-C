<HTML><HEAD>
<TITLE>Отладка</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#28">Содержание</A> | <A href="2802.htm">&lt;&lt;&lt;</A> | <A href="../VI.htm">&gt;&gt;&gt;</A><HR>
<H1>Отладка</H1>
<P class="tj">Перефразировав Томаса Эдисона, можно утверждать, что программирование на 10 процентов состоит из вдохновения и на 90 процентов из отладки. Все действительно квалифицированные программисты являются хорошими отладчиками. Чтобы научиться предотвращать множество ошибок, целесообразно рассмотреть некоторые довольно распространенные действия, которые могут привести к их появлению.
<H2>Ошибки очередности вычисления</H2>
<P class="tj">В большинстве С-программ применяются операторы инкрементирования и декрементирования, а порядок следования этих операторов, как вы помните, имеет большое значение в зависимости от того, предшествуют они или следуют за переменной. Рассмотрим следующий случай:
<PRE>
y = 10;     y = 10;
x = y++;    x = ++y;
</PRE>
<P class="tj">Приведенные две последовательности не эквивалентны. Та, что слева, присваивает переменной <KBD>х</KBD> значение <KBD>10</KBD>, а затем инкрементирует <KBD>у</KBD>. В другой же последовательности (справа) <KBD>у</KBD> сначала инкрементируется, и в результате этого становится равным <KBD>11</KBD>, и только затем значение <KBD>11</KBD> присваивается переменной <KBD>х</KBD>. Таким образом, в первом случае <KBD>х</KBD> равно <KBD>10</KBD>, а во втором случае <KBD>х</KBD> — <KBD>11</KBD>. В общем случае в сложных выражениях префиксная операция инкрементирования (или декрементирования) осуществляется перед вычислением значения операнда, используемого в последующих действиях. Постфиксный инкремент (или декремент) выполняется в сложных выражениях после того, как значение операнда вычислено. Если забыть об этих правилах, проблем не миновать.
<P class="tj">Путь, обычно ведущий к возникновению ошибки очередности вычисления, заключается в изменении имеющейся последовательности операторов. Например, при оптимизации фрагмента кода вы могли бы изменить следующую последовательность:
<PRE>
/* первоначальный код */
x = a + b;
a = a + 1;
</PRE>
<P class="t">и представить ее в таком виде:
<PRE>
/* "усовершенствованный" код - ошибка! */
x = ++a + b;
</PRE>
<P class="tj">Проблема заключается в том, что эти два фрагмента кода не дают одинаковый результат. Причина состоит в том, что второй способ инкрементирует переменную <KBD>а</KBD> до того, как она суммируется с <KBD>b</KBD>. А такое действие в первоначальном варианте не было предусмотрено!
<P class="tj">Подобные ошибки относятся к разряду трудно обнаруживаемых. Могут быть ключи-подсказки, например циклы, выполняющиеся неправильно, или процедуры, которые не работают из-за таких ошибок. Если у вас возникает сомнение в правильности оператора, перекодируйте его таким образом, чтобы быть уверенным в нем на все 100 процентов.
<H2>Проблемы с указателями</H2>
<P class="tj">Очень распространенной ошибкой в С-программах является неправильное применение указателей. Проблемы с указателями условно можно разделить на две основные категории: неправильное представление об использовании косвенной адресации и об операциях над указателями вообще, а также случайное (точнее непредумышленное) применение недействительных или неинициализированных указателей. Решить первую проблему несложно: просто разберитесь окончательно и до конца в том, что означают операторы <KBD>*</KBD> и <KBD>&</KBD>! Справиться со второй категорией проблем с указателями несколько сложнее.
<P class="tj">Ниже приведена программа, иллюстрирующая оба типа ошибок, связанных с указателями:
<PRE>
/* Эта программа содержит ошибку. */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  char *p;

  *p = (char *) malloc(100); /* эта строка содержит ошибку */
  gets(p);
  printf(p);

  return 0;
}
</PRE>
<P class="tj">При запуске такой программы скорее всего произойдет ее сбой. Объясняется это тем, что значение адреса, возвращаемого функцией <KBD>malloc()</KBD>, не было присвоено указателю <KBD>р</KBD>, а было размещено в ячейку памяти, на которую указывает <KBD>р</KBD>, адрес которой в данном случае неизвестен (и в общем случае, непредсказуем). Данный тип ошибки представляет пример фундаментального непонимания выполнения операторов над указателями (а именно выполнения операции <KBD>*</KBD>). Как правило, такая ошибка в программах на С допускается начинающими программистами, но иногда эта нелепая оплошность встречается и у опытных профессионалов! Чтобы исправить эту программу, необходимо заменить строку с ошибкой следующей корректной строкой:
<PRE>*р = (char *) malloc(100);  /* эта строка правильная */</PRE>
<P class="tj">Кроме того, данная программа содержит еще одну, причем более коварную ошибку. В ней отсутствует динамическая проверка значения адреса, возвращаемого функцией <KBD>malloc()</KBD>. Помните, если память будет исчерпана, <KBD>malloc()</KBD> возвратит значение <KBD>NULL</KBD>, а тогда указатель использовать нельзя. Использование <KBD>NULL</KBD> в качестве указателя объекта недопустимо и практически всегда ведет к аварийному завершению программы. Вот исправленный вариант данной программы, в который включена проверка допустимости указателя:
<PRE>
/* Теперь эта программа написана корректно. */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  char *p;

  p = (char *) malloc(100); /* эта строка не содержит ошибок */

  if(!p) {
    printf("Нет памяти.\n");
    exit(1);
  }

  gets(p);
  printf(p);

  return 0;
}
</PRE>
<P class="tj">Следующая часто встречающаяся ошибка заключается в том, что программист забывает инициализировать указатель перед использованием. Обратимся к следующему фрагменту программы:
<PRE>
int *x;
*x = 100;
</PRE>
<P class="tj">Выполнение такого кода обязательно приведет к проблемам, поскольку указатель <KBD>х</KBD> не был инициализирован, а значит, едва ли можно ожидать, что он указывает туда, куда нужно. Фактически вы не знаете, куда указывает <KBD>х</KBD>. Присвоение какого-либо значения этой неизвестной области памяти может разрушить что-то, имеющее огромное значение, например другой фрагмент программы или данные.
<P class="tj">Самая большая неприятность с "дикими" (т.е. непредсказуемыми) указателями состоит в том, что их невероятно тяжело обнаружить. Если вы присваиваете значение посредством указателя, который не содержит действительный адрес, ваша программа в одних случаях может функционировать вполне корректно, а в других — завершаться аварийным отказом. Чем меньше размер программы, тем выше вероятность, что она будет работать правильно, даже с "блуждающим" указателем. Это объясняется тем, что в таком случае программой используется очень маленький объем памяти, поэтому довольно велики шансы того, что указатель-нарушитель указывает на неиспользуемую область памяти. Но по мере увеличения объема программы подобные сбои будут происходить все чаще и чаще. Но вы скорее попытаетесь объяснить их последними внесенными в программу дополнениями или изменениями, и вряд ли свяжете с ошибками в использовании указателей. Следовательно, вы будете искать ошибки совершено не в том месте.
<P class="tj">Подсказкой для распознавания проблем с указателем является то, что такие ошибки часто проявляются нерегулярно и зачастую странными образом. Один раз программа работает вполне корректно, а другой раз — неправильно. Иногда некоторые переменные содержат "мусор", хотя на то нет каких бы то ни было видимых причин. Когда возникают подобные проблемы, проверьте все указатели. Собственно говоря, вы всегда должны проверять все указатели, как только начнут проявляться любые ошибки<SUP><A href="#11" name="1">[1]</A></SUP>.
<P class="tj">Возможно, утешением, станет то, что хотя указатели могут доставить множество хлопот, тем не менее, они являются одним из наиболее мощных средств языка С и стоят преодоления любой проблемы, которую они могут вам преподнести. Просто постарайтесь с самого начала изучить их правильное применение.
<H2>Интерпритация синтаксических ошибок</H2>
<P class="tj">Время от времени вы будете сталкиваться с синтаксическими ошибками, сообщения о которых покажутся вам абсурдными и бессмысленными. То ли сообщение об ошибке зашифровано, то ли ошибка, описание которой приводится в сообщении, вообще не похожа на ошибку. Тем не менее, в большинстве случаев в вопросах обнаружения ошибок компилятор оказывается прав. Просто в подобных случаях сам текст сообщения об ошибке чуть-чуть не дотягивает до совершенства. При поиске причин необычных синтаксических ошибок, как правило, необходимо при чтении программы немного возвратиться назад. Поэтому, если вы столкнулись с сообщением об ошибке, которое, судя по всему, не имеет смысла, попробуйте поискать синтаксическую ошибку одной двумя строками выше по тексту вашей программы.
<P class="tj">С одной из особенно сногсшибательных ошибок можно познакомиться ближе, если вы попытаетесь скомпилировать следующий код:
<PRE>
char *myfunc(void);

int main(void)
{
  /* ... */
}

int myfunc(void) /* сообщение об ошибке указывает сюда */
{
  /* ... */
}
</PRE>
<P class="tj">Ваш компилятор выдаст сообщение об ошибке вместе с таким вот разъяснением:
<PRE>
Type mismatch in redeclaration of myfunc(void)
(Несоответствие типов при повторном объявлении myfunc(void))
</PRE>
<P class="tj">Это сообщение относится к строке листинга программы, которая помечена комментарием о наличии ошибки. Как такое возможно? Ведь в этой строке нет двух функций <KBD>myfunc()</KBD>. А разгадка состоит в том, что прототип в верхней строке программы показывает, что <KBD>myfunc()</KBD> возвращает значение типа указатель на символ. Это ведет к тому, что в таблице идентификаторов компилятор заполняет строку, содержащую эту информацию. Когда затем в программе компилятор встречает функцию <KBD>myfunc()</KBD>, то теперь тип результата указывается как <KBD>int</KBD>. Следовательно, вы "повторно объявили", другими словами "переопределили" функцию.
<P class="tj">Другая синтаксическая ошибка, которую трудно сразу правильно истолковать, генерируется при попытке скомпилировать следующий код:
<PRE>
/* В тексте данной программы имеется синтаксическая ошибка. */
#include &lt;stdio.h&gt;

void func1(void);

int main(void)
{
  func1();

  return 0;
}

void func1(void);
{
  printf("Это в func1.\n");
}
</PRE>
<P class="tj">Здесь ошибка состоит в наличии точки с запятой после определения функции <KBD>func1()</KBD>. Компилятор будет рассматривать это как выражение, находящееся за пределами какой бы то ни было функции, что является ошибкой. Однако различные компиляторы по-разному сообщают об этой ошибке. Некоторые компиляторы выводят в сообщении об ошибке такой текст: <PRE>bad declaration syntax (неправильный синтаксис объявления)</PRE><P class="t">,и в то же время указывают на первую открытую скобку после функции <KBD>func1()</KBD>. Поскольку вы привыкли в конце выражений ставить точку с запятой, подобную ошибку очень трудно заметить.
<H2>Ошибки, вызванные "потерей" данных</H2>
<P class="tj">Как известно, в С нумерация индексов любого массива начинаются с нуля. Тем не менее, даже опытные профессионалы в пылу творческого вдохновения, бывало, забывали это общеизвестное правило! Рассмотрим следующую программу, которая, как предполагается, должна инициализировать массив из ста целых чисел:
<PRE>
/* Эта программа работать не будет. */

int main(void)
{
  int x, num[100];

  for(x=1; x &lt;= 100; ++x) num[x] = x;

  return 0;
}
</PRE>
<P class="tj">Цикл <KBD>for</KBD> в этой программе выполнен неправильно по двум причинам. Во-первых, он не инициализирует <KBD>num[0]</KBD>, первый элемент массива <KBD>num</KBD>. Во-вторых, он пытается проинициализировать элемент массива с номером на единицу больше, чем у последнего элемента массива, поскольку <KBD>num[99]</KBD> как раз и является последним элементом массива, а параметр цикла достигает значения 100. Правильно было бы записать эту программу следующим образом:
<PRE>
/* Здесь все правильно. */

int main(void)
{
  int x, num[100];

  for(x=0; x &lt; 100; ++x) num[x] = x;

  return 0;
}
</PRE>
<P class="tj">Помните, в массиве из 100 элементов элементы пронумерованы числами от 0 до 99.
<H2>Ошибки из-за нарушения границ</H2>
<P class="tj">И в среде прогона программ, написанных на языке С, и во многих стандартных библиотечных функциях почти не имеется (а иногда они вообще отсутствуют) средств динамической проверки принадлежности к диапазону (т.е. средств контроля границ). Например, если в программе произойдет выход за границы массива, то такая ошибка может остаться незамеченной. Рассмотрим следующую программу, которая должна считывать строку символов из буфера клавиатуры и отображать ее на экране монитора:
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int var1;
  char s[10];
  int var2;

  var1 = 10;  var2 = 10;
  gets(s);
  printf("%s %d %d", s, var1, var2);

  return 0;
}
</PRE>
<P class="tj">В этом фрагменте нет очевидных ошибок кодирования. Тем не менее, вызов функции <KBD>gets()</KBD> с параметром <KBD>s</KBD> может косвенно привести к ошибке. В данной программе переменная <KBD>s</KBD> объявлена как массив символов (строка длиной в 10 знаков). Но что произойдет, если пользователь введет больше десяти знаков? Это приведет к выходу за границы массива <KBD>s</KBD>, и значение переменной <KBD>var1</KBD> или <KBD>var2</KBD>, а возможно, и их обеих будет перезаписано. Следовательно, <KBD>var1</KBD> и (или) <KBD>var2</KBD> не будут содержать правильных значений. Это вызвано тем, что для хранения локальных переменных все С-компиляторы применяют стек. Переменные <KBD>var1</KBD>, <KBD>var2</KBD>, а также <KBD>s</KBD> могут располагаться в памяти так, как показано на рис. 28.1. (Ваш компилятор С может поменять порядок следования переменных <KBD>var1</KBD>, <KBD>var2</KBD> и <KBD>s</KBD>.)
<P class="tj">Предположим, что порядок распределения ячеек памяти совпадает с изображенным на рис. 28.1. Тогда, если произойдет выход за границы массива <KBD>s</KBD>, то дополнительные (лишние) символы будут помещены в область, в которой должна находиться переменная <KBD>var2</KBD>. Это практически уничтожит информацию, ранее записанную там.
<P class="tj">Поэтому на экран будет выведено не число <KBD>10</KBD> в качестве значения обеих целых переменных, а в качестве значения переменной, поврежденной в результате выхода за границы массива <KBD>s</KBD>, будет отображено что-нибудь другое. А вы можете искать ошибку совсем в другом месте.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 28.1. Размещение в памяти переменных var1, var2 и s (исходя из предположения, что на целое число выделяется 2 байта)</I>
<TR><TD>


<PRE>
           Младшие  . 
           адреса   .
           памяти   .
      |-- +--------------------+ --|
var1 -|   +--------------------+   |- 2 байта
      |-- +--------------------+ --|
      |   +--------------------+   |
      |   +--------------------+   |
      |   +--------------------+   |
      |   +--------------------+   |
  s  -|   +--------------------+   |- 10 байтов
      |   +--------------------+   |
      |   +--------------------+   |
      |   +--------------------+   |
      |   +--------------------+   |
      |-- +--------------------+ --|
var2 -|   +--------------------+   |- 2 байта
      |-- +--------------------+ --|
           Старшие  . 
           адреса   .
           памяти   .
</PRE>
</TABLE>
<P class="tj">В рассмотренной программе потенциальная ошибка из-за выхода за границы может быть исключена за счет применения функции <KBD>fgets()</KBD> вместо <KBD>gets()</KBD>. Функция <KBD>fgets()</KBD> предоставляет возможность устанавливать максимальное количество считываемых символов. Единственная проблема состоит в том, что <KBD>fgets()</KBD> считывает и сохраняет еще и символ разделителя строк, поэтому в большинстве приложений его необходимо будет удалять.
<H2>Пропуск прототипов функций</H2>
<P class="tj">В современной среде программирования отсутствие даже одного прототипа функции является непростительным упущением, "отступничеством" от мудрых принципов и здравого смысла. Чтобы понять почему именно, рассмотрим следующую программу, которая выполняет умножение двух чисел с плавающей запятой:
<PRE>
/* Эта программа содержит ошибку. */
#include &lt;stdio.h&gt;

int main(void)
{
  float x, y;

  scanf("%f%f", &x, &y);
  printf("%f", mul(x, y));

  return 0;
}

double mul(float a, float b)
{
  return a*b;
}
</PRE>
<P class="tj">В данном случае, поскольку прототип функции <KBD>mul()</KBD> отсутствует, при компиляции функции <KBD>main()</KBD> предполагается, что в результате выполнения <KBD>mul()</KBD> будет возвращена целочисленная величина. Но в действительности <KBD>mul()</KBD> возвращает число с плавающей запятой. Допустим, что для целого числа выделяется 4 байта, а для чисел двойной точности (<KBD>double</KBD>) — 8 байтов. Это значит, что в действительности только четыре байта из восьми, необходимых для двойной точности, будут использованы в операторе <KBD>printf()</KBD> внутри функции <KBD>main()</KBD>. Это приведет к неправильному ответу, выводимому на экран дисплея.
<P class="tj">Чтобы исправить эту программу, достаточно создать прототип функции <KBD>mul()</KBD>. Корректный вариант программы будет выглядеть следующим образом:
<PRE>
/* Это правильная программа. */
#include &lt;stdio.h&gt;

double mul(float a, float b);

int main(void)
{
  float x, y;

  scanf("%f%f", &x, &y);
  printf("%f", mul(x, y));

  return 0;
}

double mul(float a, float b)
{
  return a*b;
}
</PRE>
<P class="tj">В данном случае прототип указывает, что при компиляции функции <KBD>main()</KBD> необходимо учитывать, что функция <KBD>mul()</KBD> возвращает значение с удвоенной точностью.
<H2>Ошибки при задании аргументов</H2>
<P class="tj">Тип любого формального параметра, должен соответствовать типу фактического параметра. Хотя благодаря прототипам функций компиляторы могут обнаруживать многие несоответствия типов аргументов (параметров), они не могут обнаружить все. Более того, когда функция имеет переменное количество параметров, компилятор не может обнаружить несоответствие их типов. Например, рассмотрим функцию <KBD>scanf()</KBD>, которая принимает большое количество разнообразных аргументов. Не забывайте, что <KBD>scanf()</KBD> ожидает принять адреса своих аргументов, а не их значения. И никакая сила не сделает за вас правильную подстановку. Например, следующая последовательность операторов
<PRE>
int x;
scanf("%d", x);
</PRE>
<P class="t">содержит ошибку, поскольку передается значение переменной <KBD>х</KBD>, а не ее адрес. Тем не менее, вызов этой функции <KBD>scanf()</KBD> будет скомпилирован без сообщения об ошибке, и лишь во время выполнения этого оператора выявится ошибка. Правильный вариант вызова функции <KBD>scanf()</KBD> приведен ниже:
<PRE>scanf("%d", &x);</PRE>
<H2>Переполнение стека</H2>
<P class="tj">Все компиляторы С используют стек для хранения локальных переменных, адресов возврата и передаваемых функциям параметров. Однако стек не безграничен, и, в конце концов, может быть исчерпан. Тогда попытка записи очередного элемента в него приведет к переполнению стека. Когда такое происходит, программа или полностью "умирает", или продолжает выполняться в ненормальном причудливом стиле. Самое неприятное в переполнении стека заключается в том, что оно в большинстве случаев происходит безо всякого предупреждения и оказывает на программу столь серьезное воздействие, что определить, что именно было сделано неправильно, иногда бывает невероятно трудно. Единственной приемлемой подсказкой может служить то, что в некоторых случаях переполнение стека вызвано выходом из-под контроля рекурсивных функций. Если в вашей программе используются рекурсивные функции и вы столкнулись с необъяснимыми сбоями в ее работе, проверьте условия завершения в рекурсивных функциях.
<P class="tj">И еще одно замечание. Некоторые компиляторы позволяют увеличить объем памяти, резервируемой под стек. Если ваша программа во всем остальном не имеет ошибок, но быстро исчерпывает стековое пространство (возможно из-за глубокой степени вложенности или рекурсивности функций), необходимо просто увеличить размер стека.
<H2>Применение отладчика</H2>
<P class="tj">Многие компиляторы поставляются вместе с отладчиком, который представляет собой программу, помогающую отладить разрабатываемый код. В общем случае отладчики позволяют шаг за шагом исполнять код разрабатываемой программы, устанавливать точки останова и контролировать содержимое различных переменных. Современные отладчики, например такие, как поставляемые в составе пакета Visual C++, являются действительно замечательными инструментальными средствами, которые могут оказать существенную помощь в обнаружении ошибок в разрабатываемом коде. Хороший отладчик стоит дополнительного времени и усилий, которые необходимы на его изучение, чтобы в дальнейшем эффективно его применять. Как бы то ни было, хороший программист <I>никогда</I> не откажется от работы с отладчиком для реализации надежного проекта и выполнения тонких работ.
<H2>Теория отладки в общих чертах</H2>
<P class="tj">Каждый разработчик имеет свой собственный подход в программировании и отладке. Тем не менее, длительный опыт показывает, что существуют технические приемы, которые значительно лучше, чем остальные. В отношении отладки считается, что наиболее эффективным методом в плане времени и стоимости является инкрементное (нарастающее) тестирование, даже если может показаться, что этот подход может замедлить на первых порах процесс разработки. <I>Инкрементное тестирование</I> является технологическим приемом, гарантирующим, что вы всегда будете иметь работоспособную программу. В чем же его суть? Уже на самых ранних стадиях процесса разработки функциональный блок. <I>Функциональный блок</I> — это просто фрагмент работающего кода. По мере добавления нового кода к этому блоку, он тестируется и отлаживается. Таким способом программист может обнаруживать ошибки без особого труда, поскольку, вероятнее всего, ошибки будут присутствовать в более новом коде (добавке) или возникать из-за плохого взаимодействия с функциональным блоком.
<P class="tj">Время отладки прямо пропорционально общему количеству строк кода, в котором программист ищет ошибки. Благодаря инкрементному тестированию количество строк кода, в котором необходимо искать ошибки, ограничено как правило, количеством вновь добавленных строк. Другими словами, ошибка, скорее всего, содержится в строках, которые не входят в состав функционального блока. Эта ситуация проиллюстрирована на рис. 28.2. Любому программисту хочется минимизировать объем отлаживаемого фрагмента программы. Метод инкрементного тестирования позволяет не тестировать те участки, где эта работа уже была проведена. Таким образом, можно уменьшить область, в которой вероятнее всего прячется ошибка.
<PRE>
Вероятнее всего, ошибка,если
 она есть, находиться здесь
             |
    +--------|---------+
    |        |         |
    | +------V-------+ |
    | |Функциональный| |
    | |     блок     | |
    | +--------------+ |
    |                  |
    | Добавленный код  |
    +------------------+

<I>Рис. 28.2. При регулярном использовании
          метода инкрементального тести
          рования ошибки, если они есть,
          вероятнее всего находятся в до
          бавленном коде</I>
</PRE>
<P class="tj">Крупные проекты часто можно разбить на несколько модулей, слабо взаимодействующих между собой. В таких случаях можно выделить несколько функциональных блоков, что позволит вести параллельную разработку проекта.
<P class="tj">Инкрементное тестирование — просто технологический прием, благодаря которому который всегда можно иметь работоспособный код. Поэтому всякий раз, когда появляется возможность выполнить кусочек разрабатываемой программы, вы должны запустить его на выполнение и тщательно протестировать его. По мере добавления к программе новых фрагментов продолжайте тестировать их, а также их интерфейс с уже проверенным функциональным кодом. Этот способ позволяет разрабатывать программу так, что большинство ошибок будет сконцентрировано в небольшой области кода. Конечно, вы никогда не должны упускать из виду то, что ошибка могла быть пропущена и в функциональном блоке, но все же данный метод тестирования уменьшает вероятность такого случая.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Вот еше несколько универсальных советов, как избавиться от проблем: "Всегда все тщательно проверяйте!", "Никогда не делайте ошибок!", "Всегда все кодируйте правильно!" и т.д. Когда я слышу подобные советы, я вспоминаю, как всем известная Алиса реагировала на подобные высказывания: "Но ведь я не могла!", на что Шалтай-Болтай ей отвечал: "Я и не говорю, что ты могла; я говорю, что ты должна была!" Честно говоря, позиция Алисы мне очень и очень близка, ведь недаром же известный философ Хинтикка доказал, что аморально требовать от человека то, чего он не может выполнить. Если теперь предположить (вопреки тому, что заказчики считают, что программисты <I>обязаны быть роботами</I>), что все программисты — люди, то мы можем придти к заключению, что не во всех программах всегда проверяется применение всех указателей. (С точки зрения заказчиков это, конечно, недопустимо.) А потому совет, даваемый автором, хотя и смахивает на один из универсальных, вполне заслуживает того, чтобы прислушаться к нему. Статистика же подтверждает, что это — самый лучший совет из всех, которые можно дать при отладке программ с указателями! Так что ничего не поделаешь — не ленитесь!
</BLOCKQUOTE> 
<HR><A href="../main.htm#28">Содержание</A> | <A href="2802.htm">&lt;&lt;&lt;</A> | <A href="../VI.htm">&gt;&gt;&gt;</A>
</BODY></HTML>