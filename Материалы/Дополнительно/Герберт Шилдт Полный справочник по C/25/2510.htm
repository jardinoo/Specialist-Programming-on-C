<HTML><HEAD>
<TITLE>Поиск и использованием частичного пути минимальной стоимости</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#25">Содержание</A> | <A href="2509.htm">&lt;&lt;&lt;</A> | <A href="2511.htm">&gt;&gt;&gt;</A><HR>
<H1>Поиск и использованием частичного пути минимальной стоимости</H1>
<P class="tj">Противоположностью наискорейшему подъему является <I>поиск с использованием частичного пути минимальной стоимости</I>. Эта стратегия похожа на то, как если бы вы стояли на середине улицы, ведущей на большую гору, а на ногах у вас были бы надеты роликовые коньки. Вы бы тогда явно почувствовали, что двигаться вниз намного легче, чем вверх! Другими словами, поиск с использованием частичного пути минимальной стоимости выбирает путь наименьшего сопротивления.
<P class="tj">Если поиск с использованием частичного пути минимальной стоимости применять к задаче выбора маршрутов полетов, то это означает, что авиарейсы всегда выбираются самые короткие — в надеже, что и найденный маршрут окажется самым коротким. В отличие от наискорейшего подъема, который стремится уменьшить количество авиарейсов, поиск с использованием частичного пути минимальной стоимости сводит к минимуму общую длину маршрута.
<P class="tj">Чтобы использовать поиск с использованием частичного пути минимальной стоимости, сначала, как обычно, нужно переписать функцию <KBD>find()</KBD>. Ниже показан ее новый код.
<PRE>
/* Найти самый близкий город и поместить его в "anywhere". */
int find(char *from, char *anywhere)
{
  int pos, dist;

  pos = 0;
  dist = 32000;  /* больше длины самого длинного авиарейса */
  find_pos = 0;

  while(find_pos &lt; f_pos) {
    if(!strcmp(flight[find_pos].from, from) &&
      !flight[find_pos].skip) {
        if(flight[find_pos].distance&lt;dist) {
        pos = find_pos;
        dist = flight[find_pos].distance;
      }
    }
    find_pos++;
  }
  if(pos) {
    strcpy(anywhere, flight[pos].to);
    flight[pos].skip = 1;
    return flight[pos].distance;
  }
  return 0;
}
</PRE>
<P class="tj">С помощью этой версии <KBD>find()</KBD> получается такое решение:
<PRE>
Нью-Йорк - Торонто - Лос-Анджелес
Расстояние в милях равно 2600.
</PRE>
<P class="tj">Как видите, в данном случае этот метод поиска позволяет найти самый короткий маршрут. Цепочка, ведущая к цели (т.е. маршрут, причем самый короткий), показана на рис. 25.8.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 25.8. Эта цепочка, ведущая к решению (т.е. путь, притом наикратчайший), была найдена методом поиска с использованием частичного пути минимальной стоимости</I>
<TR><TD align="center"><A href="../work/pic.pdf">Страница №9
</TABLE>
<H2>Анализ поиска с использованием частичного пути минимальной стоимости</H2>
<P class="tj">Поиск с использованием частичного пути минимальной стоимости и наискорейший подъем имеют одни и те же достоинства и недостатки, но только с точностью до наоборот: то, что является достоинством одного метода, является недостатком другого, и наоборот. При поиске с использованием частичного пути минимальной стоимости могут появиться ложные, обманчивые "овраги, долины, низины и пропасти", но в целом этот метод работает достаточно хорошо. Однако не надо думать, что если поиск с использованием частичного пути минимальной стоимости работал в нашей задаче лучше, чем наискорейший подъем, то он вообще работает лучше<SUP><A href="#11" name="1">[1]</A></SUP>. Т.е. можно сказать, что в среднем он работает лучше, чем поиск вслепую.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Действительно, зная условие задачи, в которой поиск с использованием частичного пути минимальной стоимости работает лучше, можно сформулировать двойственную задачу, в которой будет лучше работать наискорейший подъем.
</BLOCKQUOTE>
<HR><A href="../main.htm#25">Содержание</A> | <A href="2509.htm">&lt;&lt;&lt;</A> | <A href="2511.htm">&gt;&gt;&gt;</A>
</BODY></HTML>