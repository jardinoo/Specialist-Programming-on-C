<HTML><HEAD>
<TITLE>Оператор return</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#06">Содержание</A> | <A href="0604.htm">&lt;&lt;&lt;</A> | <A href="0606.htm">&gt;&gt;&gt;</A><HR>
<H1>Оператор return</H1>
<P class="tj">Механизм использования <KBD>return</KBD> описан в <A href="../03/03.htm">главе 3</A>. Как вы помните, там говорится, что этот оператор имеет два важных применения. Во-первых, он обеспечивает немедленный выход из функции, т.е. заставляет выполняющуюся программу передать управление коду, вызвавшему функцию. Во-вторых, этот оператор можно использовать для того, чтобы возвратить значение. В следующих разделах рассказывается, каким именно образом можно использовать оператор <KBD>return</KBD>.
<H2>Возврат из функции</H2>
<P class="tj">Функция может завершать выполнение и осуществлять возврат в вызывающую программу двумя способами. Первый способ используется тогда, когда после выполнения последнего оператора в функции встречается закрывающая фигурная скобка (}). (Конечно, это просто жаргон, ведь в настоящем объектном коде фигурной скобки нет!) Например, функция <KBD>pr_reverse()</KBD> в приведенной ниже программе просто выводит на экран в обратном порядке строку <KBD>Мне нравится С</KBD>, а затем возвращает управление вызывающей программе.
<PRE>
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

void pr_reverse(char *s);

int main(void)
{
  pr_reverse("Мне нравится C");

  return 0;
}

void pr_reverse(char *s)
{
  register int t;

  for(t=strlen(s)-1; t&gt;=0; t--) putchar(s[t]);
}
</PRE>
<P class="tj">Как только строка выведена на экран, функции <KBD>pr_reverse()</KBD> "делать больше нечего", поэтому она возвращает управление туда, откуда она была вызвана.
<P class="tj">Но на практике не так уж много функций используют именно такой способ завершения выполнения. В большинстве функций для завершения выполнения используется оператор <KBD>return</KBD> — или потому, что необходимо вернуть значение, или чтобы сделать код функции проще и эффективнее.
<P class="tj">В функции может быть несколько операторов <KBD>return</KBD>. Например, в следующей программе функция <KBD>find_substr()</KBD> возвращает начальную позицию подстроки в строке или же возвращает —1, если подстрока, наоборот, не найдена. В этой функции для упрощения кодирования используются два оператора <KBD>return</KBD>.
<PRE>
#include &lt;stdio.h&gt;

int find_substr(char *s1, char *s2);

int main(void)
{
  if(find_substr("C - это забавно", "is") != -1)
    printf("Подстрока найдена.");

  return 0;
}

/* Вернуть позицию первого, вхождения s2 в s1. */
int find_substr(char *s1, char *s2)
{
  register int t;
  char *p, *p2;

  for(t=0; s1[t]; t++) {
    p = &s1[t];
    p2 = s2;

    while(*p2 && *p2==*p) {
      p++;
      p2++;
    }
    if(!*p2) return t; /* 1-й оператор return */
  }
   return -1; /* 2-й оператор return */
}
</PRE>
<H2>Возврат значений</H2>
<P class="tj">Все функции, кроме тех, которые относятся к типу <KBD>void</KBD>, возвращают значение. Это значение указывается выражением в операторе <KBD>return</KBD>. Стандарт С89 допускает выполнение оператора <KBD>return</KBD> без указания выражения внутри функции, тип которой отличен от <KBD>void</KBD>. В этом случае все равно происходит возврат какого-нибудь произвольного значения. Но такое положение дел, мягко говоря, никуда не годится! Поэтому в Стандарте С99 (да и в C++) предусмотрено, что в функции, тип которой отличен от <KBD>void</KBD>, в операторе <KBD>return</KBD> необходимо <I>обязательно</I> указать возвращаемое значение. То есть, согласно С99, если для какой-либо функции указано, что она возвращает значение, то внутри этой функции у любого оператора <KBD>return</KBD> должно быть свое выражение. Однако если функция, тип которой отличен от <KBD>void</KBD>, выполняется до самого конца (то есть до закрывающей ее фигурной скобки), то возвращается произвольное (непредсказуемое с точки зрения разработчика программы!) значение. Хотя здесь нет синтаксической ошибки, это является серьезным упущением и таких ситуаций необходимо избегать.
<P class="tj">Если функция не объявлена как имеющая тип <KBD>void</KBD>, она может использоваться как операнд в выражении. Поэтому каждое из следующих выражений является правильным:
<PRE>
x = power(y);
if(max(x,y) &gt; 100) printf("больше");
for(ch=getchar(); isdigit(ch); ) ... ;
</PRE>
<P class="tj">Общепринятое правило гласит, что вызов функции не может находиться в левой части оператора присваивания. Выражение
<PRE>swap(x,y) = 100; /* неправильное выражение */</PRE>
<P class="t">является неправильным. Если компилятор С в какой-либо программе найдет такое выражение, то пометит его как ошибочное и программу компилировать не будет.
<P class="tj">В программе можно использовать функции трех видов. Первый вид — простые вычисления. Эти функции предназначены для выполнения операций над своими аргументами и возвращают полученное в результате этих операций значение. Вычислительная функция является функцией "в чистом виде". В качестве примеров можно назвать стандартные библиотечные функции <KBD>sqrt()</KBD> и <KBD>sin()</KBD>, которые вычисляют квадратный корень и синус своего аргумента соответственно.
<P class="tj">Второй вид включает в себя функции, которые обрабатывают информацию и возвращают значение, которое показывает, успешно ли была выполнена эта обработка. Примером является библиотечная функция <KBD>fclose()</KBD>, которая закрывает файл. Если операция закрытия была завершена успешно, функция возвращает 0, а в случае ошибки она возвращает <KBD>EOF</KBD>.
<P class="tj">У функций последнего, третьего вида нет явно возвращаемых значений. В сущности, такие функции являются чисто процедурными и никаких значений выдавать не должны. Примером является <KBD>exit()</KBD>, которая прекращает выполнение программы. Все функции, которые не возвращают значение, должны объявляться как возвращающие значение типа <KBD>void</KBD>. Объявляя функцию как возвращающую значение типа <KBD>void</KBD>, вы запрещаете ее применение в выражениях, предотвращая таким образом случайное использование этой функции не по назначению.
<P class="tj">Иногда функции, которые, казалось бы, фактически не выдают содержательный результат, все же возвращают какое-то значение. Например, <KBD>printf()</KBD> возвращает количество выведенных символов. Если бы нашлась такая программа, которая на самом деле проверяла бы это значение, то это было бы что-то необычное... Другими словами, хотя все функции, за исключением относящихся к типу <KBD>void</KBD>, возвращают значения, вовсе не нужно стремиться использовать эти значения во что бы то ни стало. Часто при обсуждении значений, возвращаемых функциями, возникает такой довольно распространенный вопрос: "Неужели не обязательно присваивать возвращенное значение какой-либо переменной? Не повиснет ли оно где-нибудь и не приведет ли это в дальнейшем к каким-либо неприятностям?" Отвечая на этот вопрос, повторим, что присваивание отнюдь не является обязательным, причем отсутствие его не станет причиной каких-либо неприятностей. Если возвращаемое значение не входит ни в один из операторов присваивания, то это значение будет просто отброшено. Отметим также, что такое отбрасывание значения встречается очень часто. Проанализируйте следующую программу, в которой используется функция <KBD>mul()</KBD>:
<PRE>
#include &lt;stdio.h&gt;

int mul(int a, int b);

int main(void)
{
  int x, y, z;

  x = 10;   y = 20;
  z = mul(x, y);           /* 1 */
  printf("%d", mul(x,y));  /* 2 */
  mul(x, y);               /* 3 */

  return 0;
}

int mul(int a, int b)
{
  return a*b;
}
</PRE>
<P class="tj">В строке 1 значение, возвращаемое функцией <KBD>mul()</KBD>, присваивается переменной <KBD>z</KBD>. В строке 2 возвращаемое значение не присваивается, но используется функцией <KBD>printf()</KBD>. И наконец, в строке 3 возвращаемое значение теряется, потому что не присваивается никакой из переменных и не используется как часть какого-либо выражения.
<H2>Возвращаемые указатели</H2>
<P class="tj">Хотя с функциями, которые возвращают указатели, обращаются так же, как и с любыми другими функциями, все же будет полезно познакомиться с некоторыми основными понятиями и рассмотреть соответствующий пример. Указатели не являются ни целыми, ни целыми без знака. Они являются адресами в памяти и относятся к особому типу данных. Такая особенность указателей определяется тем, что арифметика указателей (адресная арифметика) работает с учетом параметров базового типа. Например, если указателю на целое придать минимальное (ненулевое) приращение, то его текущее значение станет на четыре больше, чем предыдущее (при условии, что целые значения занимают 4 байта). Вообще говоря, каждый раз, когда значение указателя увеличивается (уменьшается) на минимальную величину, то он указывает на последующий (предыдущий) элемент, имеющий базовый тип указателя. Так как размеры разных типов данных могут быть разными, то компилятор должен знать тип данных, на которые может указывать указатель. Поэтому в объявлении функции, которая возвращает указатель, тип возвращаемого указателя должен декларироваться явно. Например, нельзя объявлять возвращаемый тип как <KBD>int *</KBD>, если возвращается указатель типа <KBD>char *</KBD>! Иногда (правда, крайне редко!) требуется, чтобы функция возвращала "универсальный" указатель, т.е. указатель, который может указывать на данные любого типа. Тогда тип результата функции следует определить как <KBD>void *</KBD>.
<P class="tj">Чтобы функция могла возвратить указатель, она должна быть объявлена как возвращающая указатель на нужный тип. Например, следующая функция возвращает указатель на первое вхождение символа, присвоенного переменной <KBD>с</KBD>, в строку <KBD>s</KBD>. Если этого символа в строке нет, то возвращается указатель на символ конца строки ('0').
<PRE>
/* Возвращает указатель на первое вхождение c в s. */
char *match(char c, char *s)
{
  while(c!=*s && *s) s++;
  return(s);
}
</PRE>
<P class="tj">Вот небольшая программа, в которой используется функция <KBD>match()</KBD>:
<PRE>
#include &lt;stdio.h&gt;

char *match(char c, char *s);  /* прототип */

int main(void)
{
  char s[80], *p, ch;

  gets(s);
  ch = getchar();
  p = match(ch, s);

  if(*p)  /* символ найден */
    printf("%s ", p);
  else
    printf("Символа нет.");

  return 0;
}
</PRE>
<P class="tj">Эта программа сначала считывает строку, а затем символ. Потом проводится поиск местонахождения символа в строке. При наличии символа в строке переменная <KBD>p</KBD> укажет на него, и программа выведет строку, начиная с найденного символа. Если символ в строке не найден, то <KBD>p</KBD> укажет на символ конца строки ( '0' ), причем <KBD>*p</KBD> будет представлять логическое значение ЛОЖЬ (false). В таком случае программа выведет сообщение <KBD>Символа нет</KBD>.
<H2>Функция типа void</H2>
<P class="tj">Одним из применений ключевого слова <KBD>void</KBD> является явное объявление функций, которые не возвращают значений. Мы уже знаем, что такие функции не могут применяться в выражениях, и указание ключевого слова <KBD>void</KBD> предотвращает их случайное использование не по назначению. Например, функция <KBD>print_vertical()</KBD> выводит в боковой части экрана свой строчный аргумент по вертикали сверху вниз.
<PRE>
void print_vertical(char *str)
{
  while(*str)
    printf("%c\n", *str++);
}
</PRE>
<P class="tj">Вот пример использования функции <KBD>print_vertical()</KBD>:
<PRE>
#include &lt;stdio.h&gt;

void print_vertical(char *str);  /* прототип */

int main(int argc, char *argv[])
{
  if(argc &gt; 1) print_vertical(argv[1]);

  return 0;
}

void print_vertical(char *str)
{
  while(*str)
    printf("%c\n", *str++);
}
</PRE>
<P class="tj">И еще одно замечание: в ранних версиях С ключевое слово <KBD>void</KBD> не определялось. Таким образом, в программах, написанных на этих версиях С, функции, которые не возвращали значений, просто имели по умолчанию тип <KBD>int</KBD> — и это несмотря на то, что они не возвращали никаких значений!
<HR><A href="../main.htm#06">Содержание</A> | <A href="0604.htm">&lt;&lt;&lt;</A> | <A href="0606.htm">&gt;&gt;&gt;</A>
</BODY></HTML>