<HTML><HEAD>
<TITLE>Аргументы функции</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#06">Содержание</A> | <A href="0602.htm">&lt;&lt;&lt;</A> | <A href="0604.htm">&gt;&gt;&gt;</A><HR>
<H1>Аргументы функции</H1>
<P class="tj">Если функция должна принимать аргументы, то в ее объявлении следует декларировать параметры, которые примут значения этих аргументов. Как видно из объявления следующей функции, объявления параметров стоят после имени функции.
<PRE>
/* Возвращает 1, если символ c входит в строку s;
   и 0 в противном случае. */
int is_in(char *s,  char c)
{
  while(*s)
    if(*s==c) return 1;
    else s++;
  return 0;
}
</PRE>
<P class="tj">Функция <KBD>is_in()</KBD> имеет два параметра: <KBD>s</KBD> и <KBD>d</KBD>. Если символ <KBD>c</KBD> входит в строку <KBD>s</KBD>, то эта функция возвращает 1, в противном случае она возвращает 0.
<P class="tj">Хотя параметры выполняют специальную задачу, — принимают значения аргументов, передаваемых функции, — они все равно ведут себя так, как и другие локальные переменные. Формальным параметрам функции, например, можно присваивать какие-либо значения или использовать эти параметры в каких-либо выражениях.
<H2>Вызовы по значению и по ссылке</H2>
<P class="tj">В языках программирования имеется два способа передачи значений подпрограмме. Первый из них — <I>вызов по значению</I>. При его применении в формальный параметр подпрограммы копируется значение аргумента. В таком случае изменения параметра на аргумент не влияют.
<P class="tj">Вторым способом передачи аргументов подпрограмме является <I>вызов по ссылке</I>. При его применении в параметр копируется адрес аргумента. Это значит, что, в отличие от вызова по значению, изменения значения параметра приводят к точно таким же изменениям значения аргумента.
<P class="tj">За небольшим количеством исключений, в языке С для передачи аргументов используется вызов по значению. Обычно это означает, что код, находящийся внутри функции, не может изменять значений аргументов, которые использовались при вызове функции.
<P class="tj">Проанализируйте следующую программу:
<PRE>
#include &lt;stdio.h&gt;

int sqr(int x);

int main(void)
{
  int t=10;

  printf("%d %d", sqr(t), t);

  return 0;
}

int sqr(int x)
{
  x = x*x;
  return(x);
}
</PRE>
<P class="tj">В этом примере в параметр <KBD>х</KBD> копируется 10 — значение аргумента для <KBD>sqr()</KBD>. Когда выполняется присваивание <KBD>х=х*х</KBD>, модифицируется только локальная переменная <KBD>х</KBD>. А значение переменной <KBD>t</KBD>, использованной в качестве аргумента при вызове <KBD>sqr()</KBD>, по-прежнему остается равным 10. Поэтому выведено будет следующее: <KBD>100.10</KBD>.
<P class="tj">Помните, что именно копия значения аргумента передается в функцию. А то, что происходит внутри функции, не влияет на значение переменной, которая была использована при вызове в качестве аргумента.
<H2>Вызов по ссылке</H2>
<P class="tj">Хотя в С для передачи параметров применяется вызов по значению, можно создать вызов и по ссылке, передавая не сам аргумент, а указатель на него<SUP><A href="#11" name="1">[1]</A></SUP>. Так как функции передается адрес аргумента, то ее внутренний код в состоянии изменить значение этого аргумента, находящегося, между прочим, за пределами самой функции.
<P class="tj">Указатель передается функции так, как и любой другой аргумент. Конечно, в таком случае параметр следует декларировать как один из типов указателей. Это можно увидеть на примере функции <KBD>swap()</KBD>, которая меняет местами значения двух целых переменных, на которые указывают аргументы этой функции:
<PRE>
void swap(int *x, int *y)
{
  int temp;

  temp = *x;  /* сохранить значение по адресу x */
  *x = *y;    /* поместить y в x */
  *y = temp;  /* поместить x в y */
}
</PRE>
<P class="tj">Функция <KBD>swap()</KBD> может выполнять обмен значениями двух переменных, на которые указывают <KBD>х</KBD> и <KBD>y</KBD>, потому что передаются их адреса, а не значения. Внутри функции, используя стандартные операции с указателями, можно получить доступ к содержимому переменных и провести обмен их значений<SUP><A href="#22" name="2">[2]</A></SUP>.
<P class="tj">Помните, что <KBD>swap()</KBD> (или любую другую функцию, в которой используются параметры в виде указателей) необходимо вызывать вместе с адресами аргументов<SUP><A href="#33" name="3">[3]</A></SUP>. Следующая программа показывает, как надо правильно вызывать <KBD>swap()</KBD>:
<PRE>
#include &lt;stdio.h&gt;
void swap(int *x, int *y);

int main(void)
{
  int i, j;

  i = 10;
  j = 20;

  printf("i и j перед обменом значениями: %d %d\n", i, j);

  swap(&i, &j); /* передать адреса переменных i и j */

  printf("i и j после обмена значениями: %d %d\n", i, j);

  return 0;
}

void swap(int *x, int *y)
{
  int temp;

  temp = *x;  /* сохранить значение по адресу x */
  *x = *y;    /* поместить y в x */
  *y = temp;  /* поместить x в y */
}
</PRE>
<P class="tj">И вот что вывела эта программа:
<PRE>
i и j перед обменом значениями: 10 20
i и j после обмена значениями: 20 10
</PRE>
<P class="tj">В программе переменной <KBD>i</KBD> присваивается значение 10, а переменной <KBD>j</KBD> — значение 20. Затем вызывается функция <KBD>swap()</KBD> с адресами этих переменных. (Для получения адреса каждой из переменных используется унарный оператор <KBD>&</KBD>.) Поэтому в <KBD>swap()</KBD> передаются адреса переменных <KBD>i</KBD> и <KBD>j</KBD>, а не их значения.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Язык C++ при помощи параметров-ссылок дает возможность полностью автоматизировать вызов по ссылке. А в языке С параметры-ссылки не поддерживается
</TABLE>
<H2>Вызов функций с помощью массивов</H2>
<P class="tj">Подробно о массивах рассказывалось в <A href="../04/04.htm">главе 4</A>. В настоящем же разделе рассказывается о передаче массивов функциям в качестве аргументов. Этот вопрос рассматривается потому, что эта операция является исключением по отношению к обычной передаче параметров, выполняемой путем вызова по значению<SUP><A href="#44" name="4">[4]</A></SUP>.
<P class="tj">Когда в качестве аргумента функции используется массив, то функции передается его адрес. В этом и состоит исключение по отношению к правилу, которое гласит, что при передаче параметров используется вызов по значению. В случае передачи массива функции ее внутренний код работает с реальным содержимым этого массива и вполне может изменить это содержимое. Проанализируйте, например, функцию <KBD>print_upper()</KBD>, которая печатает свой строковый аргумент на верхнем регистре:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void print_upper(char *string);

int main(void)
{
  char s[80];

  printf("Введите строку символов: ");
  gets(s);
  print_upper(s); 
  printf("\ns теперь на верхнем регистре: %s", s);
  return 0;
}

/* Печатать строку на верхнем регистре. */
void print_upper(char *string)
{
  register int t;

  for(t=0; string[t]; ++t)  {
    string[t] = toupper(string[t]);
    putchar(string[t]);
  }
}
</PRE>
<P class="tj">Вот что будет выведено в случае фразы "This is a test." (это тест):
<PRE>
Введите строку символов: This is a test.
THIS IS A TEST.
s теперь в верхнем регистре: THIS IS A TEST.
</PRE>
<P class="tj">Правда, эта программа не работает с символами кириллицы.
<P class="tj">После вызова <KBD>print_upper()</KBD> содержимое массива <KBD>s</KBD> в <KBD>main()</KBD> переводится в символы верхнего регистра. Если вам это не нужно, программу можно написать следующим образом:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void print_upper(char *string);

int main(void)
{
  char s[80];

  printf("Введите строку символов: ");
  gets(s);
  print_upper(s);
  printf("\ns не изменялась: %s", s);

  return 0;
}

void print_upper(char *string)
{
  register int t;

  for(t=0; string[t]; ++t)
    putchar(toupper(string[t]));
}
</PRE>
<P class="tj">Вот какой на этот раз получится фраза "This is a test.":
<PRE>
Введите строку символов: This is a test.
THIS IS A TEST.
s не изменилась: This is a test.
</PRE>
<P class="tj">На этот раз содержимое массива не изменилось, потому что внутри <KBD>print_upper()</KBD> не изменялись его значения.
<P class="tj">Классическим примером передачи массивов в функции является стандартная библиотечная функция <KBD>gets()</KBD>. Хотя <KBD>gets()</KBD>, которая находится в вашей стандартной библиотеке, и более сложная, чем предлагаемая вам версия <KBD>xgets()</KBD>, но с помощью функции <KBD>xgets()</KBD> вы сможете получить представление о том, как работает <KBD>gets()</KBD>.
<PRE>
/* Упрощенная версия стандартной библиотечной функции gets(). */
char *xgets(char *s)
{
  char ch, *p;
  int t;

  p = s;  /* xgets() возвращает указатель s */

  for(t=0; t&lt;80; ++t){
    ch = getchar();

    switch(ch) {
      case '\n':
        s[t] = '\0'; /* завершает строку */
        return p;
      case '\b':
        if(t&gt;0) t--;
        break;
      default:
        s[t] = ch;
    }
  }
  s[79] = '\0';
  return p;
}
</PRE>
<P class="tj">Функцию <KBD>xgets()</KBD> следует вызывать с указателем <KBD>char *</KBD>. Им, конечно же, может быть имя символьного массива, которое по определению является указателем <KBD>char *</KBD>. В самом начале программы <KBD>xgets()</KBD> выполняется цикл <KBD>for</KBD> от 0 до 80. Это не даст вводить с клавиатуры строки, содержащие более 80 символов. При попытке ввода большего количества символов происходит возврат из функции. (В настоящей функции <KBD>gets()</KBD> такого ограничения нет.) Так как в языке С нет встроенной проверки границ, программист должен сам позаботиться, чтобы в любом массиве, используемом при вызове <KBD>xgets()</KBD>, помещалось не менее 80 символов. Когда символы вводятся с клавиатуры, они сразу записываются в строку. Если пользователь нажимает клавишу &lt;Backspase&gt;, то счетчик <KBD>t</KBD> уменьшается на 1, а из массива удаляется последний символ, введенный перед нажатием этой клавиши. Когда пользователь нажмет &lt;ENTER&gt;, в конец строки запишется нуль, т.е. признак конца строки. Так как массив, использованный для вызова <KBD>xgets()</KBD>, модифицируется, то при возврате из функции в нем будут находиться введенные пользователем символы.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Конечно, при передаче указателя будет применен вызов по значению, и сам указатель внутри функции вы изменить не сможете. Однако для того объекта, на который указывает этот указатель, все произойдет так, будто этот объект был передан по ссылке. В некоторых языках программирования (например, в Алголе-60) имелись специальные средства, позволяющие уточнить, как следует передавать аргументы: по ссылке или по значению. Благодаря наличию указателей в С механизм передачи параметров удалось унифицировать. Параметры, не являющиеся массивами, в С всегда вызываются только по значению, но все, что в других языках вы можете сделать с объектом, получив ссылку на него (т.е. его адрес), вы можете сделать, получив значение указателя на этот объект (т.е. опять же, его адрес). Так что в языке С благодаря свойственной ему унификации передачи параметров никаких проблем не возникает. А вот в других языках трудности, связанные с отсутствием эффективных средств работы с указателями, встречаются довольно часто.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>Конечно, задача, решаемая этой программой, кажется тривиальной. Ну разве представляет трудность написать на каком-либо процедурном языке, например, на Алголе-60, процедуру, которая обменивает значения своих параметров. Ведь так просто написать: <B>procedure</B> swap(x, y); <B>integer</B> х, y; <B>begin integer</B> t; t:= x; x:=y; y:=t <B>end</B>. Но эта процедура работает неправильно, хотя вызов значений здесь происходит по ссылке! Причем сразу найти тестовый пример, демонстрирующий ошибочность этой процедуры, удается далеко не всем. Ведь в случае вызова swap(i, j) все работает правильно! А что будет в случае вызова swap(i, a[i])? Да и можно ли на Алголе-60 вообще написать требуемую процедуру? Если вы склоняетесь к отрицательному ответу, то это показывает, насколько все-таки необходимы указатели в развитых языках программирования. Если все же вы знаете правильный ответ, то обратите внимание на то, что требуемая процедура, хотя и не длинная, но все же содержит своего рода программистский фокус!
<P class="tj"><SUP><A href="#3" name="33">[3]</A></SUP>Конечно, это просто программистский жаргон. На самом деле, конечно, аргументами являются именно адреса переменных, а не сами переменные. Просто в этом случае для краткости изложения программисты "делают вид", что вроде бы и в самом деле происходит передача значений по ссылке.
<P class="tj"><SUP><A href="#4" name="44">[4]</A></SUP>Ведь при вызове по значению пришлось бы копировать весь массив!
</BLOCKQUOTE> 
<HR><A href="../main.htm#06">Содержание</A> | <A href="0602.htm">&lt;&lt;&lt;</A> | <A href="0604.htm">&gt;&gt;&gt;</A>
</BODY></HTML>