<HTML><HEAD>
<TITLE>Указатели на функции</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#05">Содержание</A> | <A href="0507.htm">&lt;&lt;&lt;</A> | <A href="0509.htm">&gt;&gt;&gt;</A><HR>
<H1>Указатели на функции</H1>
<P class="tj"><I>Указатели на функции</I><SUP><A href="#11" name="1">[1]</A></SUP> — очень мощное средство языка С. Хотя нельзя не отметить, что это весьма трудный для понимания термин. Функция располагается в памяти по определенному адресу, который можно присвоить указателю в качестве его значения. Адресом функции является ее точка входа. Именно этот адрес используется при вызове функции. Так как указатель хранит адрес функции, то она может быть вызвана с помощью этого указателя. Он позволяет также передавать ее другим функциям в качестве аргумента.
<P class="tj">В программе на С адресом функции служит ее имя без скобок и аргументов (это похоже на адрес массива, который равен имени массива без индексов). Рассмотрим следующую программу, в которой сравниваются две строки, введенные пользователем. Обратите внимание на объявление функции <KBD>check()</KBD> и указатель <KBD>p</KBD> внутри <KBD>main()</KBD>. Указатель <KBD>p</KBD>, как вы увидите, является указателем на функцию.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void check(char *a, char *b,
           int (*cmp)(const char *, const char *));

int main(void)
{
  char s1[80], s2[80];
  int (*p)(const char *, const char *);
               /* указатель на функцию */

  p = strcmp;
  /* присваивает адрес функции strcmp указателю p */

  printf("Введите две строки.\n");
  gets(s1);
  gets(s2);

  check(s1, s2, p); /* Передает адрес функции strcmp
                       посредством указателя p */

  return 0;
}

void check(char *a, char *b,
           int (*cmp)(const char *, const char *))
{
  printf("Проверка на совпадение.\n");
  if(!(*cmp)(a, b)) printf("Равны");
  else printf("Не равны");
}
</PRE>
<P class="tj">Проанализируем эту программу подробно. В первую очередь рассмотрим объявление указателя <KBD>p</KBD> в <KBD>main()</KBD>:
<PRE>int (*p)(const char *, const char *);</PRE>
<P class="tj">Это объявление сообщает компилятору, что <KBD>p</KBD> — это указатель на функцию, имеющую два параметра типа <KBD>const char *</KBD> и возвращающую значение типа <KBD>int</KBD>. Скобки вокруг <KBD>p</KBD> необходимы для правильной интерпретации объявления компилятором. Подобная форма объявления используется также для указателей на любые другие функции, нужно лишь внести изменения в зависимости от возвращаемого типа и параметров функции.
<P class="tj">Теперь рассмотрим функцию <KBD>check()</KBD>. В ней объявлены три параметра: два указателя на символьный тип (<KBD>a</KBD> и <KBD>b</KBD>) и указатель на функцию <KBD>cmp</KBD>. Обратите внимание на то, что указатель функции <KBD>cmp</KBD> объявлен в том же формате, что и <KBD>p</KBD>. Поэтому в <KBD>cmp</KBD> можно хранить значение указателя на функцию, имеющую два параметра типа <KBD>const char *</KBD> и возвращающую значение <KBD>int</KBD>. Как и в объявлении <KBD>p</KBD>, круглые скобки вокруг <KBD>*cmp</KBD> необходимы для правильной интерпретации этого объявления компилятором.
<P class="tj">Вначале в программе указателю <KBD>p</KBD> присваивается адрес стандартной библиотечной функции <KBD>strcmp()</KBD>, которая сравнивает строки. Потом программа просит пользователя ввести две строки и передает указатели на них функции <KBD>check()</KBD>, которая их сравнивает. Внутри <KBD>check()</KBD> выражение
<PRE>(*cmp)(a, b)</PRE>
<P class="t">вызывает функцию <KBD>strcmp()</KBD>, на которую указывает <KBD>cmp</KBD>, с аргументами <KBD>a</KBD> и <KBD>b</KBD>. Скобки вокруг <KBD>*cmp</KBD> обязательны. Существует и другой, более простой, способ вызова функции с помощью указателя:
<PRE>cmp(a, b);</PRE>
<P class="tj">Однако первый способ используется чаще (и мы рекомендуем использовать именно его), потому что при втором способе вызова указатель <KBD>cmp</KBD> очень похож на имя функции, что может сбить с толку читающего программу. В то же время у первого способа записи есть свои преимущества, например, хорошо видно, что функция вызывается с помощью указателя на функцию, а не имени функции. Следует отметить, что первоначально в С был определен именно первый способ вызова.
<P class="tj">Вызов функции <KBD>check()</KBD> можно записать, используя непосредственно имя <KBD>strcmp()</KBD>:
<PRE>check(s1, s2, strcmp);</PRE>
<P class="tj">В этом случае вводить в программу дополнительный указатель <KBD>p</KBD> нет необходимости.
<P class="tj">У читателя может возникнуть вопрос: какая польза от вызова функции с помощью указателя на функцию? Ведь в данном случае никаких преимуществ не достигнуто, этим мы только усложнили программу. Тем не менее, во многих случаях оказывается более выгодным передать имя функции как параметр или даже создать массив функций. Например, в программе интерпретатора синтаксический анализатор (программа, анализирующая выражения) часто вызывает различные вспомогательные функции, такие как вычисление математических функций, процедуры ввода-вывода и т.п. В таких случаях чаще всего создают список функций и вызывают их с помощью индексов.
<P class="tj">Альтернативный подход — использование оператора <KBD>switch</KBD> с длинным списком меток <KBD>case</KBD> — делает программу более громоздкой и подверженной ошибкам.
<P class="tj">В следующем примере рассматривается расширенная версия предыдущей программы. В этой версии функция <KBD>check()</KBD> устроена так, что может выполнять разные операции над строками <KBD>s1</KBD> и <KBD>s2</KBD> (например, сравнивать каждый символ с соответствующим символом другой строки или сравнивать числа, записанные в строках) в зависимости от того, какая функция указана в списке аргументов. Например, строки "0123" и "123" отличаются, однако представляют одно и то же числовое значение.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void check(char *a, char *b,
           int (*cmp)(const char *, const char *));
int compvalues(const char *a, const char *b);

int main(void)
{
  char s1[80], s2[80];

  printf("Введите два значения или две строки.\n");
  gets(s1);
  gets(s2);

  if(isdigit(*s1)) {
    printf("Проверка значений на равенство.\n");
    check(s1, s2, compvalues);
  }
  else {
    printf("Проверка строк на равенство.\n");
    check(s1, s2, strcmp);
  }

  return 0;
}

void check(char *a, char *b,
           int (*cmp)(const char *, const char *))
{
  if(!(*cmp)(a, b)) printf("Равны");
  else printf("Не равны");
}

int compvalues(const char *a, const char *b)
{
  if(atoi(a)==atoi(b)) return 0;
  else return 1;
}
</PRE>
<P class="tj">Если в этом примере ввести первый символ первой строки как цифру, то <KBD>check()</KBD> использует <KBD>compvalues()</KBD>, в противном случае — <KBD>strcmp()</KBD>. Функция <KBD>check()</KBD> вызывает ту функцию, имя которой указано в списке аргументов при вызове <KBD>check()</KBD>, поэтому она в разных ситуациях может вызывать разные функции. Ниже приведены результаты работы этой программы в двух случаях:
<PRE>
Введите два значения или две строки.
тест
тест
Проверка строк на равенство.
Равны

Введите два значения или две строки.
0123
123
Проверка значений на равенство.
Равны
</PRE>
<P class="tj">Сравнение строк 0123<SUP><A href="#22" name="2">[2]</A></SUP> и 123 показывает равенство их значений.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Иногда их называют просто <I>указателями функций</I>. Но следует помнить, что в языках программирования под этим термином подразумевается также средство обращения к подпрограмме-функции или встроенной функции, имеющее конструкцию &lt;<I>имя-функции</I>&gt; (&lt;<I>список-аргументов</I>&gt;).
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>Обратите внимание, что в языке С нулем начинаются восьмеричные константы. Если бы эта запись была в выражении, то 0123 не было бы равно 123. Однако здесь функция <KBD>atoi()</KBD> обрабатывает это число как десятичное.
</BLOCKQUOTE>
<HR><A href="../main.htm#05">Содержание</A> | <A href="0507.htm">&lt;&lt;&lt;</A> | <A href="0509.htm">&gt;&gt;&gt;</A>
</BODY></HTML>