<HTML><HEAD>
<TITLE>Инициализация указателей</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#05">Содержание</A> | <A href="0506.htm">&lt;&lt;&lt;</A> | <A href="0508.htm">&gt;&gt;&gt;</A><HR>
<H1>Инициализация указателей</H1>
<P class="tj">После объявления нестатического локального указателя до первого присвоения он содержит неопределенное значение. (Глобальные и статические локальные указатели при объявлении неявно инициализируются нулем.) Если попытаться использовать указатель перед присвоением ему нужного значения, то скорее всего он мгновенно разрушит программу или всю операционную систему. Это очень досадная ошибка.
<P class="tj">При работе с указателями большинство программистов придерживаются следующего важного соглашения: указатель, не ссылающийся в текущий момент времени должным образом на конкретный объект, должен содержать нулевое значение. Нуль используется потому, что С гарантирует отсутствие чего-либо по нулевому адресу. Следовательно, если указатель равен нулю, то это значит, во-первых, что он ни на что не ссылается, а во-вторых — что его сейчас нельзя использовать.
<P class="tj">Указателю можно задать нулевое значение, присвоив ему 0. Например, следующий оператор инициализирует <KBD>р</KBD> нулем:
<PRE>char *p = 0;</PRE>
<P class="tj">Дополнительно к этому во многих заголовочных файлах языка С, например, в <KBD>&lt;stdio.h&gt;</KBD> определен макрос <KBD>NULL</KBD>, являющийся нулевой указательной константой. Поэтому в программах на С часто можно увидеть следующее присваивание:
<PRE>p = NULL;</PRE>
<P class="tj">Однако равенство указателя нулю не делает его абсолютно "безопасным". Использование нуля в качестве признака неподготовленности указателя — это только соглашение программистов, но не правило языка С. В следующем примере компиляция пройдет без ошибки, а результат, тем не менее, будет неправильным:
<PRE>
int *p = 0;
*p = 10; /* ошибка! */
</PRE>
<P class="tj">В этом случае присваивание посредством <KBD>p</KBD> будет присваиванием по нулевому адресу, что обычно вызывает разрушение программы.
<P class="tj">Во многих процедурах для повышения эффективности программы можно использовать то, что нулевой указатель заведомо считается неподготовленным для использования. Например, можно использовать нулевой указатель как признак конца массива указателей (по аналогии с нулевым терминатором строки). Процедура, использующая массив указателей, таким образом узнает о конце массива. Такой подход иллюстрируется в таком примере. Просматривая список имен, функция <KBD>search()</KBD> определяет, есть ли в этом списке заданное имя.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int search(char *p[], char *name);

char *names[] = {
  "Сергей",
  "Юрий",
  "Ольга",
  "Игорь",
  NULL}; /* Нулевая константа кончает список */

int main(void)
{
  if(search(names, "Ольга") != -1)
    printf("Ольга есть в списке.\n");

  if(search(names, "Павел") == -1)
    printf("Павел в списке не найден.\n");

  return 0;
}

/* Просмотр имен. */
int search(char *p[], char *name)
{
  register int t;

  for(t=0; p[t]; ++t)
    if(!strcmp(p[t], name)) return t;

    return -1; /* имя не найдено */
}
</PRE>
<P class="tj">В функцию <KBD>search()</KBD> передаются два параметра. Первый из них, <KBD>p</KBD> — массив указателей на строки, представляющие собой имена из списка. Второй параметр name является указателем на строку с заданным именем. Функция <KBD>search()</KBD> просматривает массив указателей, пока не найдет строку, совпадающую со строкой, на которую указывает <KBD>name</KBD>. Итерации цикла <KBD>for</KBD> повторяются до тех пор, пока не произойдет совпадение имен, или не встретится нулевой указатель. Конец массива отмечен нулевым указателем, поэтому при достижении конца массива управляющее условие цикла примет значение ЛОЖЬ. Иными словами, <KBD>p[t]</KBD> имеет значение ЛОЖЬ, когда <KBD>p[t]</KBD> является нулевым указателем. В рассмотренном примере именно это и происходит, когда идет поиск имени "Павел", которого в списке нет.
<P class="tj">В программах на С указатель типа <KBD>char *</KBD> часто инициализируют строковой константой (как в предыдущем примере). Рассмотрим следующий пример:
<PRE>char *p = "тестовая строка";</PRE>
<P class="tj">Переменная <KBD>р</KBD> является указателем, а не массивом. Поэтому возникает логичный вопрос: где хранится строковая константа "тестовая строка"? Так как <KBD>p</KBD> не является массивом, она не может храниться в <KBD>p</KBD>, тем не менее, она где-то записана. Чтобы ответить на этот вопрос, нужно знать, что происходит, когда компилятор встречает строковую константу. Компилятор создает так называемую <I>таблицу строк</I>, в ней он сохраняет строковые константы, которые встречаются ему по ходу чтения текста программы. Следовательно, когда встречается объявление с инициализацией, компилятор сохраняет строку "тестовая строка" в таблице строк, а в указатель <KBD>p</KBD> записывает ее адрес. Дальше в программе указатель <KBD>p</KBD> может быть использован как любая другая строка. Это иллюстрируется следующим примером:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *p = "тестовая строка";

int main(void)
{
  register int t;

  /* печать строки слева направо и справа налево */
  printf(p);
  for(t=strlen(p)-1; t&gt;-1; t--) printf("%c", p[t]);

  return 0;
}
</PRE>
<HR><A href="../main.htm#05">Содержание</A> | <A href="0506.htm">&lt;&lt;&lt;</A> | <A href="0508.htm">&gt;&gt;&gt;</A>
</BODY></HTML>