<HTML><HEAD>
<TITLE>Функции динамического распределения</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#05">Содержание</A> | <A href="0508.htm">&lt;&lt;&lt;</A> | <A href="0510.htm">&gt;&gt;&gt;</A><HR>
<H1>Функции динамического распределения</H1>
<P class="tj">Указатели используются для динамического выделения памяти компьютера для хранения данных. <I>Динамическое распределение</I> означает, что программа выделяет память для данных во время своего выполнения. Память для глобальных переменных выделяется во время компиляции, а для нестатических локальных переменных — в стеке. Во время выполнения программы ни глобальным, ни локальным переменным не может быть выделена дополнительная память. Но довольно часто такая необходимость возникает, причем объем требуемой памяти заранее неизвестен. Такое случается, например, при использовании динамических структур данных, таких как связные списки или двоичные деревья. Такие структуры данных при выполнении программы расширяются или сокращаются по мере необходимости. Для реализации таких структур в программе нужны средства, способные по мере необходимости выделять и освобождать для них память.
<P class="tj">Память, выделяемая в С функциями динамического распределения данных, находится в т.н. <I>динамически распределяемой области памяти (heap)</I><SUP><A href="#11" name="1">[1]</A></SUP>. Динамически распределяемая область памяти — это свободная область памяти, не используемая программой, операционной системой или другими программами. Размер динамически распределяемой области памяти заранее неизвестен, но как правило в ней достаточно памяти для размещения данных программы. Большинство компиляторов поддерживают библиотечные функции, позволяющие получить текущий размер динамически распределяемой области памяти, однако эти функции не определены в Стандарте С. Хотя размер динамически распределяемой области памяти очень большой, все же она конечна и может быть исчерпана.
<P class="tj">Основу системы динамического распределения в С составляют функции <KBD>malloc()</KBD> и <KBD>free()</KBD>. Эти функции работают совместно. Функция <KBD>malloc()</KBD> выделяет память, а <KBD>free()</KBD> — освобождает ее. Это значит, что при каждом запросе функция <KBD>malloc()</KBD> выделяет требуемый участок свободной памяти, a <KBD>free()</KBD> освобождает его, то есть возвращает системе. В программу, использующую эти функции, должен быть включен заголовочный файл <KBD>&lt;stdlib.h&gt;</KBD>.
<P class="tj">Прототип функции <KBD>malloc()</KBD> следующий:
<PRE>void *malloc(size_t <I>количество_байтов</I>);</PRE>
<P class="tj">Здесь <I>количество_байтов</I> — размер памяти, необходимой для размещения данных. (Тип <KBD>size_t</KBD> определен в <KBD>&lt;stdlib.h&gt;</KBD> как некоторый целый без знака.) Функция <KBD>malloc()</KBD> возвращает указатель типа <KBD>void *</KBD>, поэтому его можно присвоить указателю любого типа. При успешном выполнении <KBD>malloc()</KBD> возвращает указатель на первый байт непрерывного участка памяти, выделенного в динамически распределяемой области памяти. Если в динамически распределяемой области памяти недостаточно свободной памяти для выполнения запроса, то память не выделяется и <KBD>malloc()</KBD> возвращает нуль.
<P class="tj">При выполнении следующего фрагмента программы выделяется непрерывный участок памяти объемом 1000 байтов:
<PRE>
char *p;
p = malloc(1000); /* выделение 1000 байтов */
</PRE>
<P class="tj">После присвоения указатель <KBD>p</KBD> ссылается на первый из 1000 байтов выделенного участка памяти.
<P class="tj">В следующем примере выделяется память для 50 целых. Для повышения мобильности (переносимости программы с одной машины на другую) используется оператор <KBD>sizeof</KBD>.
<PRE>
int *p;
p = malloc(50*sizeof(int));
</PRE>
<P class="tj">Поскольку динамически распределяемая область памяти не бесконечна, при каждом размещении данных необходимо проверять, состоялось ли оно. Если <KBD>malloc()</KBD> не смогла по какой-либо причине выделить требуемый участок памяти, то она возвращает нуль. В следующем примере показано, как выполняется проверка успешности размещения:
<PRE>
p = malloc(100);
if(!p) {
  printf("Нехватка памяти.\n");
  exit(1);
}
</PRE>
<P class="tj">Конечно, вместо выхода из программы <KBD>exit()</KBD> можно поставить какой-либо обработчик ошибки. Обязательным здесь можно назвать лишь требование не использовать указатель <KBD>р</KBD>, если он равен нулю.
<P class="tj">Функция <KBD>free()</KBD> противоположна функции <KBD>malloc()</KBD> в том смысле, что она возвращает системе участок памяти, выделенный ранее с помощью функции <KBD>malloc()</KBD>. Иными словами, она освобождает участок памяти, который может быть вновь использован функцией <KBD>malloc()</KBD>. Функция <KBD>free()</KBD> имеет следующий прототип:
<PRE>void free(void *<I>p</I>)</PRE>
<P class="tj">Здесь <I>р</I> — указатель на участок памяти, выделенный перед этим функцией <KBD>malloc()</KBD>. Функцию <KBD>free()</KBD> ни в коем случае нельзя вызывать с неправильным аргументом, это мгновенно разрушит всю систему распределения памяти.
<P class="tj">Подсистема динамического распределения в С используется совместно с указателями для создания различных программных конструкций, таких как связные списки и двоичные деревья. Несколько примеров использования таких конструкций приведены в <A href="../IV.htm">части IV</A>. Здесь рассматривается другое важное применение динамического размещения: размещение массивов.
<H2>Динамическое выделение памяти для массивов</H2>
<P class="tj">Довольно часто возникает необходимость выделить память динамически, используя <KBD>malloc()</KBD>, но работать с этой памятью удобнее так, будто это массив, который можно индексировать. В этом случае нужно создать <I>динамический массив</I>. Сделать это несложно, потому что каждый указатель можно индексировать как массив. В следующем примере одномерный динамический массив содержит строку:
<PRE>
/* Динамическое распределение строки, строка вводится
   пользователем, а затем распечатывается справа налево. */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
  char *s;
  register int t;

  s = malloc(80);

  if(!s) {
    printf("Требуемая память не выделена.\n");
    exit(1);
  }

  gets(s);
  for(t=strlen(s)-1; t&gt;=0; t--) putchar(s[t]);
  free(s);

  return 0;
}
</PRE>
<P class="tj">Перед первым использованием <KBD>s</KBD> программа проверяет, успешно ли прошло выделение памяти. Эта проверка необходима для предотвращения случайного использования нулевого указателя. Обратите внимание на то, что указатель <KBD>s</KBD> используется в функции <KBD>gets()</KBD>, а также при выводе на экран (но на этот раз уже как обыкновенный массив).
<P class="tj">Можно также динамически выделить память для многомерного массива. Для этого нужно объявить указатель, определяющий все, кроме самого левого измерения массива. В следующем примере<SUP><A href="#22" name="2">[2]</A></SUP> двухмерный динамический массив содержит таблицу чисел от 1 до 10 в степенях 1, 2, 3 и 4.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int pwr(int a, int b);

int main(void)
{
  /* Объявление указателя на массив из 10 строк
     в которых хранятсяцелые числа (int). */
  int (*p)[10]; 

  register int i, j;

  /* выделение памяти для массива 4 x 10 */
  p = malloc(40*sizeof(int));

  if(!p) {
    printf("Требуемая память не выделена.\n");
    exit(1);
  }

  for(j=1; j&lt;11; j++)
    for(i=1; i&lt;5; i++) p[i-1][j-1] = pwr(j, i);

  for(j=1; j&lt;11; j++) {
    for(i=1; i&lt;5; i++) printf("%10d ", p[i-1][j-1]);
    printf("\n");
  }

  return 0;
}

/* Возведение чисел в степень. */
pwr(int a, int b)
{
  register int  t=1;

  for(; b; b--) t = t*a;
  return t;
}
</PRE>
<P class="tj">Программа выводит на экран следующее:
<PRE>
         1         1         1         1
         2         4         8        16
         3         9        27        81
         4        16        64       256
         5        25       125       625
         6        36       216      1296
         7        49       343      2401
         8        64       512      4096
         9        81       729      6561
        10       100      1000     10000
</PRE>
<P class="tj">Указатель <KBD>р</KBD> в главной программе (<KBD>main()</KBD>) объявлен как
<PRE>int (*p)[10]</PRE>
<P class="tj">Следует отметить, что скобки вокруг <KBD>*р</KBD> обязательны. Такое объявление означает, что <KBD>р</KBD> указывает на массив из 10 целых. Если увеличить указатель <KBD>р</KBD> на 1, то он будет указывать на следующие 10 целых чисел. Таким образом, <KBD>р</KBD> — это указатель на двухмерный массив с 10 числами в каждой строке. Поэтому <KBD>р</KBD> можно индексировать как обычный двухмерный массив. Разница только в том, что здесь память выделена с помощью <KBD>malloc()</KBD>, а для обыкновенного массива память выделяет компилятор.
<P class="tj">Как упоминалось ранее, в C++ нужно преобразовывать типы указателей явно. Поэтому чтобы данная программа была правильной и в С, и в C++, необходимо выполнить явное приведение типа значения, возвращаемого функцией <KBD>malloc()</KBD>. Для этого строчку, в которой указателю <KBD>р</KBD> присваивается это значение, нужно переписать следующим образом:
<PRE>p = (int (*)[10]) malloc(40*sizeof(int));</PRE>
<P class="tj">Многие программисты используют явное преобразование типов указателей для обеспечения совместимости с C++.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Применяются и другие названия: <I>динамическая область</I>, <I>динамически распределяемая область</I>, <I>куча</I>, <I>неупорядоченный массив (данных)</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>В примере динамически размещается только левое измерение массива. Однако это нетрудно сделать и для всех измерений, объявив указатель <KBD>**р</KBD> и разместив каждое измерение отдельно. Такой прием особенно удобен при написании функции, один из аргументов которой — двухмерный массив с неизвестными заранее размерами измерений.
</BLOCKQUOTE> 
<HR><A href="../main.htm#05">Содержание</A> | <A href="0508.htm">&lt;&lt;&lt;</A> | <A href="0510.htm">&gt;&gt;&gt;</A>
</BODY></HTML>