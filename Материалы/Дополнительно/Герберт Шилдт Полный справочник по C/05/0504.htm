<HTML><HEAD>
<TITLE>Указательные выражения</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#05">Содержание</A> | <A href="0503.htm">&lt;&lt;&lt;</A> | <A href="0505.htm">&gt;&gt;&gt;</A><HR>
<H1>Указательные выражения</H1>
<P class="tj">В общем случае выражения с указателями подчиняются тем же правилам, что и обычные выражения. В этом разделе рассматривается применение указательных выражений в операциях присваивания, преобразования типов, а также в операциях "указательной" арифметики.
<H2>Присваивание указателей</H2>
<P class="tj">Указатель можно использовать в правой части оператора присваивания для присваивания его значения другому указателю. Если оба указателя имеют один и тот же тип, то выполняется простое присваивание, без преобразования типа. В следующем примере
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int x = 99;
  int *p1, *p2;

  p1 = &x;
  p2 = p1;

  /* печать значение x дважды */
  printf("Значение по адресу p1 и p2: %d %d\n", *p1, *p2); 

  /* печать адреса x дважды */
  printf("Значение указателей p1 и p2: %p %p", p1, p2); 

  return 0;
}
</PRE>
<P class="t">после присваивания
<PRE>
p1 = &x;
p2 = p1;
</PRE>
<P class="t">оба указателя (<KBD>p1</KBD> и <KBD>р2</KBD>) ссылаются на <KBD>х</KBD>. То есть, оба указателя ссылаются на один и тот же объект. Программа выводит на экран следующее:
<PRE>
Значения по адресу p1 и р2 : 99 99
Значения указателей p1 и р2: 0063FDF0 0063FDF0
</PRE>
<P class="tj">Обратите внимание, для вывода значений указателей в функции <KBD>printf()</KBD> используется спецификатор формата <KBD>%р</KBD>, который выводит адреса в формате, используемом компилятором.
<P class="tj">Допускается присваивание указателя одного типа указателю другого типа. Однако для этого необходимо выполнить явное преобразование типа указателя (операция приведения типов), которая рассматривается в следующем разделе.
<H2>Преобразование типа указателя</H2>
<P class="tj">Указатель можно преобразовать к другому типу. Эти преобразования бывают двух видов: с использованием указателя типа void * и без его использования.
<P class="tj">В языке С допускается присваивание указателя типа void * указателю любого другого типа (и наоборот) без явного преобразования типа указателя. Тип указателя void * используется, если тип объекта неизвестен. Например, использование типа void * в качестве параметра функции позволяет передавать в функцию указатель на объект любого типа, при этом сообщение об ошибке не генерируется. Также он полезен для ссылки на произвольный участок памяти, независимо от размещенных там объектов. Например, функция размещения mallocO (рассматривается далее в этой главе) возвращает значение типа void *, что позволяет использовать ее для размещения в памяти объектов любого типа.
<P class="tj">В отличие от void *, преобразования всех остальных типов указателей должны быть всегда явными (т.е. должна быть указана операция приведения типов). Однако следует учитывать, что преобразование одного типа указателя к другому может вызвать непредсказуемое поведение программы. Например, в следующей программе делается попытка присвоить значение х переменной у посредством указателя р. При компиляции программы сообщение об ошибке не генерируется, однако результат работы программы неверен.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  double x = 100.1, y;
  int  *p;

  /* В следующем операторе указателю на целое p 
     (присваивается значение, ссылающееся на double. */
  p = (int *) &x;

  /* Следующий оператор работает не так, как ожидается. */
  y = *p; /* attempt to assign y the value x through p */

  /* Следующий оператор не выведет число  100.1. */
  printf("Значение x равно: %f (Это не так!)", y);

  return 0;
}
</PRE>
<P class="tj">Обратите внимание на то, что операция приведения типов применяется в операторе присваивания адреса переменной <KBD>х</KBD> (он имеет тип <KBD>double *</KBD>) указателю <KBD>p</KBD>, тип которого <KBD>int *</KBD>. Преобразование типа выполнено корректно, однако программа работает не так, как ожидается (по крайней мере, в большинстве оболочек). Для разъяснения проблемы предположим, что переменная <KBD>int</KBD> занимает в памяти 4 байта, а <KBD>double</KBD> — 8 байтов. Указатель <KBD>p</KBD> объявлен как указатель на целую переменную (т.е. типа <KBD>int</KBD>), поэтому оператор присваивания
<PRE>y = *р;</PRE>
<P class="t">передаст переменной <KBD>y</KBD> только 4 байта информации, а не 8 байтов, необходимых для <KBD>double</KBD>. Несмотря на то, что <KBD>p</KBD> ссылается на объект <KBD>double</KBD>, оператор присваивания выполнит действие с объектом типа <KBD>int</KBD>, потому что <KBD>p</KBD> объявлен как указатель на <KBD>int</KBD>. Поэтому такое использование указателя <KBD>p</KBD> неправильное.
<P class="tj">Приведенный пример подтверждает то, что операции с указателями выполняются в зависимости от базового типа указателей. Синтаксически допускается ссылка на объект с типом, отличным от типа указателя, однако при этом указатель будет "думать", что он ссылается на объект своего типа. Таким образом, операции с указателями управляются типом указателя, а не типом объекта, на который он ссылается.
<P class="tj">Разрешен еще один тип преобразований: преобразование целого в указатель и наоборот. В этом случае необходимо применить операцию приведения типов (явное преобразование типа). Однако пользоваться этим средством нужно очень осторожно, потому что при этом легко получить непредсказуемое поведение программы. Явное преобразование типа не обязательно, если преобразуется нуль, то есть нулевой указатель.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">В языке C++ требуется явно указывать преобразование типа указателей, в том числе указателей типа <KBD>void *</KBD>. Поэтому многие программисты используют в языке С явное преобразование для совместимости с C++.
</TABLE>
<H2>Адресная арифметика</H2>
<P class="tj">В языке С допустимы только две арифметические операции над указателями: суммирование и вычитание. Предположим, текущее значение указателя <KBD>p1</KBD> типа <KBD>int *</KBD> равно 2000. Предположим также, что переменная типа <KBD>int</KBD> занимает в памяти 2 байта. Тогда после операции увеличения
<PRE>p1++;</PRE>
<P class="t">указатель <KBD>p1</KBD> принимает значение 2002, а не 2001. То есть, при увеличении на 1 указатель <KBD>p1</KBD> будет ссылаться на следующее целое число. Это же справедливо и для операции уменьшения. Например, если <KBD>p1</KBD> равно 2000, то после выполнения оператора
<PRE>p1--;</PRE>
<P class="t">значение <KBD>p1</KBD> будет равно 1998.
<P class="tj">Операции адресной арифметики подчиняются следующим правилам. После выполнения операции увеличения над указателем, данный указатель будет ссылаться на следующий объект своего базового типа. После выполнения операции уменьшения — на предыдущий объект. Применительно к указателям на <KBD>char</KBD>, операций адресной арифметики выполняются как обычные арифметические операции, потому что длина объекта <KBD>char</KBD> всегда равна 1. Для всех указателей адрес увеличивается или уменьшается на величину, равную размеру объекта того типа, на который они указывают. Поэтому указатель всегда ссылается на объект с типом, тождественным базовому типу указателя. Эта концепция иллюстрируется с помощью рис. 5.2.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 5.2. Пример размещения в памяти переменных <KBD>char</KBD> (слева) и <KBD>int</KBD> (справа)</I>
<TR><TD>
<PRE>
char *ch = (char *) 3000;
int *i = (int *) 3000;

       +------+
ch ---&gt;| 3000 |--.
       +------+  |&lt;- i
ch+1 -&gt;| 3001 |--'
       +------+
ch+2 -&gt;| 3002 |--.
       +------+  |&lt;- i+1
ch+3 -&gt;| 3003 |--'
       +------+
ch+4 -&gt;| 3004 |--.
       +------+  |&lt;- i+2
ch+5 -&gt;| 3005 |--'
       +------+
        Память
</PRE>
</TABLE> 
<P class="tj">Операции адресной арифметики не ограничены увеличением (инкрементом) и уменьшением (декрементом). Например, к указателям можно добавлять целые числа или вычитать из них целые числа. Выполнение оператора
<PRE>p1 = p1 + 12;</PRE>
<P class="t">"передвигает" указатель <KBD>p1</KBD> на 12 объектов в сторону увеличения адресов.
<P class="tj">Кроме суммирования и вычитания указателя и целого, разрешена еще только одна операция адресной арифметики: можно вычитать два указателя. Благодаря этому можно определить количество объектов, расположенных между адресами, на которые указывают данные два указателя; правда, при этом считается, что тип объектов совпадает с базовым типом указателей. Все остальные арифметические операции запрещены. А именно: нельзя делить и умножать указатели, суммировать два указателя, выполнять над указателями побитовые операции, суммировать указатель со значениями, имеющими тип <KBD>float</KBD> или <KBD>double</KBD> и т.д.
<H2>Сравнение указателей</H2>
<P class="tj">Стандартом С допускается сравнение двух указателей. Например, если объявлены два указателя <KBD>р</KBD> и <KBD>q</KBD>, то следующий оператор является правильным:
<PRE>if(p &lt; q) printf("p ссылается на меньший адрес, чем q\n");</PRE>
<P class="tj">Как правило, сравнение указателей может оказаться полезным, только тогда, когда два указателя ссылаются на общий объект, например, на массив. В качестве примера рассмотрим программу с двумя стековыми функциями, предназначенными для записи и считывания целых чисел. Стек — это список, использующий систему доступа "первым вошел — последним вышел". Иногда стек сравнивают со стопкой тарелок на столе: первая, поставленная на стол, будет взята последней. Стеки часто используются в компиляторах, интерпретаторах, программах обработки крупноформатных таблиц и в других системных программах. Для создания стека необходимы две функции: <KBD>push()</KBD> и <KBD>pop()</KBD>. Функция <KBD>push()</KBD> заносит числа в стек, a <KBD>pop()</KBD> — извлекает их. В данном примере эти функции используются в <KBD>main()</KBD>. При вводе числа с клавиатуры, программа помещает его в стек. Если ввести 0, то число извлекается из стека. Программа завершает работу при вводе -1.
<PRE>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE 50

void push(int i);
int pop(void);

int  *tos, *p1, stack[SIZE];

int main(void)
{
  int value;

  tos = stack; /* tos ссылается на основание стека */
  p1 = stack; /* инициализация p1 */

  do {
    printf("Введите значение: ");
    scanf("%d", &value);

    if(value != 0) push(value);
    else printf("значение на вершине равно %d\n", pop());

  } while(value != -1);

  return 0;
}

void push(int i)
{
  p1++;
  if(p1 == (tos+SIZE)) {
    printf("Переполнение стека.\n");
    exit(1);
  }
  *p1 = i;
}

int pop(void)
{
  if(p1 == tos) {
    printf("Стек пуст.\n");
    exit(1);
  }
  p1--;
  return *(p1+1);
}
</PRE>
<P class="tj">Стек хранится в массиве <KBD>stack</KBD>. Сначала указатели <KBD>p1</KBD> и <KBD>tos</KBD> устанавливаются на первый элемент массива <KBD>stack</KBD>. В дальнейшем <KBD>p1</KBD> ссылается на верхний элемент стека, a <KBD>tos</KBD> продолжает хранить адрес основания стека. После инициализации стека используются функции <KBD>push()</KBD> и <KBD>pop()</KBD>. Они выполняют запись в стек и считывание из него, проверяя каждый раз соблюдение границы стека. В функции <KBD>push()</KBD> проверяется, что указатель <KBD>p1</KBD> не превышает верхней границы стека <KBD>tos+SIZE</KBD>. Это предотвращает переполнение стека. В функции <KBD>pop()</KBD> проверяется, что указатель <KBD>p1</KBD> не выходит за нижнюю границу стека.
<P class="tj">В операторе <KBD>return</KBD> функции <KBD>pop()</KBD> скобки необходимы потому, что без них оператор
<PRE>return *p1+1;</PRE>
<P class="t">вернул бы значение, расположенное по адресу <KBD>p1</KBD>, увеличенное на 1, а не значение по адресу <KBD>p1+1</KBD>.
<HR><A href="../main.htm#05">Содержание</A> | <A href="0503.htm">&lt;&lt;&lt;</A> | <A href="0505.htm">&gt;&gt;&gt;</A>
</BODY></HTML>