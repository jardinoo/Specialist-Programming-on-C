<HTML><HEAD>
<TITLE>Квалификатор типа</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#02">Содержание</A> | <A href="0205.htm">&lt;&lt;&lt;</A> | <A href="0207.htm">&gt;&gt;&gt;</A><HR>
<H1>Квалификатор типа</H1>
<P class="tj">В языке С определяются <I>квалификаторы типа</I><SUP><A href="#11" name="1">[1]</A></SUP>, указывающие на доступность и модифицируемость переменной. Стандарт С89 определяет два квалификатора: <KBD>const</KBD> и <KBD>volatile</KBD>. (C99 добавляет третий, <KBD>restrict</KBD>, описанный в <A href="../II.htm">части II</A>.) Квалификатор типа должен предшествовать имени типа, который он квалифицирует (уточняет).
<H2>Квалификатор const</H2>
<P class="tj">Переменная, к которой в объявлении (декларации) применен квалификатор <KBD>const</KBD>, не может изменять свое значение<SUP><A href="#22" name="2">[2]</A></SUP>. Ее можно только инициализировать, то есть присвоить ей значение в начале выполнения программы. Компилятор может поместить переменную этого типа в постоянное запоминающее устройство, так называемое ПЗУ (ROM, read-only memory). Например, в объявлении
<PRE>const int a=10;</PRE>
<P class="t">создается переменная с именем <KBD>а</KBD>, причем ей присваивается начальное значение 10, которое в дальнейшем в программе изменить никак нельзя. Переменную, к которой в объявлении применен квалификатор <KBD>const</KBD>, можно использовать в различных выражениях. Однако свое значение она может получить только в результате инициализации или с помощью аппаратно-зависимых средств.
<P class="tj">Квалификатор <KBD>const</KBD> часто используется для того, чтобы предотвратить изменение функцией объекта, на который указывает аргумент функции. Без него при передаче в функцию указателя эта функция может изменить объект, на который он указывает. Однако если в объявлении параметра-указателя применен квалификатор <KBD>const</KBD>, функция не сможет изменить этот объект. В следующем примере функция <KBD>sp_to_dash()</KBD> печатает минус вместо каждого пробела в строке, передаваемой ей как аргумент. То есть строка "тестовый пример" будет напечатана как "тестовый-пример". Применение квалификатора <KBD>const</KBD> в объявлении параметра функции гарантирует, что внутри функций объект, на который указывает параметр функции, не будет изменен.
<PRE>
#include &lt;stdio.h&gt;

void sp_to_dash(const char *str);

int main(void)
{
  sp_to_dash("тестовый пример");

  return 0;
}

void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str== ' ') printf("%c", '-');
    else printf("%c", *str);
    str++;
  }
}
</PRE>
<P class="tj">Если написать <KBD>sp_to_dash()</KBD> таким образом, что внутри функции строка изменяется, то еще на этапе компиляции в программе будет обнаружена ошибка. Например, на этапе компиляции возникнет ошибка, если написать так:
<PRE>
/* Неправильный пример. */
void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str==' ' ) *str = '-'; /* это не правильно */
    printf("%c", *str);
    str++;
  }
}
</PRE>
<P class="tj">Квалификатор <KBD>const</KBD> используется в объявлениях параметров многих функций стандартной библиотеки. Например, прототип функции <KBD>strlen()</KBD> выглядит так:
<PRE>size_t strlen(const char *<I>str</I>);</PRE>
<P class="tj">Применение квалификатора <KBD>const</KBD> в объявлении <KBD>str</KBD> гарантирует, что функция не изменит строку, на которую указывает <KBD>str</KBD>. Если функция стандартной библиотеки не предназначена для изменения аргумента, то практически всегда в объявлении указателя на аргумент применяется квалификатор <KBD>const</KBD>.
<P class="tj">Программист тоже может применять квалификатор <KBD>const</KBD> для того, чтобы гарантировать сохранность объекта. Но следует помнить, что переменная, даже если к ней применен квалификатор <KBD>const</KBD>, может быть изменена в результате какого-нибудь внешнего по отношению к программе воздействия. Например, ей может быть присвоено значение каким либо устройством. Однако применение квалификатора <KBD>const</KBD> в объявлении переменной гарантирует, что ее изменение может произойти только в ходе внешнего по отношению к программе события.
<H2>Квалификатор volatile</H2>
<P class="tj">Квалификатор <KBD>volatile</KBD> указывает компилятору на то, что значение переменной может измениться независимо от программы, т.е. вследствие воздействия еще чего-либо, не являющегося оператором программы. Например, адрес глобальной переменной можно передать в подпрограмму операционной системы, следящей за временем, и тогда эта переменная будет содержать системное время. В этом случае значение переменной будет изменяться без участия какого-либо оператора программы. Знание таких подробностей важно потому, что большинство компиляторов С автоматически оптимизируют некоторые выражения, предполагая при этом неизменность переменной, если она не встречается в левой части оператора присваивания. В этом случае при очередной ссылке на переменную может использоваться ее предыдущее значение. Некоторые компиляторы изменяют порядок вычислений в выражениях, что может привести к ошибке, если в выражении присутствует переменная, вычисляемая вне программы. Квалификатор <KBD>volatile</KBD> предотвращает такие изменения программы.
<P class="tj">Квалификаторы <KBD>const</KBD> и <KBD>volatile</KBD> могут применяться и совместно. Например, если 0x30 — адрес порта, значение в котором может задаваться только извне, то следующее объявление предотвратит всякую возможность нежелательных побочных эффектов:
<PRE>const volatile char *port = (const volatile char *) 0x30;</PRE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называются также <I>классификаторами</I>, <I>описателями</I>, <I>спецификаторами</I>.
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP>На жаргоне программистов: переменная "типа" <KBD>const</KBD> не может изменять значение. В описании многих языков такие переменные часто называются константами. Но если исключить левые части операторов присваивания, то переменные этого "типа" могут использоваться в тех же ситуациях, что и "настоящие" переменные. В этом смысле константы являются частным случаем переменных.
</BLOCKQUOTE>
<HR><A href="../main.htm#02">Содержание</A> | <A href="0205.htm">&lt;&lt;&lt;</A> | <A href="0207.htm">&gt;&gt;&gt;</A>
</BODY></HTML>