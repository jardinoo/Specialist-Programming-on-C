<HTML><HEAD>
<TITLE>Спецификаторы класса памяти</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#02">Содержание</A> | <A href="0206.htm">&lt;&lt;&lt;</A> | <A href="0208.htm">&gt;&gt;&gt;</A><HR>
<H1>Спецификаторы класса памяти</H1>
<P class="tj">Стандарт С поддерживает четыре спецификатора класса памяти:
<PRE>
extern
static
register
auto
</PRE>
<P class="tj">Эти спецификаторы сообщают компилятору, как он должен разместить соответствующие переменные в памяти. Общая форма объявления переменных при этом такова:
<PRE><I>спецификатор_класса_памяти тип имя переменой;</I></PRE>
<P class="tj">Спецификатор класса памяти в объявлении всегда должен стоять первым.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Стандарты С89 и С99 из соображений удобства синтаксиса утверждают, что <KBD>typedef</KBD> — это спецификатор класса памяти. Однако <KBD>typedef</KBD> не является собственно спецификатором. Подробнее  <KBD>typedef</KBD> рассматривается в книге далее.
</TABLE> 
<H2>Спецификатор extern</H2>
<P class="tj">Прежде чем приступить к рассмотрению спецификатора <KBD>extern</KBD>, необходимо коротко остановиться на компоновке программы. В языке С при редактировании связей к переменной может применяться одно из трех связываний: внутреннее, внешнее или же не относящееся ни к одному из этих типов. (В последнем случае редактирование связей к ней не применяется.) В общем случае к именам функций и глобальных переменных применяется внешнее связывание. Это означает, что после компоновки они будут доступны во всех файлах, составляющих программу. К объектам, объявленным со спецификатором <KBD>static</KBD> и видимым на уровне файла, применяется внутреннее связывание, после компоновки они будут доступны только внутри файла, в котором они объявлены. К локальным переменным связывание не применяется и поэтому они доступны только внутри своих блоков.
<P class="tj">Спецификатор <KBD>extern</KBD> указывает на то, что к объекту применяется внешнее связывание, именно поэтому они будут доступны во всей программе. Далее нам понадобятся чрезвычайно важные понятия объявления и описания. <I>Объявление</I> (<I>декларация</I>) объявляет имя и тип объекта. <I>Описание</I><SUP><A href="#11" name="1">[1]</A></SUP> выделяет для объекта участок памяти, где он будет находиться. Один и тот же объект может быть объявлен неоднократно в разных местах, но описан он может быть только один раз.
<P class="tj">В большинстве случаев объявление переменной является в то же время и ее описанием. Однако, если перед именем переменной стоит спецификатор <KBD>extern</KBD>, то объявление переменной может и не быть ее описанием. Таким образом, если нужно сослаться на переменную, определенную в другой части программы, необходимо объявить ее как внешнюю (<KBD>extern</KBD>).
<P class="tj">Приведем пример использования спецификатора <KBD>extern</KBD>. Обратите внимание, что глобальные переменные <KBD>first</KBD> и <KBD>last</KBD> объявлены <I>после</I> <KBD>main()</KBD>.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  extern int first, last; /* используются глобальные переменные */

  printf("%d %d", first, last);

  return 0;
}

/* описание глобальных переменных first и last */
int first = 10, last = 20;
</PRE>
<P class="tj">Программа напечатает <KBD>10 20</KBD>, потому что глобальные переменные <KBD>first</KBD> и <KBD>last</KBD> инициализированы этими значениями. Объявление <KBD>extern</KBD> сообщает компилятору, что переменные <KBD>first</KBD> и <KBD>last</KBD> определены в другом месте, поэтому программа компилируется без ошибки, несмотря даже на то, что <KBD>first</KBD> и <KBD>last</KBD> используются до своего описания.
<P class="tj">Обратите внимание, в этом примере объявление переменных со спецификатором <KBD>extern</KBD> необходимо только потому, что они не были объявлены до <KBD>main()</KBD>. Если бы их объявление встретилось перед <KBD>main()</KBD>, то в объявлении со спецификатором <KBD>extern</KBD> не было бы необходимости.
<P class="tj">При компиляции выполняются следующие правила. Если компилятор находит переменную, не объявленную внутри блока, он ищет ее объявление во внешних блоках. Если не находит ее и там, то ищет среди объявлений глобальных переменных. В предыдущем примере, если бы не было объявления <KBD>extern</KBD>, компилятор не нашел бы <KBD>first</KBD> и <KBD>last</KBD> среди глобальных переменных, потому что они объявлены после <KBD>main()</KBD>. Здесь спецификатор <KBD>extern</KBD> сообщает компилятору, что эти переменные будут объявлены в файле позже.
<P class="tj">Как сказано выше, спецификатор <KBD>extern</KBD> позволяет объявить переменную, не описывая ее. Но если в объявлении со спецификатором <KBD>extern</KBD> инициализировать переменную, то это объявление становится также и описанием. При этом программист обязательно должен учитывать, что объект может иметь много объявлений, но лишь одно описание.
<P class="tj">Спецификатор <KBD>extern</KBD> играет большую роль в программах, состоящих из многих файлов. В языке С программа может быть записана в нескольких файлах, которые компилируются раздельно, а затем компонуются в одно целое. В этом случае необходимо как-то сообщить всем файлам о глобальных переменных программы. Самый лучший (и наиболее переносимый) способ сделать это — определить (описать) все глобальные переменные в одном файле и объявить их со спецификатором <KBD>extern</KBD> в остальных файлах, как показано на рис. 2.1.</P>
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 2.1. Использование глобальных переменных в раздельно компилируемых модулях</I>
<TR><TD>
<PRE>
  <B>Файл 1</B>                    <B>Файл 2</B>
int x, y;                 extern int x, y;
char ch;                  extern char ch;

int main(void)            void func22(void)
{                         {
  /* ... */                 x = y / 10;
}                         }

void func1(void)          void func23(void)
{                         {
  x = 123;                  y = 10;
}                         }
</PRE>
</TABLE> 
<P class="tj">Во втором файле спецификатор <KBD>extern</KBD> сообщает компилятору, что эти переменные определены в других файлах. Таким образом компилятор узнает имена и типы переменных, размещенных в другом месте, и может отдельно компилировать второй файл, ничего не зная о первом. При компоновке этих двух модулей все ссылки на глобальные переменные будут разрешены.
<P class="tj">На практике программисты обычно включают объявления <KBD>extern</KBD> в заголовочные файлы, которые просто подключаются к каждому файлу исходного текста программы. Это более легкий путь, который к тому же приводит к меньшему количеству ошибок, чем повторение этих объявлений вручную в каждом файле.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Спецификатор <KBD>extern</KBD> можно применять в объявлении функций, но в этом нет необходимости.
</TABLE>
<H2>Спецификатор static</H2>
<P class="tj">Переменные, объявленные со спецификатором <KBD>static</KBD>, хранятся постоянно внутри своей функции или файла. В отличие от глобальных переменных они невидимы за пределами своей функции или файла, но они сохраняют свое значение между вызовами. Эта особенность делает их полезными в общих и библиотечных функциях, которые будут использоваться другими программистами. Спецификатор <KBD>static</KBD> воздействует на локальные и глобальные переменные по-разному.
<H3>Локальные статические переменные</H3>
<P class="tj">Для локальной переменной, описанной со спецификатором <KBD>static</KBD>, компилятор выделяет в постоянное пользование участок памяти, точно так же, как и для глобальных переменных. Коренное отличие статических локальных от глобальных переменных заключается в том, что статические локальные переменные видны только внутри блока, в котором они объявлены. Говоря коротко, статические локальные переменные — это локальные переменные, сохраняющие свое значение между вызовами функции.
<P class="tj">Статические локальные переменные очень важны при создании функций, работающих отдельно, так как многие процедуры требуют сохранения некоторых значений между вызовами. Если бы не было статических переменных, вместо них пришлось бы использовать глобальные, подвергая их риску непреднамеренного изменения другими участками программы. Рассмотрим пример функции, в которой особенно уместно применение статической локальной переменной. Это — генератор последовательности чисел, каждое из которых зависит только от предыдущего. Для хранения числа между вызовами можно использовать глобальную переменную. Однако тогда при каждом использовании функции придется объявлять эту переменную и, что особенно неудобно, постоянно следить за тем, чтобы ее объявление не конфликтовало с объявлениями других глобальных переменных. Значительно лучшее решение — объявить эту переменную со спецификатором <KBD>static</KBD>:
<PRE>
int series(void)
{
  static int series_num;

  series_num = series_num+23;
  return series_num;
} 
</PRE>
<P class="tj">В этом примере переменная <KBD>series_num</KBD> продолжает существовать между вызовами функций, в то время как обычная локальная переменная создается заново при каждом вызове, а затем уничтожается. Поэтому в данном примере каждый вызов <KBD>series()</KBD> генерирует новое число, зависящее от предыдущего, причем удается обойтись без глобальных переменных.
<P class="tj">Статическую локальную переменную можно инициализировать. Это значение присваивается ей только один раз — в начале работы всей программы, но не при каждом входе в блок программы, как обычной локальной переменной. В следующей версии функции <KBD>series()</KBD> статическая локальная переменная инициализируется числом 100:
<PRE>
int series(void)
{
  static int series_num = 100;

  series_num = series_num+23;
  return series_num;
}
</PRE>
<P class="tj">Теперь эта функция всегда будет генерировать последовательность, начинающуюся с числа 123. Однако во многих случаях необходимо дать пользователю программы возможность ввести первое число вручную. Для этого переменную <KBD>series_num</KBD> можно сделать глобальной и предусмотреть возможность задания начального значения. Если же отказаться от объявления переменной <KBD>series_num</KBD> в качестве глобальной, то необходимо ее объявить со спецификатором <KBD>static</KBD>.
<H3>Глобальные статические переменные</H3>
<P class="tj">Спецификатор <KBD>static</KBD> в объявлении глобальной переменной заставляет компилятор создать глобальную переменную, видимую только в том файле, в котором она объявлена. Статическая глобальная переменная, таким образом, подвергается внутреннему связыванию, как описано ранее в разделе "Спецификатор extern". Это значит, что хоть эта переменная и глобальная, тем не менее процедуры в других файлах не увидят ее и не смогут случайно изменить ее значение. Этим снижается риск нежелательных побочных эффектов. А в тех относительно редких случаях, когда для выполнения задачи статическая локальная переменная не подойдет, можно создать небольшой отдельный файл, который содержит только функции, в которых используется эта статическая глобальная переменная. Затем этот файл необходимо откомпилировать отдельно; тогда можно быть уверенным, что побочных эффектов не будет.
<P class="tj">В следующем примере иллюстрируется применение статической глобальной переменной. Здесь генератор последовательности чисел переделан так, что начальное число задается вызовом другой функции, <KBD>series_start()</KBD>:
<PRE>
/* Это должно быть в одном файле
     отдельно от всего остального. */

static int series_num;
void series_start(int seed);
int series(void);

int series(void)
{
  series_num = series_num+23;
  return series_num;
}

/* иницилизирует переменную series_num */
void series_start(int seed)
{
  series_num = seed;
}
</PRE>
<P class="tj">Вызов функции <KBD>series_start()</KBD> с некоторым целым числом в качестве параметра инициализирует генератор <KBD>series()</KBD>. После этого можно генерировать последовательность чисел путем многократного вызова <KBD>series()</KBD>.
<P class="tj"><I>Обзор</I>: Имена локальных статических переменных видимы только внутри блока, в котором они объявлены; имена глобальных статических переменных видимы только внутри файла, в котором они объявлены.
<P class="tj">Если поместить функции <KBD>series()</KBD> и <KBD>series_num()</KBD> в библиотеку, то уже нельзя будет сослаться на переменную <KBD>series_num</KBD>, она оказалась спрятанной от любых операторов всей остальной программы. При этом в программе (конечно, в других файлах) можно объявить и использовать другую переменную под именем <KBD>series_num</KBD>. Иными словами, спецификатор <KBD>static</KBD> позволяет создать переменную, видимую только для функций, в которых она нужна, что исключает нежелательные побочные эффекты.
<P class="tj">Таким образом, при разработке больших и сложных программ для "сокрытия" переменных можно применять спецификатор <KBD>static</KBD>.
<H2>Спецификатор register</H2>
<P class="tj">Первоначально спецификатор класса памяти <KBD>register</KBD> применялся только к переменным типа <KBD>int</KBD>, <KBD>char</KBD> и для указателей. Однако стандарт С расширил использование спецификатора <KBD>register</KBD>, теперь он может применяться к переменным любых типов.
<P class="tj">В первых версиях компиляторов С спецификатор <KBD>register</KBD> сообщал компилятору, что переменная должна храниться в регистре процессора, а не в оперативной памяти, как все остальные переменные. Это приводит к тому, что операции с переменной <KBD>register</KBD> осуществляются намного быстрее, чем с обычными переменными, потому такая переменная уже находится в процессоре и не нужно тратить время на выборку ее значения из оперативной памяти (и на запись в память).
<P class="tj">В настоящее время определение спецификатора <KBD>register</KBD> существенно расширено. Стандарты С89 и С99 попросту декларируют "доступ к объекту так быстро, как только возможно". Практически при этом символьные и целые переменные по-прежнему размещаются в регистрах процессора. Конечно, большие объекты (например, массивы) не могут поместиться в регистры процессора, однако компилятор получает указание "позаботиться" о быстродействии операций с ними. В зависимости от конкретной реализации компилятора и операционной системы переменные <KBD>register</KBD> обрабатываются по-разному. Иногда спецификатор <KBD>register</KBD> попросту игнорируется, а переменная обрабатывается как обычная, однако на практике это бывает редко.
<P class="tj">Спецификатор <KBD>register</KBD> можно применить только к локальным переменным и формальным параметрам функций. В объявлении глобальных переменных применение спецификатора <KBD>register</KBD> не допускается. Ниже приведен пример использования переменной, в объявлении которой применен спецификатор <KBD>register</KBD>; эта переменная используется в функции возведения целого числа <KBD>m</KBD> в степень. (Степень — натуральное число — представлена идентификатором <KBD>е</KBD>.)
<PRE>
int int_pwr(register int m,  register int e)
{
  register int temp;

  temp = 1;

  for(; e; e--) temp = temp * m;
  return temp;
}
</PRE>
<P class="tj">В этом примере в объявлениях к переменным <KBD>е</KBD>, <KBD>m</KBD> и <KBD>temp</KBD> применен спецификатор <KBD>register</KBD> потому, что они используются внутри цикла. Переменные <KBD>register</KBD> идеально подходят для оптимизации скорости работы цикла. Как правило, переменные <KBD>register</KBD> используются там, где от них больше всего пользы, а именно, когда процесс многократно обращается к одной и той же переменной. Это существенно потому, что в объявлении можно применить спецификатор <KBD>register</KBD> к любой переменной, но средства оптимизации быстродействия могут быть применены далеко не ко всем переменным в равной степени.
<P class="tj">Максимальное количество переменных <KBD>register</KBD>, оптимизирующихся по быстродействию, зависит от среды программирования и конкретной реализации компилятора. Если таких переменных окажется слишком много, то компилятор автоматически преобразует регистровые переменные в нерегистровые. Этим обеспечивается переносимость программы в широком диапазоне процессоров.
<P class="tj">Обычно в регистры процессора можно поместить как минимум две переменные типа <KBD>char</KBD> или <KBD>int</KBD>. Однако в различных средах программирования режимы оптимизации могут очень отличаться, поэтому выбор режима оптимизации необходимо осуществлять с учетом особенностей конкретного компилятора.
<P class="tj">В языке С с помощью оператора <KBD>&</KBD> (рассматривается в этой главе далее) нельзя получить адрес регистровой переменной, потому что она может храниться в регистре процессора, который обычно не имеет адреса.
<P class="tj">Хотя в настоящее время применение спецификатора <KBD>register</KBD> в значительной мере вышло за его традиционные рамки, практически ощутимый эффект от его применения по-прежнему может быть получен только для переменных целого и символьного типа. Не следует ожидать заметного повышения скорости от объявления регистровыми переменных других типов.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Синонимы: <I>определение</I>, <I>дефиниция</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#02">Содержание</A> | <A href="0206.htm">&lt;&lt;&lt;</A> | <A href="0208.htm">&gt;&gt;&gt;</A>
</BODY></HTML>