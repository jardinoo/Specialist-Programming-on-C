<HTML><HEAD>
<TITLE>Операции</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#02">Содержание</A> | <A href="0209.htm">&lt;&lt;&lt;</A> | <A href="0211.htm">&gt;&gt;&gt;</A><HR>
<H1>Операции</H1>
<P class="tj">Язык С содержит большое количество встроенных операций. Их роль в С значительно больше, чем в других языках программирования. Существует четыре основных класса операций: <I>арифметические</I>, <I>логические</I>, <I>поразрядные</I> и <I>операции сравнения</I>. Кроме них, есть также некоторые специальные операторы, например, оператор присваивания.
<H2>Оператор присваивания</H2>
<P class="tj">Оператор присваивания может присутствовать в любом выражении языка С<SUP><A href="#11" name="1">[1]</A></SUP>. Этим С отличается от большинства других языков программирования (Pascal, BASIC и FORTRAN), в которых присваивание возможно только в отдельном операторе. Общая форма оператора присваивания:
<PRE><I>имя_переменной=выражение;</I></PRE>
<P class="tj">Выражение может быть просто константой или сколь угодно сложным выражением. В отличие от Pascal или Modula-2, в которых для присваивания используется знак ":=", в языке С оператором присваивания служит единственный знак присваивания "=". <I>Адресатом</I> (<I>получателем</I>), т.е. левой частью оператора присваивания должен быть объект, способный получить значение, например, переменная.
<P class="tj">В книгах по С и в сообщениях компилятора часто встречаются термины <I>lvalue</I><SUP><A href="#22" name="2">[2]</A></SUP> (<I>left side value</I>) и <I>rvalue</I><SUP><A href="#33" name="3">[3]</A></SUP> (<I>right side value</I>). Попросту говоря, <I>lvalue</I> — это объект. Если этот объект может стоять в левой части присваивания, то он называется также <I>модифицируемым</I> (<I>modifiable</I>) <I>lvalue</I>. Подытожим сказанное: <I>lvalue</I> — это объект в левой части оператора присваивания, получающий значение, чаще всего этим объектом является переменная. Термин <I>rvalue</I> означает значение выражения в правой части оператора присваивания.
<H3>Преобразование типов при присваиваниях</H3>
<P class="tj">Если в операции встречаются переменные разных типов, происходит <I>преобразование типов</I>. В операторе присваивания действует простое правило: значение выражения в правой части преобразуется к типу объекта в левой части.
<PRE>
int x;
char ch;
float  f;

void func(void)
{
  ch = x;    /* 1-я строка */
  x = f;     /* 2-я строка */
  f = ch;    /* 3-я строка */
  f = x;     /* 4-я строка */
}
</PRE>
<P class="tj">В 1-й строке этого примера старшие двоичные разряды целой переменной <KBD>х</KBD> отбрасываются, а в <KBD>ch</KBD> заносятся младшие 8 бит. Если значение <KBD>х</KBD> лежит в интервале от 0 до 255, то <KBD>ch</KBD> и <KBD>х</KBD> будут идентичны и потери информации не произойдет. В противном случае в <KBD>ch</KBD> будут занесены только младшие разряды переменной <KBD>х</KBD>. Во 2-й строке в <KBD>х</KBD> будет записана целая часть числа <KBD>f</KBD>. В 3-й строке произойдет преобразование целого 8-разрядного числа, хранящегося в <KBD>ch</KBD>, в число в плавающем формате. В 4-й строке произойдет то же самое, только с 16-разрядным целым.
<P class="tj">Преобразование целых в символы и длинных целых в целые удаляет соответствующее количество старших двоичных разрядов. В 16-разрядной среде теряются 8 битов при преобразовании целого в символ и 16 битов при преобразовании длинного целого в целое. В 32-разрядной среде теряются 24 бита при преобразовании целого в символ и 16 битов при преобразовании целого в короткое целое.
<P class="tj">В табл. 2.3. приведены варианты потери информации при некоторых преобразованиях. Необходимо помнить, что преобразование <KBD>int</KBD> во <KBD>float</KBD> или <KBD>float</KBD> в <KBD>double</KBD> не повышает точность вычислений. При таком преобразовании только изменяется форма представления числа. Некоторые компиляторы при преобразовании <KBD>char</KBD> в <KBD>int</KBD> считают переменную <KBD>char</KBD> положительной независимо от ее значения. Другие компиляторы считают переменную <KBD>char</KBD> отрицательной, если она больше 127. Поэтому для обеспечения переносимости программы необходимо использовать переменные типа <KBD>char</KBD> для хранения символов, а переменные типа <KBD>signed char</KBD> и <KBD>int</KBD> (целый) — для хранения чисел.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.3. Результат некоторых преобразований типов</B><CAPTION>
<TR><TH><I>Тип адресата</I><TH><I>Тип выражения</I><TH><I>Потеря информации</I>
<TR><TD>signed char<TD>char<TD>Если значение > 127, то результат отрицательный
<TR><TD>char<TD>short int<TD>Старшие 6 бит
<TR><TD>char<TD>int (16-разрядный)<TD>Старшие 8 бит
<TR><TD>char<TD>int (32-разрядный)<TD>Старшие 24 бит
<TR><TD>char<TD>long int<TD>Старшие 24 бит
<TR><TD>short int<TD>int (16-разрядный)<TD>Нет
<TR><TD>short int<TD>int (32-разрядный)<TD>Старшие 16 бит
<TR><TD>int (16-разрядный)<TD>long int<TD>Старшие 16 бит
<TR><TD>int (32-разрядный)<TD>long int<TD>Нет
<TR><TD>long int (32-разрядный)<TD>long long int (64-разрядный)<TD>Старшие 32 бита (это относится только к C99)
<TR><TD>int<TD>float<TD>Дробная часть
<TR><TD>float<TD>double<TD>Результат округляется
<TR><TD>double<TD>long double<TD>Результат округляется 
</TABLE>
<P class="tj">Если какое-либо преобразование не приведено в табл. 2.3, то, чтобы определить, что именно теряется в результате этого преобразования, нужно представить его в виде композиции (суперпозиции, произведения) указанных в таблице преобразований и затем провести последовательные преобразования. Например, преобразование <KBD>double</KBD> в <KBD>int</KBD> эквивалентно последовательному выполнению двух преобразований: сначала <KBD>double</KBD> в <KBD>float</KBD>, а затем <KBD>float</KBD> в <KBD>int</KBD>.
<H3>Множественные присваивания</H3>
<P class="tj">В одном операторе присваивания можно присвоить одно и то же значение многим переменным. Для этого используется оператор <I>множественного присваивания</I><SUP><A href="#44" name="4">[4]</A></SUP>, например:
<PRE>x = y = z = 0;</PRE>
<P class="tj">Следует отметить, что в практике программирования этот прием используется очень часто.
<H3>Составное присваивание</H3>
<P class="tj">Составное присваивание — это разновидность оператора присваивания, в которой запись сокращается и становится более удобной в написании<SUP><A href="#55" name="5">[5]</A></SUP>. Например, оператор
<PRE>x = x+10;</PRE>
<P class="t">можно записать как
<PRE>x += 10;</PRE>
<P class="tj">Оператор "+=" сообщает компилятору, что к переменной <KBD>х</KBD> нужно прибавить 10.
<P class="tj">"Составные" операторы<SUP><A href="#66" name="6">[6]</A></SUP> присваивания существуют для всех бинарных операций (то есть операций, имеющих два операнда). Любой оператор вида
<PRE><I>переменная = переменная оператор выражение;</I></PRE>
<P class="t">можно записать как
<PRE><I>переменная оператор = выражение;</I></PRE>
<P class="tj">Еще один пример:
<PRE>x = x-100;</PRE>
<P class="t">означает то же самое, что и
<PRE>x -= 100;</PRE>
<P class="tj">Составное присваивание значительно компактнее, чем соответствующее простое присваивание, поэтому его иногда называют <I>стенографическим</I> (<I>shorthand</I>) <I>присваиванием</I>. В программах на С этот оператор широко используется, поэтому необходимо хорошо его усвоить.
<H2>Арифметические операции</H2>
<P class="tj">В табл. 2.4 приведены арифметические операции С. Операции +, —, * и / работают так же, как и в большинстве других языков программирования. Их можно применять почти ко всем встроенным типам данных. Если операция / применяется к целому или символьному типам, то остаток от деления отбрасывается. Например, результатом операции 5/2 является 2.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.4. Арифметические операции</B><CAPTION>
<TR><TH><I>Оператор</I><TH><I>Операция</I>
<TR><TD>-<TD>Вычитание, так же унарный минус
<TR><TD>+<TD>Сложение
<TR><TD>*<TD>Умножение
<TR><TD>/<TD>Деление
<TR><TD>%<TD>Остаток от деления
<TR><TD>--<TD>Декремент<SUP><A href="#77" name="7">[7]</A></SUP>, или уменьшение
<TR><TD>++<TD>Инкремент<SUP><A href="#88" name="8">[8]</A></SUP>, или увеличение
</TABLE>
<P class="tj">Оператор деления по модулю % в С работает так же, как и в других языках, его результатом является остаток от целочисленного деления. Этот оператор, однако, нельзя применять к типам данных с плавающей точкой. Применение оператора % иллюстрируется следующим примером:
<PRE>
int x, y;

x = 5;
y = 2;

printf("%d ", x/y);   /* напечатает 2 */
printf("%d ", x%y);   /* напечатает 1,
                         остаток от целочисленного деления */

x = 1;
y = 2;

printf("%d %d", x/y, x%y); /*  напечатает 0 1 */
</PRE>
<P class="tj">Последняя строка программы напечатает <KBD>0 1</KBD> потому, что при целочисленном делении остаток отбрасывается и здесь результат будет 0, а сам остаток равен 1.
<P class="tj">Унарный минус умножает операнд на -1, то есть меняет его знак на противоположный.
<H2>Операции увеличения (инкремента) и уменьшения (декремента)</H2>
<P class="tj">В языке С есть два полезных оператора, значительно упрощающие широко распространенные операции. Это инкремент ++ и декремент --. Оператор ++ увеличивает значение операнда на 1, а — уменьшает на 1. Иными словами,
<PRE>x = x+1;</PRE>
<P class="t">можно записать как
<PRE>++x;</PRE>
<P class="tj">Аналогично оператор
<PRE>x = x-1;</PRE>
<P class="t">равносилен оператору
<PRE>x--;</PRE>
<P class="tj">Как инкремент, так и декремент могут предшествовать операнду (префиксная форма) или следовать за ним (постфиксная форма). Например
<PRE>x = x+1;</PRE>
<P class="t">можно записать как в виде
<PRE>++x;</PRE>
<P class="t">так и в виде
<PRE>x++;</PRE>
<P class="tj">Однако префиксная и постфиксная формы отличаются при использовании их в выражениях. Если оператор инкремента или декремента предшествует операнду, то сама операция выполняется до использования результата в выражении. Если же оператор следует за операндом, то в выражении значение операнда используется до выполнения операции инкремента или декремента. То есть для выражения эта операция как бы не существует, она выполняется только для операнда. Например,
<PRE>x = 10;
y = ++x;</PRE>
<P class="t">присваивает <KBD>у</KBD> значение 11. Однако если написать
<PRE>x = 10;
y = x++;</PRE>
<P class="t">то переменной <KBD>у</KBD> будет присвоено значение 10. В обоих случаях х присвоено значение 11, разница только в том, когда именно это случилось, до или после присваивания значения переменной <KBD>у</KBD>.
<P class="tj">Большинство компиляторов С генерируют для инкремента и декремента очень быстрый, эффективный объектный код, значительно лучший, чем для соответствующих операторов присваивания. Поэтому везде, где это возможно, рекомендуется использовать инкремент и декремент.
<P class="tj">Приоритет выполнения арифметических операторов следующий:
<PRE>
<B>Наивысший</B>     ++ --
              - (унарный минус)
              * / %
<B>Наинизший</B>     + -
</PRE>
<P class="tj">Операции с одинаковым приоритетом выполняются слева направо. Используя круглые скобки, можно изменить порядок вычислений. В языке С круглые скобки интерпретируются компилятором так же, как и в любом другом языке программирования: они как бы придают операции (или последовательности операций) наивысший приоритет.
<H2>Операции сравнения и логические операции</H2>
<P class="tj">Операции <I>сравнения</I> — это операции, в которых значения двух переменных сравниваются друг с другом. <I>Логические</I> же операции реализуют средствами языка С операции формальной логики. Между логическими операциями и операциями сравнения существует тесная связь: результаты операций <I>сравнения</I> часто являются операндами <I>логических</I> операций.
<P class="tj">В операциях сравнения и логических операциях в качестве операндов и результатов операций используются значения ИСТИНА (true) и ЛОЖЬ (false). В языке С значение ИСТИНА представляется любым числом, отличным от нуля. Значение ЛОЖЬ представляется нулем. Результатом операции сравнения или логической операции являются ИСТИНА (true, 1) или ЛОЖЬ (false, 0).</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Как в С89, так и в С99 значение ИСТИНА представлено любым отличным от нуля числом, а ЛОЖЬ — нулем. В стандарте С99 дополнительно определен тип данных <KBD>_Bооl</KBD>, переменные которого могут принимать значение только или 1. Подробнее см. <A href="../II.htm">часть II</A>.
</TABLE>
<P class="tj">В табл. 2.5 приведен полный список операций сравнения и логических операций. Таблица истинности логических операций имеет следующий вид:</P>
<TABLE align=center border=1 width=100%>
<TR><TH><I>p</I><TH><I>q</I><TH><I>p && q</I><TH><I>p || q</I><TH><I>!p</I>
<TR align=center><TD>0<TD>0<TD>0<TD>0<TD>1
<TR align=center><TD>0<TD>1<TD>0<TD>1<TD>1
<TR align=center><TD>1<TD>1<TD>1<TD>1<TD>0
<TR align=center><TD>1<TD>0<TD>0<TD>1<TD>0
</TABLE>
<P class="tj">Как операции сравнения, так и логические операции имеют низший приоритет по сравнению с арифметическими. То есть, выражение 10&gt;1+12 интерпретируется как 10&gt;(1+12). Результат, конечно, равен ЛОЖЬ.
<P class="tj">В одном выражении можно использовать несколько операций:
<PRE>10&gt;5 && !(10&lt;9) || 3&lt;4</PRE>
<P class="tj">В этом случае результатом будет ИСТИНА.
<P class="tj">В языке С не определена операция "исключающего ИЛИ" (exclusive OR, или XOR). Однако с помощью логических операторов несложно написать функцию, выполняющую эту операцию. Результатом операции "исключающее ИЛИ" является ИСТИНА, если и только если один из операндов (но не оба) имеют значение ИСТИНА. В следующем примере функция <KBD>xor()</KBD> возвращает результат операции "исключающее ИЛИ", а операндами служат аргументы функции:
<PRE>
#include &lt;stdio.h&gt;

int xor(int a, int b);

int main(void)
{
  printf("%d", xor(1, 0));
  printf("%d", xor(1, 1));
  printf("%d", xor(0, 1));
  printf("%d", xor(0, 0));

  return 0;
}

/* Выполнение логической оперции
   исключающее ИЛИ над двумя аргументами. */
int xor(int a, int b)
{
  return (a || b) && !(a && b);
}
</PRE>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.5. Операции сравнения и логические операции</B><CAPTION>
<TR align=center><TH colspan="2"><I>Операторы сравнения</I> 
<TR><TH><I>Оператор</I><TH><I>Операция</I>
<TR><TD>&gt;<TD>Больше чем
<TR><TD>&gt;=<TD>Больше или равно
<TR><TD>&lt;<TD>Меньше чем
<TR><TD>&lt;=<TD>Меньше или равно
<TR><TD>==<TD>Равно
<TR><TD>!=<TD>Не равно
<TR align=center><TH colspan="2"><I>Логические операции</I> 
<TR><TH><I>Оператор</I><TH><I>Операция</I>
<TR><TD>&&<TD>И
<TR><TD>||<TD>ИЛИ
<TR><TD>!<TD>НЕ, отрицание
</TABLE>
<P class="tj">Ниже приведен приоритет логических операций:
<PRE>
<B>Наивысший</B>     !
              &gt; &gt;= &lt; &lt;=
              == !=
              &&
<B>Наинизший</B>     ||
</PRE>
<P class="tj">Как и в арифметических выражениях, для изменения порядка выполнения операций сравнения и логических операций можно использовать круглые скобки. Например, выражение:
<PRE>!0 && 0 || 0</PRE>
<P class="t">равно ЛОЖЬ. Однако, если добавить скобки как показано ниже, то результатом будет ИСТИНА:
<PRE>!(0 && 0) || 0</PRE>
<P class="tj">Необходимо помнить, что результатом любой операции сравнения или логической операции есть 0 или 1. Поэтому следующий фрагмент программы является правильным и в результате его выполнения будет напечатано <KBD>1</KBD>.
<PRE>
int x; 

x = 100;
printf("%d", x&gt;10);
</PRE>
<H2>Поразрядные операции</H2>
<P class="tj">В отличие от многих других языков программирования, в С определен полный набор <I>поразрядных операций</I><SUP><A href="#99" name="9">[9]</A></SUP>. Это обусловлено тем, что С был задуман как язык, призванный во многих приложениях заменить ассемблер, который способен оперировать битами данных. <I>Поразрядные операции</I> — это тестирование (проверка), сдвиг или присвоение значений отдельным битам данных. Эти операции осуществляются над ячейками памяти, содержащими данные типа <KBD>char</KBD> или <KBD>int</KBD>. Данные типа <KBD>float</KBD>, <KBD>double</KBD>, <KBD>long double</KBD>, <KBD>void</KBD> или другие более сложные не могут участвовать в поразрядных операциях. В табл. 2.6 приведен полный список знаков поразрядных операций, выполняемых над отдельными разрядами (битами) операндов.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.6. Поразрядные операции</B><CAPTION>
<TR><TH><I>Оператор</I><TH><I>Операция</I>
<TR><TD>&<TD>И
<TR><TD>|<TD>ИЛИ
<TR><TD>^<TD>исключающее ИЛИ
<TR><TD>~<TD>НЕ (отрицание, дополнение к 1)
<TR><TD>&gt;&gt;<TD>Сдвиг вправо
<TR><TD>&lt;&lt;<TD>Сдвиг влево
</TABLE>
<P class="tj">Таблицы истинности логических операций и поразрядных операций И, ИЛИ, НЕ совпадают. Отличие лишь в том, что поразрядные операции выполняются над отдельными разрядами (битами) операндов. Операция "исключающее ИЛИ" имеет следующую таблицу истинности:</P>
<TABLE align=center border=1 width=100%>
<TR><TH><I>p</I><TH><I>q</I><TH><I>p ^ q</I>
<TR align=center><TD>0<TD>0<TD>0
<TR align=center><TD>1<TD>0<TD>1
<TR align=center><TD>1<TD>1<TD>0
<TR align=center><TD>0<TD>1<TD>1
</TABLE>
<P class="tj">Как показано в таблице, результат операции "исключающее ИЛИ" равен ИСТИНА если и только если один из операндов равен 1, иначе результат будет равен ЛОЖЬ.
<P class="tj">Наиболее часто поразрядные операции применяются при программировании драйверов устройств, таких как модемы, а также процедур, выполняющих операции над файлами, и стандартных программ обслуживания принтера. В них поразрядные операции используются для маскирования определенных битов, например, бита контроля четности<SUP><A href="#1010" name="010">[10]</A></SUP>. (Этот бит служит для проверки правильности остальных битов в байте. Чаще всего это бит старшего разряда в каждом байте.)
<P class="tj">Операция И может быть использована для <I>очищения бита</I><SUP><A href="#1111" name="011">[11]</A></SUP>. Иными словами, для гашения бита используется следующее свойство операции И: если бит одного из операндов равен 0, то соответствующий бит результата будет равен 0 независимо от состояния этого бита во втором операнде. Например, следующая функция читает символ из порта модема и обнуляет бит контроля четности:
<PRE>
char get_char_from_modem(void)
{
  char ch;

  ch = read_modem(); /* чтение символа из
                        порта модема */
  return(ch & 127);
}
</PRE>
<P class="tj">Бит контроля четности, находящийся в 8-м разряде байта, обнуляется с помощью операции И. При этом в качестве второго операнда выбирается число, имеющее 1 в разрядах от 1 до 7, и 0 в 8-м разряде. Именно таким числом и является 127, поскольку все биты двоичного представления числа 127, кроме старшего, равны 1. В силу указанного свойства операции И операция ch & 127 оставляет все биты, кроме старшего, без изменения, а старший обнуляет:
<P class="tj">Бит контроля четности
<PRE>
  |
  V
  1100 0001     переменная ch содержит символ 'A' с битом четности
  0111 1111     двоичное представление числа 127
& ---------     поразрядная операция И
  0100 0001     символ 'A' с обнуленным битом контроля четности
</PRE>
<P class="tj">Поразрядная операция ИЛИ, являющаяся двойственной операции И, применяется для установки необходимых битов в 1. В следующем примере выполняется операция 128 | 3:
<PRE>
  |
  V
  1000 0000     двоичное представление числа 128
  0000 0011     двоичное представление числа 3
| ---------     поразрядная операция ИЛИ
  1000 0011     результат
</PRE>
<P class="tj">Операция исключающего ИЛИ (XOR) устанавливает бит результата в 1, если соответствующие биты операндов различны. В следующем примере выполняется операция 127 ^ 120:
<PRE>
  |
  V
  0000 0011     двоичное представление числа 127
  0111 1000     двоичное представление числа 120
^ ---------     поразрядная операция XOR
  0000 0111     результат
</PRE>
<P class="tj">Необходимо помнить, что результат логической операции всегда равен 0 или 1. В то же время результатом поразрядной операции может быть любое значение, которое, как видно из предыдущих примеров, не обязательно равно 0 или 1.
<P class="tj">Поразрядные операторы сдвига &gt;&gt; и &lt;&lt; сдвигают все биты переменной вправо или влево. Общая форма оператора сдвига вправо:
<PRE><I>переменная &gt;&gt; количество_разрядов</I></PRE>
<P class="tj">Общая форма оператора сдвига влево:
<PRE><I>переменная &lt;&lt; количество_разрядов</I></PRE>
<P class="tj">Во время сдвига битов в один конец числа, другой конец заполняется нулями. Но если число типа <KBD>signed int</KBD> отрицательно, то при сдвиге вправо левый конец заполняется единицами, так что знак числа сохраняется. Необходимо отметить различие между сдвигом и циклическим сдвигом. При циклическом сдвиге биты, сдвигаемые за пределы операнда, появляются на другом конце операнда. А при сдвиге вышедшие за границу биты теряются.
<P class="tj">Поразрядные операции сдвига очень полезны при декодировании выходов внешних устройств, например таких, как цифро-аналоговые преобразователи, а также при считывании информации о статусе устройств. Побитовые операторы сдвига могут быстро умножать и делить целые числа. Как показано в табл. 2.7, сдвиг на один бит вправо делит число на 2, а на один бит влево — умножает на 2. Следующая программа иллюстрирует применение операторов сдвига:
<PRE>
/* Пример применения операторов сдвига. */
#include &lt;stdio.h&gt;

int main(void)
{
  unsigned int i;
  int j;

  i = 1;

  /* сдвиг влево */
  for(j=0; j&lt;4; j++) {
    i = i &lt;&lt; 1;  /* сдвиг i влево на 1 разраяд, что
                    равносильно умножению на 2 */
    printf("Сдвиг влево на %d разр.: %d\n", j, i);
  }

  /* сдвиг вправо */
  for(j=0; j&lt;4; j++) {
    i = i &gt;&gt; 1;  /* сдвиг i вправо на 1 разраяд, что
                    равносильно делению на 2 */
    printf("Сдвиг вправо на %d разр.: %d\n", j, i);
  }

  return 0;
}
</PRE>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.7. Умножение и деление операторами сдвига</B><CAPTION>
<TR><TH><I>unsigned char x</I><TH><I>x после операции</I><TH><I>значение x</I>
<TR><TD>x = 7<TD>0000 0111<TD>7
<TR><TD>x = x &lt;&lt; 1<TD>0000 1110<TD>14
<TR><TD>x = x &lt;&lt; 3<TD>0111 0000<TD>112
<TR><TD>x = x &lt;&lt; 2<TD>1100 0000<TD>192
<TR><TD>x = x &gt;&gt; 1<TD>0110 0000<TD>96
<TR><TD>x = x &gt;&gt; 2<TD>0001 1000<TD>24
<TR align=justify><TD colspan="3">Каждый сдвиг влево умножает на 2. Потеря информации произошла после операции x &lt;&lt; 2 в результате сдвига за левую границу.<BR>Каждый сдвиг вправо делит на 2. Сдвиг вправо потерянную информацию не восстановил.
</TABLE>
<P class="tj">Поразрядная операция отрицания (дополнения) ~ инвертирует состояние каждого бита операнда. То есть, 0 преобразует в 1, а 1 — в 0.
<P class="tj">Поразрядные операции часто используются в процедурах кодирования. Проделав с дисковым файлом некоторые поразрядные операции, его можно сделать нечитаемым. Простейший способ сделать это — применить операцию отрицания к каждому биту:
<PRE>Исходный байт 0010100
После 1-го отрицания 1101011
После 2-го отрицания 0010100</PRE>
<P class="tj">Обратите внимание, при последовательном применении 2-х отрицаний результатом всегда будет исходное число. Таким образом, 1-е отрицание кодирует состояние байта, а 2-е — декодирует.
<P class="tj">В следующем примере оператор отрицания используется в функции шифрования символа:
<PRE>
/* Простейшая процедура шифрования. */
char encode(char ch)
{
  return(~ch); /* оперция отрицания */
}
</PRE>
<P class="tj">Конечно, взломать такой шифр не представляет труда.
<H2>Операция ?</H2>
<P class="tj">В языке С определен мощный и удобный оператор, который часто можно использовать вместо оператора вида if-then-else. Речь идет о тернарном операторе ?, общий вид которого следующий:
<PRE><I>Выражение1 ? Выражение2 : Выражение3;</I></PRE>
<P class="tj">Обратите внимание на использование двоеточия. Оператор ? работает следующим образом: сначала вычисляется <I>Выражение1</I>, если оно истинно, то вычисляется <I>Выражение2</I> и его значение присваивается всему выражению; если <I>Выражение1</I> ложно, то вычисляется <I>Выражение3</I> и всему выражению присваивается его значение. В примере
<PRE>x = 10;

y = x&gt;9 ? 100 : 200;</PRE>
<P class="t">переменной <KBD>у</KBD> будет присвоено значение 100. Если бы <KBD>х</KBD> было меньше 9, то переменной <KBD>у</KBD> было бы присвоено значение 200. Эту же процедуру можно написать, используя оператор if-else:
<PRE>x = 10;

if(x&gt;9) y = 100;
else y = 200;</PRE>
<P class="tj">Более подробно оператор ? обсуждается в <A href="../03/03.htm">главе 3</A> в связи с условными операторами.
<H2>Операция получения адреса (&) и раскрытия ссылки (*)</H2>
<P class="tj"><I>Указатель</I> — это адрес объекта в памяти. <I>Переменная типа "указатель" (или просто переменная-указатель)</I> — это специально объявленная переменная, в которой хранится указатель на переменную определенного типа. В языке С указатели служат мощнейшим средством создания программ и широко используются для самых разных целей. Например, с их помощью можно быстро обратиться к элементам массива или дать функции возможность модифицировать свои аргументы. Указатели широко используются для связи элементов в списках, в двоичных деревьях и в других динамических структурах данных. <A href="../05/05.htm">Глава 5</A> полностью посвящена указателям. В данной главе коротко рассматриваются два оператора, использующиеся для работы с указателями.
<P class="tj">Первый из них — <I>оператор &</I>, это унарный оператор, возвращающий адрес операнда в памяти<SUP><A href="#1212" name="012">[12]</A></SUP>. (Унарной операцией называется операция, имеющая только один операнд.) Например, оператор
<PRE>m = &count;</PRE>
<P class="t">записывает в переменную <KBD>m</KBD> адрес переменной <KBD>count</KBD>. Этот адрес представляет собой адрес ячейки памяти компьютера, в которой размещена переменная. Адрес и значение переменной — совершенно разные понятия. Выражение "&переменная" означает "адрес переменной". Следовательно, инструкция <KBD>m = &scount;</KBD> означает: "Переменной <KBD>m</KBD> присвоить адрес, по которому расположена переменная <KBD>count;</KBD>".
<P class="tj">Допустим, переменная <KBD>count</KBD> расположена в памяти в ячейке с адресом 2000, а ее значение равно 100. Тогда в предыдущем примере переменной <KBD>m</KBD> будет присвоено значение 2000.
<P class="tj">Второй рассматриваемый <I>оператор *</I> является двойственным (дополняющим) по отношению к &<SUP><A href="#1313" name="013">[13]</A></SUP>. Оператор * является унарным оператором, он возвращает значение объекта, расположенного по указанному адресу. Операндом для * служит адрес объекта (переменной). Например, если переменная <KBD>m</KBD> содержит адрес переменной <KBD>count</KBD>, то оператор
<PRE>q = *m;</PRE>
<P class="t">записывает значение переменной <KBD>count</KBD> в переменную <KBD>q</KBD>. В нашем примере переменная <KBD>q</KBD> получит значение 100, потому что по адресу 2000 записано число 100, причем этот адрес записан в переменной <KBD>m</KBD>. Выражение "* адрес" означает "по адресу". Наш фрагмент программы можно прочесть как "<KBD>q</KBD> получает значение, расположенное по адресу <KBD>m</KBD>".
<P class="tj">К сожалению, символ операции раскрытия ссылки совпадает с символом операции умножения, а символ операции получения адреса — с символом операции поразрядного И. Необходимо помнить, что эти операторы не имеют никакого отношения друг к другу. Операторы * и & имеют более высокий приоритет, чем любая арифметическая операция, кроме унарного минуса, имеющего такой же приоритет.
<P class="tj">Если переменная является указателем, то в объявлении перед ее именем нужно поставить символ *, он сообщит компилятору о том, что это указатель на переменную данного типа. Например, объявление указателя на переменную типа char записывается так:
<PRE>char *ch;</PRE>
<P class="tj">Необходимо понимать, что <KBD>ch</KBD> — это не переменная типа <KBD>char</KBD>, а указатель на переменную данного типа, это совершенно разные вещи. Тип данных, на который указывает указатель (в данном случае это <KBD>char</KBD>), называется <I>базовым типом</I> указателя<SUP><A href="#1414" name="014">[14]</A></SUP>. Сам указатель является переменной, содержащей адрес объекта базового типа. Компилятор учтет размер указателя в архитектуре компьютера и выделит для него необходимое количество байтов, чтобы в указатель поместился адрес. Базовый тип указателя определяет тип объекта, хранящегося по этому адресу.
<P class="tj">В одном операторе объявления можно одновременно объявить и указатель, и переменную, не являющуюся указателем. Например, оператор
<PRE>int x, *y, count;</PRE>
<P class="t">объявляет <KBD>х</KBD> и <KBD>count</KBD> как переменные целого типа, а <KBD>у</KBD> — как указатель на переменную целого типа.
<P class="tj">В следующей программе операторы * и & используются для записи значения 10 в переменную <KBD>target</KBD>. Программа выведет значение 10 на экран.
<PRE>
#include &lt;stdio.h&gt;

int main(void)
{
  int target, source;
  int *m;

  source = 10;
  m = &source;
  target = *m;

  printf("%d", target);

  return 0;
}
</PRE>
<H2>Операция определения размера sizof</H2>
<P class="tj">Унарная операция <KBD>sizeof</KBD>, выполняемая во время компиляции программы, позволяет определить длину операнда в байтах. Например, если компилятор для чисел типа <KBD>int</KBD> отводит 4 байта, а для чисел типа <KBD>double</KBD> — 8, то следующая программа напечатает 8 4.
<PRE>
double f;

printf("%d ", sizeof f);
printf("%d", sizeof(int));
</PRE>
<P class="tj">Необходимо помнить, что для вычисления размера типа переменной имя типа должно быть заключено в круглые скобки. Имя переменной заключать в скобки не обязательно, но ошибки в этом не будет.
<P class="tj">В языке С определяется (с помощью спецификатора класса памяти <KBD>typedef</KBD>) специальный тип <KBD>size_t</KBD>, приблизительно соответствующий целому числу без знака. Результат операции <KBD>sizeof</KBD> имеет тип <KBD>size_t</KBD>. Но практически его можно использовать везде, где допустимо использование целого числа без знака.
<P class="tj">Оператор <KBD>sizeof</KBD> очень полезен для улучшения переносимости программ, так как переносимость существенно зависит от размеров встроенных типов данных. Для примера рассмотрим программу, работающую с базой данных, в которой необходимо хранить шесть целых чисел в одной записи. Если эта программа предназначена для работы на многих компьютерах, ни в коем случае нельзя полагаться на то, что размер целого числа на всех компьютерах будет один и тот же. В программе следует определять размер целого, используя оператор <KBD>sizeof</KBD>. Соответствующая программа имеет следующий вид:
<PRE>
/* Запись шести целых чисел в дисковый файл. */
void put_rec(int rec[6], FILE *fp)
{
  int len; 

  len = fwrite(rec, sizeof(int)*6, 1, fp);
  if(len != 1) printf("Ошибка при записи");
}
</PRE>
<P class="tj">Приведенная функция <KBD>put_rec()</KBD> компилируется и выполняется правильно в любой среде, в том числе на 16- и 32-разрядных компьютерах.
<P class="tj">И в заключение: оператор <KBD>sizeof</KBD> выполняется во время трансляции, его результат в программе рассматривается как константа.
<H2>Оператор последовательного вычисления: оператор "запятая"</H2>
<P class="tj"><I>Оператор "запятая"</I><SUP><A href="#1515" name="015">[15]</A></SUP> связывает воедино несколько выражений. При вычислении левой части оператора "запятая" всегда подразумевается, что она имеет тип <KBD>void</KBD>. Это значит, что выражение, стоящее справа после оператора "запятая", является значением всего разделенного запятыми выражения. Например, оператор
<PRE>x = (y=3, y+1);</PRE>
<P class="t">сначала присваивает <KBD>у</KBD> значение 3, а затем присваивает <KBD>х</KBD> значение 4. Скобки здесь обязательны, потому что приоритет оператора "запятая" меньший, чем оператора присваивания.
<P class="tj">В операторе "запятая" выполняется последовательность операций. Если этот оператор стоит в правой части оператора присваивания, то его результатом всегда является выражение, стоящее последним в списке.
<H2>Оператор доступа к члену структуры (оператор . (точка)) и оператор доступа через указатель -&gt; (оператор стрелка)</H2>
<P class="tj">В языке С операторы . (точка) и -&gt; (стрелка) обеспечивают доступ к элементам структур и объединений. <I>Структуры</I> и <I>объединения</I> — это составные типы данных, в которых под одним именем хранятся многие объекты. (Структуры и объединения подробно рассматриваются в <A href="../07/07.htm">главе 7</A>.)
<P class="tj">Оператор точка используется для прямой ссылки на элемент структуры или объединения, т.е. перед точкой стоит имя структуры, а после — имя элемента структуры. Оператор стрелка используется с указателем на структуру или объединение, т.е. перед стрелкой стоит указатель на структуру. Например, во фрагменте программы
<PRE>
struct employee
{
  char name[80];
  int age;
  float wage;
} emp; 

struct employee *p = &emp; /* адрес emp заносится в p */
</PRE>
<P class="t">для присвоения члену <KBD>wage</KBD> значения 123.33 необходимо записать
<PRE>emp.wage = 123.23;</PRE>
<P class="tj">То же самое можно сделать, использовав указатель на структуру:
<PRE>p-&gt;wage = 123.23;</PRE>
<H2>Оператор [] и ()</H2>
<P class="tj">Круглые скобки являются оператором, повышающим приоритет выполнения операций, которые в них заключены. Квадратные скобки служат для индексации массива (массивы подробно рассматриваются в <A href="../04/04.htm">главе 4</A>). Если в программе определен массив, то выражение в квадратных скобках представляет собой индекс массива. Например, в программе
<PRE>
#include &lt;stdio.h&gt;
char s[80];

int main(void)
{
  s[3] = 'X';
  printf("%c", s[3]);

  return 0;
} 
</PRE>
<P class="t">значение 'Х' сначала присваивается четвертому элементу массива (в С элементы массива нумеруются с нуля), затем этот элемент выводится на экран.
<H2>Сводка приоритетов операций</H2>
<P class="tj">В табл. 2.8 приведены приоритеты всех операций, определенных в С. Необходимо помнить, что все операторы, кроме унарных и "?", связывают (присоединяют, ассоциируют) свои операнды слева направо. Унарные операторы (*, &, -) и "?" связывают (присоединяют, ассоциируют) свои операнды справа налево.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.8. Приоритеты опреаций в языке C</B><CAPTION>
<TR><TH><I>Наивысший</I><TH align=left>( ) [ ] -&gt; .
<TR><TD><TD>! ~ ++ -- - (type) * & sizeof<BR>* / %<BR>+ -<BR>&lt;&lt; &gt;&gt;<BR>&lt; &lt;= &gt; &gt;=<BR>== !=<BR>&<BR>^<BR>|<BR>&&<BR>||<BR>?:<BR>= += -= *= /= и т.д.
<TR><TH><I>Наинизший</I><TH align=left>,
</TABLE>
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>В данном случае под оператором имеется в виду, конечно, знак операции. По этому поводу см. сделанное ранее примечание редактора о переводе термина <I>operator</I>
<P class="tj"><SUP><A href="#2" name="22">[2]</A></SUP><I>lvalue</I> — именующее выражение, т.е. выражение, которое может стоять в левой части оператора присваивания. Под lvalue также часто подразумевается адрес переменной. (С идентификатором переменной в программе связано две величины: адрес переменной и ее значение. Адрес используется, когда переменная стоит в левой части присваивания, значение — в правой части присваивания.) Иногда встречается и термин <I>l-значение</I>. Как бы то ни было, этим термином обозначается выражение, которое может находиться в левой части оператора присваивания. Семантически оно представляет собой адрес, по которому размещена переменная, массив, элемент структуры и т.п.
<P class="tj"><SUP><A href="#3" name="33">[3]</A></SUP><I>rvalue</I> — значение переменной; иногда переводится, как <I>r-значение</I>, т.е. значение в правой части оператора присваивания.
<P class="tj"><SUP><A href="#4" name="44">[4]</A></SUP><I>Множественное присваивание</I> — присваивание одного и того же значения нескольким переменным. Под множественным присваиванием также подразумевается конструкция языка программирования, позволяющая присвоить одно и то же значение нескольким переменным одновременно.
<P class="tj"><SUP><A href="#5" name="55">[5]</A></SUP>По этой причине варианты оператора присваивания, в которых используется такая запись, называются "сокращенными" или "укороченными". Что касается терминологии, то необходимо отметить также следующее обстоятельство. Хотя термины <I>присваивание</I> и <I>оператор присваивания</I> часто могут рассматриваться как синонимы, составное присваивание не является составным оператором! (Под составным оператором в языке С подразумевают блок.)
<P class="tj"><SUP><A href="#6" name="66">[6]</A></SUP>Под "составными" операторами в данном случае, конечно, подразумеваются составные знаки операций, т.е. знаки операций, состоящие из нескольких (обычно двух) символов. Составные операторы-блоки не имеют к этому никакого отношения.
<P class="tj"><SUP><A href="#7" name="77">[7]</A></SUP>На жаргоне программистов: <I>декрементация</I>.
<P class="tj"><SUP><A href="#8" name="88">[8]</A></SUP>На жаргоне программистов: <I>инкрементация</I>.
<P class="tj"><SUP><A href="#9" name="99">[9]</A></SUP>Называются также <I>битовыми</I>, <I>побитовыми</I> и <I>логическими операциями</I>.
<P class="tj"><SUP><A href="#010" name="1010">[10]</A></SUP><I>Бит контроля четности</I> называется также  контрольным двоичным разрядом четности, контрольным разрядом четности,  проверочным двоичным разрядом четности, проверочным разрядом четности, битом четности, разрядом четности, контрольным битом и битом контроля на четность. Это дополнительный бит, который добавляется к группе (обычно из семи) битов. Передающее устройство устанавливает значение бита четности равным нулю или единице так, чтобы сумма битов в каждом байте всегда была четной или нечетной в зависимости от выбора типа проверки — на четность или нечетность. Невыполнение условия такой проверки на приемном конце линии означает искажение по крайней мере одного бита при передаче. При обнаружении ошибки принимающее устройство делает запрос на повтор данных. Иными словами, это бит, добавляемый к данным для контроля их верности таким образом, чтобы сумма двоичных единиц, составляющих данное, включая единицу контрольного бита, всегда была четной (либо всегда нечетной). 
<P class="tj"><SUP><A href="#011" name="1111">[11]</A></SUP><I>Очищение бита</I> — гашение, т.е. занесение нуля.
<P class="tj"><SUP><A href="#012" name="1212">[12]</A></SUP><I>Оператор &</I> называется также <I>оператором получения (взятия) адреса</I>.
<P class="tj"><SUP><A href="#013" name="1313">[13]</A></SUP><I>Оператор *</I> называется также <I>оператором косвенности, оператором раскрытия ссылки</I> и <I>оператором разыменования адреса</I>.
<P class="tj"><SUP><A href="#014" name="1414">[14]</A></SUP>Иногда называется также <I>основным</I> или <I>исходным</I> типом.
<P class="tj"><SUP><A href="#015" name="1515">[15]</A></SUP>Чаще встречается написание без кавычек: <I>оператор запятая</I>. Мы пишем кавычки лишь для того, чтобы новичкам было легче воспринимать несколько непривычное для них название оператора.
</BLOCKQUOTE> 
<HR><A href="../main.htm#02">Содержание</A> | <A href="0209.htm">&lt;&lt;&lt;</A> | <A href="0211.htm">&gt;&gt;&gt;</A>
</BODY></HTML>