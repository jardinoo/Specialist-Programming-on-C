<HTML><HEAD>
<TITLE>Модификация базовых типов</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#02">Содержание</A> | <A href="0201.htm">&lt;&lt;&lt;</A> | <A href="0203.htm">&gt;&gt;&gt;</A><HR>
<H1>Модификация базовых типов</H1>
<P class="tj">Базовые типы данных (кроме <KBD>void</KBD>) могут иметь различные <I>спецификаторы</I><SUP><A href="#11" name="1">[1]</A></SUP>, предшествующие им в тексте программы. Спецификатор типа так изменяет значение базового типа, чтобы он более точно соответствовал своему назначению в программе. Полный список спецификаторов типов:
<PRE>
signed
unsigned
long
short
</PRE>
<P class="tj">Базовый тип <KBD>int</KBD> может быть модифицирован каждым из этих спецификаторов. Тип <KBD>char</KBD> модифицируется с помощью <KBD>unsigned</KBD> и <KBD>signed</KBD>, <KBD>double</KBD> — с помощью <KBD>long</KBD>. (Стандарт С99 также позволяет модифицировать <KBD>long</KBD> с помощью <KBD>long</KBD>, создавая таким образом <KBD>long long</KBD>, см. <A href="../II.htm">часть II</A>). В табл. 2.1 приведены все допустимые комбинации типов данных с их минимальным диапазоном значений и типичным размером. Обратите внимание, в таблице приведены <I>минимально возможные</I>, а не типичные диапазоны значений. Например, если в компьютере арифметические операции выполняются над числами в дополнительных кодах (а именно так спроектированы почти все компьютеры!), то в диапазон значений целых попадут все целые числа от -32767 до 32768.</P>
<TABLE align=center border=1 width=100%>
<CAPTION><B>Таблица 2.1. Все типы данных, определенные Стандартом C</B><CAPTION>
<TR><TH><I>Тип</I><TH><I>Типичный размер в битах</I><TH><I>Минимально допустимый диапозон значений</I>
<TR><TD>char<TD>8<TD>от -127 до 127
<TR><TD>unsigned char<TD>8<TD>от 0 до 255
<TR><TD>signed char<TD>8<TD>от -127 до 127
<TR><TD>int<TD>16 или 32<TD>от -32767 до 32767
<TR><TD>unsigned int<TD>16 или 32<TD>от 0 до 65535
<TR><TD>signed int<TD>16 или 32<TD>то же, что int
<TR><TD>short int<TD>16<TD>от -32767 до 32767
<TR><TD>unsigned short int<TD>16<TD>от 0 до 65535
<TR><TD>signed short int<TD>16<TD>то же, что short int
<TR><TD>long int<TD>32<TD>от -2 147 483 647 до 2 147 483 647
<TR><TD>long long int<TD>64<TD>от -(2<SUP>63</SUP>-1) до (2<SUP>63</SUP>-1), добавлен стандартом C99 
<TR><TD>signed long int<TD>32<TD>то же, что long int
<TR><TD>unsigned long int<TD>32<TD>от 0 до 4 294 967 295
<TR><TD>unsigned long long int<TD>64<TD>от 0 до (2<SUP>64</SUP>-1), добавлен в C99
<TR><TD>float<TD>32<TD>от 1E-37 до 1E+37, с точностью не менее 6 значащих десятичных цифр
<TR><TD>double<TD>64<TD>от 1E-37 до 1E+37, с точностью не менее 10 значащих десятичных цифр
<TR><TD>long double<TD>80<TD>от 1E-37 до 1E+37, с точностью не менее 10 значащих десятичных цифр
</TABLE>
<P class="tj">Для целых можно использовать спецификатор <KBD>signed</KBD>, но в этом нет необходимости, потому что при объявлении целого он предполагается по умолчанию. Спецификатор <KBD>signed</KBD> чаще всего используется для типа <KBD>char</KBD>, который в некоторых реализациях по умолчанию может быть беззнаковым.
<P class="tj">Целые числа со знаком и без знака отличаются интерпретацией нулевого бита числа. Если целое объявлено со знаком, компилятор считает, что нулевой бит содержит знак числа. Если в нулевом бите записан 0, число считается положительным, а если 1 — отрицательным.
<P class="tj">В большинстве реализаций отрицательные числа представлены в <I>двоичном дополнительном коде</I>. Это значит, что для отрицательного числа все биты, кроме нулевого, инвертируются, к полученному числу добавляется 1, а нулевой бит устанавливается в 1.
<P class="tj">Целые числа со знаком используются почти во всех алгоритмах, но абсолютная величина наибольшего из них составляет примерно только половину максимального целого без знака. Например, знаковое целое число 32767 в двоичном коде имеет вид
<PRE>01111111 11111111</PRE>
<P class="tj">Если в нулевой бит записать 1, то оно будет интерпретироваться как —1. Однако если полученную запись рассматривать как представление числа, объявленного как <KBD>unsigned int</KBD>, то оно будет интерпретироваться как 65535.
<P class="tj">Если спецификатор типа записать сам по себе (без следующего за ним базового типа), то предполагается, что он модифицирует тип <KBD>int</KBD>. Таким образом, следующие спецификаторы типов эквивалентны:</P>
<TABLE align=center border=1 width=100%>
<TR><TH><I>Спецификатор</I><TH><I>То же самое</I>
<TR><TD>signed<TD>signed int
<TR><TD>unsigned<TD>unsigned int
<TR><TD>long<TD>long int
<TR><TD>short<TD>short int
</TABLE>
<P class="tj">Хотя базовый тип <KBD>int</KBD> и предполагается по умолчанию, его, тем не менее, обычно указывают явно.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Называются также <I>описателями</I>, <I>модификаторами</I> и <I>квалификаторами</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#02">Содержание</A> | <A href="0201.htm">&lt;&lt;&lt;</A> | <A href="0203.htm">&gt;&gt;&gt;</A>
</BODY></HTML>