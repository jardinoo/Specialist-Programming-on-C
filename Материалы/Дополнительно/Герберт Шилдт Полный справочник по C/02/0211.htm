<HTML><HEAD>
<TITLE>Выражения</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#02">Содержание</A> | <A href="0210.htm">&lt;&lt;&lt;</A> | <A href="../03/03.htm">&gt;&gt;&gt;</A><HR>
<H1>Выражения</H1>
<P class="tj">Выражения состоят из операторов, констант, функций и переменных. В языке С выражением является любая правильная последовательность этих элементов. Большинство выражений в языке С по форме очень похожи на алгебраические, часто их и пишут, руководствуясь правилами алгебры. Однако здесь необходимо быть внимательным и учитывать специфику выражений в языке С.
<H2>Порядок вычислений</H2>
<P class="tj">Порядок вычисления подвыражений в выражениях языка С не определен. Компилятор может самостоятельно перестроить выражение с целью создания оптимального объектного кода. Это значит, что программист не может полагаться на определенную последовательность вычисления подвыражений. Например, при вычислении выражения
<PRE>х = f1() + f2();</PRE>
<P class="t">нет никаких гарантий того, что функция <KBD>f1()</KBD> будет вызвана перед вызовом <KBD>f2()</KBD>.
<H2>Преобразования типов в выражениях</H2>
<P class="tj">Если в выражении встречаются переменные и константы разных типов, они преобразуются к одному типу. Компилятор преобразует "меньший" тип в "больший". Этот процесс называется <I>продвижением типов</I> (<I>type promotion</I>). Сначала все переменные типов <KBD>char</KBD> и <KBD>short int</KBD> автоматически продвигаются в <KBD>int</KBD>. Это называется целочисленным расширением. (В С99 целочисленное расширение может также завершиться преобразованием в <KBD>unsigned int</KBD>.) После этого все остальные операции выполняются одна за другой, как описано в приведенном ниже алгоритме преобразования типов:
<PRE>
IF операнд имеет тип <B>long double</B>
THEN второй операнд преобразуется в <B>long double</B>
ELSE IF операнд имеет тип <B>double</B>
THEN второй операнд преобразуется в <B>double</B>
ELSE IF операнд имеет тип <B>float</B>
THEN второй операнд преобразуется в <B>float</B>
ELSE IF операнд имеет тип <B>unsigned long</B>
THEN второй операнд преобразуется в <B>unsigned long</B>
ELSE IF операнд имеет тип <B>long</B>
THEN второй операнд преобразуется в <B>long</B>
ELSE IF операнд имеет тип <B>unsigned int</B>
THEN второй операнд преобразуется в <B>unsigned int</B>
</PRE>
<P class="tj">Для тех, кто еще не знаком с общей формой оператора IF, приводим более русифицированную запись алгоритма:
<PRE>
ЕСЛИ операнд имеет тип <B>long double</B>
ТО второй операнд преобразуется в <B>long double</B>
ИНАЧЕ ЕСЛИ операнд имеет тип <B>double</B>
ТО второй операнд преобразуется в <B>double</B>
ИНАЧЕ ЕСЛИ операнд имеет тип <B>float</B>
ТО второй операнд преобразуется в <B>float</B>
ИНАЧЕ ЕСЛИ операнд имеет тип <B>unsigned long</B>
ТО второй операнд преобразуется в <B>unsigned long</B>
ИНАЧЕ ЕСЛИ операнд имеет тип <B>long</B>
ТО второй операнд преобразуется в <B>long</B>
ИНАЧЕ ЕСЛИ операнд имеет тип <B>unsigned int</B>
ТО второй операнд преобразуется в <B>unsigned int</B>
</PRE>
<P class="tj">Кроме того, действует следующее правило: если один из операндов имеет тип <KBD>long</KBD>, а второй — <KBD>unsigned int</KBD>, притом значение <KBD>unsigned int</KBD> не может быть представлено типом <KBD>long</KBD>, то оба операнда преобразуются в <KBD>unsigned long</KBD>.</P>
<TABLE align=center border=1 width=100%>
<TR><TD align=center bgcolor=skyblue width=7%>На заметку<TD class="tj">Описание правил целочисленного расширения в С99 см. в <A href="../II.htm">части II</A>.
</TABLE>
<P class="tj">После выполнения приведенных выше преобразований оба операнда относятся к одному и тому же типу, к этому типу относится и результат операции.
<P class="tj">Рассмотрим пример преобразования типов, приведенный на рис. 2.2. Сначала символ <KBD>ch</KBD> преобразуется в целое число. Результат операции <KBD>ch/i</KBD> преобразуется в <KBD>double</KBD>, потому что результат <KBD>f*d</KBD> имеет тип <KBD>double</KBD>. Результат операции <KBD>f+i</KBD> имеет тип <KBD>float</KBD>, потому что <KBD>f</KBD> имеет тип <KBD>float</KBD>. Окончательный результат имеет тип <KBD>double</KBD>.
<TABLE align=center width=100%>
<CAPTION align=bottom><P class="tj"><I>Рис. 2.2. Пример преобразования типов</I>
<TR><TD>
<PRE>
  char    ch;
  int     i;
  float   f;
  double  d;
  
  r  e  s  u  l  t  =  (  ch  /  i  )  +  (  f  *  d  )  -  (  f  +  i  )  ;
                           |     |           |     |           |     |
                          int    |         double  |           |    float
                           |_____|           |_____|           |_____|
                              |                 |                 |
                             int              double             float
                              |_________________|                 |
                                       |__________________________|
                                                    |
                                                  double
</PRE>
</TABLE>
<H2>Явное преоразование типов: операция приведения типов</H2>
<P class="tj">Программист может "принудительно" преобразовать значение выражения к нужному ему типу, используя операцию приведения типов. Общая форма оператора явного приведения типа:
<PRE><I>(тип) выражение</I></PRE>
<P class="tj">Здесь <I>тип</I> — это любой поддерживаемый тип данных. Например, следующая запись преобразует значение выражения <KBD>х/2</KBD> к типу <KBD>float</KBD>:
<PRE>(float) х/2</PRE>
<P class="tj">Явное преобразование типа — это операция. Оператор приведения типа является унарным и имеет тот же приоритет, что и остальные унарные операторы.
<P class="tj">Иногда приведение типов может быть весьма полезным. Допустим, целую переменную нужно использовать как параметр цикла, притом в вычислении участвует и дробная часть числа. В следующем примере показано, как с помощью приведения можно сохранить точность:
<PRE>
#include &lt;stdio.h&gt;

int main(void) /* печать i и i/2 с дробной частью */
{
  int i;

  for(i=1; i&lt;=100; ++i)
    printf("%d / 2 is: %f\n", i, (float) i /2);

  return 0;
}
</PRE>
<P class="tj">Без операции приведения <KBD>(float)</KBD> выполнялось бы целочисленное деление. Дробная часть результата выводится благодаря приведению типа переменной <KBD>i</KBD>.
<H2>Пробелы и круглые скобки</H2>
<P class="tj">Для повышения удобочитаемости программы при записи выражений можно использовать пробелы и символы табуляции. Например, следующие два оператора эквивалентны:
<PRE>
x=10/y~(127/x);

x = 10 / y ~(127/x);
</PRE>
<P class="tj">Лишние скобки, если они не изменяют приоритет операций, не приводят к ошибке и не замедляют вычисление выражения. Дополнительные скобки часто используют для прояснения порядка вычислений. В следующем примере 2-я строка читается значительно легче:
<PRE>
x = y/3-34*temp+127;

x = (y/3) - (34*temp) + 127;
</PRE>
<HR><A href="../main.htm#02">Содержание</A> | <A href="0210.htm">&lt;&lt;&lt;</A> | <A href="../03/03.htm">&gt;&gt;&gt;</A>
</BODY></HTML>