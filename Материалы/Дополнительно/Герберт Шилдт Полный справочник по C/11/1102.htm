<HTML><HEAD>
<TITLE>Указатели, определенные с квалификаторами типа restrict</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#11">Содержание</A> | <A href="1101.htm">&lt;&lt;&lt;</A> | <A href="1103.htm">&gt;&gt;&gt;</A><HR>
<H1>Указатели, определенные с квалификаторами типа restrict</H1>
<P class="tj">Одной из самых важных новинок, введенных Стандартом С99, является квалификатор типа <KBD>restrict</KBD> (ограниченный). Этот квалификатор применяется только к указателям. Указатель, определенный с квалификатором типа <KBD>restrict</KBD><SUP><A href="#11" name="1">[1]</A></SUP>, изначально является единственным средством, с помощью которого можно получить доступ к указываемому объекту. Доступ к объекту с помощью другого указателя возможен лишь тогда, когда этот второй указатель основан на первом. Таким образом, доступ к объекту возможен только для выражений, составленных на основе указателя с квалификатором типа <KBD>restrict</KBD>. Такие указатели в основном используются как параметры функций или для указания памяти, распределенной с помощью <KBD>malloc()</KBD>. Квалификатор типа <KBD>restrict</KBD> семантики программы не меняет.
<P class="tj">Если указатель квалифицирован с помощью квалификатора типа <KBD>restrict</KBD>, то компилятор может лучше оптимизировать некоторые программы, зная, что указатель с квалификатором типа <KBD>restrict</KBD> является единственным средством доступа к объекту. Например, если функция имеет два параметра в виде указателей с квалификатором типа <KBD>restrict</KBD>, то компилятор может допустить, что указатели указывают на разные (причем неперекрывающиеся!) объекты. Проанализируем, например, то, что стало классическим примером применения <KBD>restrict</KBD> — определение функции <KBD>memcpy()</KBD>. В С89 у нее имеется следующий прототип:
<PRE>void *memcpy(void *<I>cmp1</I>, const void *<I>cmp2</I>, size_t <I>размер</I>);</PRE>
<P class="tj">В описании <KBD>memcpy()</KBD> сказано, что если объекты, на которые указывают <I>cmp1</I> и <I>cmp2</I>, перекрываются, то поведение этой функции непредсказуемое. Таким образом. <KBD>memcpy()</KBD> гарантированно будет работать только с неперекрывающимися объектами.
<P class="tj">В С99 можно использовать <KBD>restrict</KBD>, чтобы в прототипе <KBD>memcpy()</KBD> явно указать то, что в С89 приходится дополнительно объяснять словами. Вот прототип <KBD>memcpy()</KBD> в С99:
<PRE>void *memcpy(void * restrict <I>cmp1</I>, const void * restrict <I>cmp2</I>, size_t <I>размер</I>);</PRE>
<P class="tj">Квалифицируя <I>cmp1</I> и <I>cmp2</I> с помощью квалификатора типа <KBD>restrict</KBD>, в прототипе явно утверждается, что они указывают на неперекрывающиеся объекты.
<P class="tj">Из-за преимуществ, которые может принести использование квалификатора типа <KBD>restrict</KBD>, в С99 он был добавлен в прототипы многих библиотечных функций, определенных еще в С89.
<P><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" name="11">[1]</A></SUP>Указатель, определенный с квалификатором типа <KBD>restrict</KBD>, называется также <I>restrict-квалифицированным указателем</I> или <I>указателем, квалифицированным как restrict</I>.
</BLOCKQUOTE>
<HR><A href="../main.htm#11">Содержание</A> | <A href="1101.htm">&lt;&lt;&lt;</A> | <A href="1103.htm">&gt;&gt;&gt;</A>
</BODY></HTML>