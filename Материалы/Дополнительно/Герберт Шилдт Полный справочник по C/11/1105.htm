<HTML><HEAD>
<TITLE>Расширение массивов</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=Windows-1251"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#11">Содержание</A> | <A href="1104.htm">&lt;&lt;&lt;</A> | <A href="1106.htm">&gt;&gt;&gt;</A><HR>
<H1>Расширение массивов</H1>
<P class="tj">В Стандарте С99 появились два новых для С и достаточно важных свойства массивов: переменная длина и возможность включать в объявлениях массивов квалификаторы типа.
<H2>Массивы переменной длины</H2>
<P class="tj">В С89 размерности массивов необходимо объявлять при помощи выражений из целых констант, причем размер массива фиксируется во время компиляции. В силу определенных обстоятельств, в С99 это правило было изменено. В С99 можно объявить массив, размерности которого определяются любыми допустимыми целыми выражениями, в том числе и такими, значения которых становятся известны только во время выполнения. Такой массив называется <I>массивом переменной длины</I> (variable-length array, VLA). Однако такими массивами могут быть только локальные массивы (то есть те, у которых область видимости — прототип или блок). Вот пример массива переменной длины:
<PRE>
void f(int diml, int dim2)
{
  int matrix[diml][dim2]; /* двумерный массив переменной длины */
  /* ... */
}
</PRE>
<P class="tj">В данном случае размер <KBD>matrix</KBD> определяется значениями, передаваемыми функции <KBD>f()</KBD> через переменные <KBD>dim1</KBD> и <KBD>dim2</KBD>. Таким образом, в результате каждого вызова <KBD>f()</KBD> может получиться массив <KBD>matrix</KBD> с самыми разными измерениями.
<P class="tj">Важно понять, что массивы переменной длины за время "своей жизни" не меняют своих размеров. (Иными словами, они не являются динамическими.) На самом деле массив переменной длины создается с другим размером каждый раз, когда встречается его объявление.
<P class="tj">Можно указать массив переменной длины неуказанного размера, используя в качестве размера звездочку, *.
<P class="tj">Появление массивов переменной длины вызвало небольшое изменение в операторе <KBD>sizeof</KBD>. Вообще говоря, <KBD>sizeof</KBD> — это оператор, который вычисляется во время компиляции. То есть во время компиляции он обычно превращается в целую константу, значение которой равно размеру типа или объекта. Однако если <KBD>sizeof</KBD> применяется к массиву переменной длины, то свое значение он получает только во время выполнения. Это изменение было необходимо потому, что размер массива переменной длины нельзя узнать до времени выполнения.
<P class="tj">Одной из главных причин появления массивов переменной длины является желание упростить программирование численных методов. Конечно, это средство применяется довольно широко. Но помните — массивы переменной длины не поддерживаются Стандартом С89 (и в языке C++).
<H2>Использование квалификаторов типов в объявлении массива</H2>
<P class="tj">В С99 при объявлении массива в качестве параметра функции, внутри квадратных скобок этого объявления можно указать ключевое слово <KBD>static</KBD>. Оно сообщает компилятору, что в массиве, на который указывает этот параметр, всегда будет находиться как минимум названное количество элементов. Например:
<PRE>
int f(char str[static 80])
{
  // здесь str всегда является указателем на массив из 80 элементов
  //
}      
</PRE>
<P class="tj">Здесь дается гарантия, что <KBD>str</KBD> будет указывать на начало массива типа <KBD>char</KBD>, причем в нем будет не менее 80 элементов.
<P class="tj">Внутри квадратных скобок также допускаются ключевые слова <KBD>restrict</KBD>, <KBD>volatile</KBD> и <KBD>const</KBD>, но только для параметров функций. Использование <KBD>restrict</KBD> означает, что указатель изначально является единственным средством доступа к объекту. Применение <KBD>const</KBD> показывает, что указатель указывает на один и тот же массив (то есть указатель всегда указывает на один и тот же объект). Можно использовать и <KBD>volatile</KBD> (означает "асинхронно-изменяемый"), хотя и нет смысла это делать.
<HR><A href="../main.htm#11">Содержание</A> | <A href="1104.htm">&lt;&lt;&lt;</A> | <A href="1106.htm">&gt;&gt;&gt;</A>
</BODY></HTML>